{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"source/img/avatar/we.png","path":"img/avatar/we.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":0,"renderable":0},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/404.jpg","path":"img/header_img/404.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag.jpg","path":"img/header_img/tag.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":0,"renderable":0},{"_id":"source/img/blog.jpg","path":"img/blog.jpg","modified":0,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":0,"renderable":0},{"_id":"source/img/avatar/we.jpg","path":"img/avatar/we.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8b9e17605b69cf3d2b0cbf8ddc5c7357d538ccd9","modified":1575788116882},{"_id":"source/CNAME","hash":"60a9ce3696e7262df3d5ba09815b15082353176e","modified":1575788116882},{"_id":"themes/huweihuang/_config.yml","hash":"f29811ef62e8d1bec51d14eac30eae0d345b130a","modified":1575795257635},{"_id":"themes/huweihuang/LICENSE","hash":"c48eaae47a703282e0ffe7b91d69366452046214","modified":1575788117127},{"_id":"source/_posts/Front-Notes-2020-03.md","hash":"443d7137d979f21c2874b54ead93e55c93d55ff7","modified":1583225327192},{"_id":"source/_posts/FE-Technical-Docs-Collection.md","hash":"47bc3d4bed8ab7eafd8211f1df4681b305c90fb9","modified":1580886547922},{"_id":"source/_posts/FE-Resources-Collection.md","hash":"fafaaf5dd9e8e851e3e96272d856c9ee5b4d7a5f","modified":1583290088614},{"_id":"source/_posts/PaperReadingNotes2020-0223.md","hash":"56eaacbb27e66a3578aba02cd0c7c72963d5b056","modified":1582527095233},{"_id":"source/_posts/FrontEnd-Daily-Learning.md","hash":"c417d86ed060e4e70bed79b1082fdd9171ef3c29","modified":1583119317757},{"_id":"source/_posts/FrontEnd-Notes-2019-12.md","hash":"666482d88a364d1d7ccd828ef4bfa1ae96fb900c","modified":1577930268925},{"_id":"source/_posts/FrontEnd-Notes-2020-01.md","hash":"67be6d26783f422f71c9344c13d70a96e4368f7e","modified":1580191485218},{"_id":"source/_posts/We Are Graduated!.md","hash":"c75b86faa55caae69d57ef2ccf0138e0be0b419d","modified":1575788116892},{"_id":"source/_posts/FrontEnd-Notes-2020-02.md","hash":"bf4c78dc5cd12ac76576005edd5bae0ab21cbdcb","modified":1582806553472},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick.md","hash":"d78fd9ad10ac89959082577441ed07ae172e7420","modified":1575907751836},{"_id":"source/_posts/React-官方文档阅读笔记.md","hash":"4966442d45de92b0bc5f9f9eeb85f44a24e16873","modified":1581061991044},{"_id":"source/about/index.md","hash":"563abf8b0f19e4b3476e8ed0669b56bafc32a2dc","modified":1575797945824},{"_id":"source/_posts/Resources.md","hash":"a0b0f179d0e2cb4802b3b64ef5934660b518b75f","modified":1577930452567},{"_id":"source/archive/index.md","hash":"87e995582a1fedab64a901410a1a9d7390f75b94","modified":1575788116926},{"_id":"source/_posts/gitlab-runners-配置笔记.md","hash":"853cf7d906725c9cd30c0fa848d7e01da9a37a30","modified":1582817085600},{"_id":"source/_posts/《你不知道的-JavaScript》（上卷）-读书笔记.md","hash":"b0ba04f71e17c83c4e8f45d2c76505458a6a97a5","modified":1582527024981},{"_id":"source/tags/index.md","hash":"9a417cb743a80a4ea6e78e833c13d5faeba2508c","modified":1575798133019},{"_id":"themes/huweihuang/languages_to_be_added/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1575788117129},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1575790252732},{"_id":"themes/huweihuang/languages_to_be_added/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1575788117130},{"_id":"themes/huweihuang/languages_to_be_added/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1575788117130},{"_id":"themes/huweihuang/languages_to_be_added/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1575788117131},{"_id":"themes/huweihuang/languages_to_be_added/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1575788117134},{"_id":"themes/huweihuang/languages_to_be_added/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1575788117135},{"_id":"themes/huweihuang/languages_to_be_added/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1575788117136},{"_id":"themes/huweihuang/languages_to_be_added/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1575788117132},{"_id":"themes/huweihuang/languages_to_be_added/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1575788117132},{"_id":"themes/huweihuang/layout/404.ejs","hash":"2e8d719fab50014b7963d3c2f4ee34c23e749d7b","modified":1575788117137},{"_id":"themes/huweihuang/layout/archive.ejs","hash":"62781e8b0ce4de9c3db6042fedeaf13c26d138f8","modified":1575788117145},{"_id":"themes/huweihuang/layout/index.ejs","hash":"f293cefe4bf9f9c6848dff08b6dac4aeb7948892","modified":1575788117145},{"_id":"themes/huweihuang/layout/layout.ejs","hash":"389fc11a45676f94b77ebd2cb0d658a0358979c8","modified":1575788117146},{"_id":"themes/huweihuang/layout/about.ejs","hash":"96c08fc3580b842ad9d8f37f2cdf02e6fa57d7bc","modified":1575788117144},{"_id":"themes/huweihuang/layout/tags.ejs","hash":"63911a99e6daf9968bfdd7d69f0d3d697039902e","modified":1575788117148},{"_id":"themes/huweihuang/layout/keynote.ejs","hash":"e177b9e4a159f40b512f4ae1bfd928be4ab60840","modified":1575788117146},{"_id":"source/_posts/FrontEnd-Daily-Learning/FE_20190806.png","hash":"cf1e11f4935faca118ffa5ec422350393827b54b","modified":1575788116886},{"_id":"source/_posts/FrontEnd-Daily-Learning/FE_20190808.png","hash":"bca41264a7be4e31f610710c569b14e04e0e68a8","modified":1575788116887},{"_id":"source/_posts/FrontEnd-Daily-Learning/FE_20190809.png","hash":"8e381370d624b8863b6eb44fd2fa8e55c4ce5296","modified":1575788116888},{"_id":"themes/huweihuang/layout/page.ejs","hash":"f77a9eb0e09931eac85e8244027eb5678c7b0705","modified":1575788117147},{"_id":"themes/huweihuang/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1575788117150},{"_id":"themes/huweihuang/source/css/archive.styl","hash":"bcb216ef65804c97b1a5dbe5f519fc171a13aaf1","modified":1575788117149},{"_id":"themes/huweihuang/source/css/beantech.css","hash":"5e9bee0a553da83a3efd4e9bc975a0ebd13b1b7d","modified":1575788117149},{"_id":"themes/huweihuang/layout/post.ejs","hash":"1d5e2e84ed5d8e7679612ae07660128b02f8e954","modified":1575793973615},{"_id":"themes/huweihuang/source/css/donate.css","hash":"948c148076e7e0e0f78225f753813012938f5022","modified":1575788117153},{"_id":"themes/huweihuang/source/css/highlight.styl","hash":"831f8195f3577ba5bea374f2e24b90054d445055","modified":1575788117154},{"_id":"themes/huweihuang/source/css/signature.styl","hash":"63ae8051f59d5e69544647cc4173eabc81d99aae","modified":1575788117155},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1575788117154},{"_id":"themes/huweihuang/source/css/rocket.styl","hash":"0abbccdbcd6cce70e8a0bab7152c38adc0b708f1","modified":1575788117155},{"_id":"themes/huweihuang/source/css/toc.styl","hash":"e197d57dc5312b20974193b6991c779e266fadca","modified":1575788117156},{"_id":"themes/huweihuang/source/css/widget.styl","hash":"f996466e299c68274145ba5afaca9b6d1dd83114","modified":1575788117157},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1575788117160},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1575788117159},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1575788117157},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1575788117161},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","hash":"ee99af17a1a69ac8d85a695fed0349ba202789ae","modified":1575788117166},{"_id":"themes/huweihuang/source/js/hux-blog.js","hash":"3d3c93e42a9990b2a2e6df5a08e9816f9a221e0f","modified":1575788117165},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","hash":"313da686ebbe387064f2d1899c64ea562b81eb40","modified":1575788117164},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","hash":"448017ff32f75f444ed7985d10a21b3ad92ab100","modified":1575788117174},{"_id":"themes/huweihuang/source/js/jquery.nav.js","hash":"bc6383fa2aa8f437978cf044a3b6f10a65114398","modified":1575788117173},{"_id":"themes/huweihuang/source/js/toc.js","hash":"4ffe95b7755b035ee1b41664fa72b0ebea29c3f8","modified":1575788117174},{"_id":"themes/huweihuang/source/js/totop.js","hash":"f796b09b4f6177c3674a8c1542a8c92e8590cb5c","modified":1575788117175},{"_id":"themes/huweihuang/layout/_partial/head.ejs","hash":"07e23da21331914b971bb0317f545ea677484180","modified":1575788117139},{"_id":"themes/huweihuang/layout/_partial/header.ejs","hash":"10d5e0966895f86373b0652e9ad2df69d742bfe4","modified":1575788117140},{"_id":"themes/huweihuang/layout/_partial/sidebar.ejs","hash":"bc7834dd769eeac94a76ffd9cfbb13a622861b62","modified":1575788117141},{"_id":"themes/huweihuang/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1575788117141},{"_id":"themes/huweihuang/layout/_partial/footer.ejs","hash":"f3619af90437b15c757b2fdd37907cc6a7484e7d","modified":1575788117138},{"_id":"themes/huweihuang/layout/_partial/nav.ejs","hash":"e65bfec3d14a9eb9f1e09b592bb34023e6bf6e83","modified":1575788117140},{"_id":"themes/huweihuang/layout/_partial/toc.ejs","hash":"aa41fc56f2fa03559aa266fc062772e9e3bbebbf","modified":1575788117141},{"_id":"themes/huweihuang/layout/_widget/category.ejs","hash":"c32e6fb8f3a07c5cbaffcebf93c357237c18b009","modified":1575788117142},{"_id":"themes/huweihuang/layout/_widget/archive.ejs","hash":"ad9fb0073d40fe90bfe3a1e3246e0b07e12b3ecf","modified":1575788117142},{"_id":"themes/huweihuang/layout/_widget/featured-tags.ejs","hash":"e29431fa78c81d7c521bb1f7be356651fcde959c","modified":1575788117142},{"_id":"themes/huweihuang/layout/_widget/friends-blog.ejs","hash":"b185fcffb0d181ddd9eb2259af38cf7d82fb2846","modified":1575788117143},{"_id":"source/_posts/PaperReadingNotes2020-0223/progressive_shrinking.png","hash":"0374e42f70486bf39358b4de0e7092981b088228","modified":1582527095247},{"_id":"source/_posts/PaperReadingNotes2020-0223/ofa-results1.png","hash":"9e7665874afd1bd8f93a5c91412a5402a6bdc64a","modified":1582527095238},{"_id":"source/_posts/Reinforcement-Learning-Post-1-Basic-Knowledge-and-Background/LDS-GNN.png","hash":"5fcbe43d5637218a0a05b5938af037d262ebd53e","modified":1575788116891},{"_id":"themes/huweihuang/layout/_widget/recent-posts.ejs","hash":"814dd716083a8a75eb31f9d2d6ab28150b01c533","modified":1575788117143},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","hash":"1818a346630e7133a1f194669f613f613fcfa97c","modified":1575788117153},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1575788117158},{"_id":"themes/huweihuang/source/js/bootstrap.js","hash":"5d69034fb6eded2e5961ea54dd47129a88cd5182","modified":1575788117163},{"_id":"themes/huweihuang/source/js/jquery.min.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1575788117172},{"_id":"themes/huweihuang/layout/_widget/short-about.ejs","hash":"bc918e897eead442ca3b6e5a11824402a8aeb18d","modified":1575788117144},{"_id":"themes/huweihuang/source/css/bootstrap.css","hash":"d1a24afac31222d70b4e001e0361ef045aa42043","modified":1575788117151},{"_id":"themes/huweihuang/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1575788117155},{"_id":"themes/huweihuang/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1575788117155},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1575788117125},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1575788117121},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/re-paramerise.png","hash":"44fd0e604c5419e1aa8bc710b9696ed860f891cb","modified":1575788116906},{"_id":"source/img/avatar/we.png","hash":"bcb66101bf0be4147664ad308baf85904e7054d5","modified":1575788117008},{"_id":"themes/huweihuang/source/js/jquery.js","hash":"4bb763dc96da604aed08ac024a1a3f5de73eea39","modified":1575788117170},{"_id":"source/img/header_img/home.jpg","hash":"67be147e02ddb76ea40a3c07e0f7e41805b52354","modified":1575817320311},{"_id":"source/img/article_header/article_bg.jpg","hash":"acc16e8a1e024239415bed316e09f481651c342d","modified":1575796664058},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/gumbel2.png","hash":"723753b396f4b0490ef5c831db3be60c3f0aff75","modified":1575788116902},{"_id":"source/img/header_img/404.jpg","hash":"5313a0db2c29e6ea1c48e952e48ffc59f931d169","modified":1575816281673},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/gumbel1.png","hash":"f4553c67e4b451a8461cfccd9ec7ebf767631b52","modified":1575788116897},{"_id":"source/img/header_img/tag.jpg","hash":"f16f692e9fd31cba89b2df25d23079260a8fe8ec","modified":1575816045471},{"_id":"source/img/header_img/about.jpg","hash":"eee9ab1704c5220d629cc552611954c8f1420137","modified":1575815839059},{"_id":"source/img/blog.jpg","hash":"a76af0b98dbe92ca2d21babcef13f094e409554b","modified":1575790252731},{"_id":"source/_posts/hexo-theme-huweihuang/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1575790252725},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1575788116952},{"_id":"source/img/header_img/archive.jpg","hash":"78ab7bc8c864c0e1922cd5229ff115edf80f999d","modified":1575815899943},{"_id":"source/img/avatar/we.jpg","hash":"86b6728028a68a6ba9cbf1302ee08daa73e95d65","modified":1575788117005},{"_id":"source/_posts/FrontEnd-Daily-Learning-2020-03.md","hash":"8ba508bd6c681568bb2fc80d18c31fe224189d8d","modified":1584684601626},{"_id":"source/_posts/FrontEnd-Daily-Learning-2020-01.md","hash":"918b453bdad165f21ba4fbed0b9ff77e5ddafdec","modified":1583290282132},{"_id":"source/_posts/FrontEnd-Daily-Learning-2020-02.md","hash":"6c941634611049df0c36d39f1b8b41a35d15d342","modified":1583290282132},{"_id":"source/_posts/FrontEnd-Daily-Learning-2019-07-08.md","hash":"c417d86ed060e4e70bed79b1082fdd9171ef3c29","modified":1583290672500},{"_id":"source/_posts/FrontEnd-Daily-Learning-2019-12.md","hash":"5f00c130f3b8e22db14bb6cf67871161beea1906","modified":1583290282132},{"_id":"source/_posts/FrontEnd-Daily-Learning-2019-07-08/FE_20190806.png","hash":"cf1e11f4935faca118ffa5ec422350393827b54b","modified":1575788116886},{"_id":"source/_posts/FrontEnd-Daily-Learning-2019-07-08/FE_20190808.png","hash":"bca41264a7be4e31f610710c569b14e04e0e68a8","modified":1575788116887},{"_id":"source/_posts/FrontEnd-Daily-Learning-2019-07-08/FE_20190809.png","hash":"8e381370d624b8863b6eb44fd2fa8e55c4ce5296","modified":1575788116888}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2019-12-08T06:55:16.882Z","updated":"2019-12-08T06:55:16.882Z","path":"404.html","title":"","comments":1,"_id":"ck7bsdjrs0000csueumzxnm0x","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2017-10-03T02:48:33.000Z","description":"Enjoy Coding, Enjoy Life","header-img":"/img/header_img/about.jpg","aplayer":false,"fixed":false,"_content":"\n### Who Are We?\n\nWe are lovers:couple_with_heart: graduated from [School of Data and Computer Science](http://sdcs.sysu.edu.cn/) in [Sun Yat-Sen university](http://www.sysu.edu.cn/2012/en/index.htm). \n\n### What This Blog for?\n\nWe build this site to track our life and thoughts.\n\n### What Are in This Blog?\n\nWe are interested in Front-end technologies, Machine Learning & Deep Learning Algorithms.  \nWe also track our life moments here.\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2017-10-03 10:48:33\ndescription: \"Enjoy Coding, Enjoy Life\"\nheader-img: \"/img/header_img/about.jpg\"\naplayer: false\nfixed: false\n---\n\n### Who Are We?\n\nWe are lovers:couple_with_heart: graduated from [School of Data and Computer Science](http://sdcs.sysu.edu.cn/) in [Sun Yat-Sen university](http://www.sysu.edu.cn/2012/en/index.htm). \n\n### What This Blog for?\n\nWe build this site to track our life and thoughts.\n\n### What Are in This Blog?\n\nWe are interested in Front-end technologies, Machine Learning & Deep Learning Algorithms.  \nWe also track our life moments here.\n","updated":"2019-12-08T09:39:05.824Z","path":"about/index.html","comments":1,"_id":"ck7bsdjsj0002csuemy0tz90c","content":"<h3 id=\"who-are-we\"><a href=\"#Who-Are-We\" class=\"headerlink\" title=\"Who Are We?\"></a>Who Are We?</h3><p>We are lovers:couple_with_heart: graduated from <a href=\"http://sdcs.sysu.edu.cn/\" target=\"_blank\" rel=\"noopener\">School of Data and Computer Science</a> in <a href=\"http://www.sysu.edu.cn/2012/en/index.htm\" target=\"_blank\" rel=\"noopener\">Sun Yat-Sen university</a>. </p>\n<h3 id=\"what-this-blog-for\"><a href=\"#What-This-Blog-for\" class=\"headerlink\" title=\"What This Blog for?\"></a>What This Blog for?</h3><p>We build this site to track our life and thoughts.</p>\n<h3 id=\"what-are-in-this-blog\"><a href=\"#What-Are-in-This-Blog\" class=\"headerlink\" title=\"What Are in This Blog?\"></a>What Are in This Blog?</h3><p>We are interested in Front-end technologies, Machine Learning &amp; Deep Learning Algorithms.<br>We also track our life moments here.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Who-Are-We\"><a href=\"#Who-Are-We\" class=\"headerlink\" title=\"Who Are We?\"></a>Who Are We?</h3><p>We are lovers:couple_with_heart: graduated from <a href=\"http://sdcs.sysu.edu.cn/\" target=\"_blank\" rel=\"noopener\">School of Data and Computer Science</a> in <a href=\"http://www.sysu.edu.cn/2012/en/index.htm\" target=\"_blank\" rel=\"noopener\">Sun Yat-Sen university</a>. </p>\n<h3 id=\"What-This-Blog-for\"><a href=\"#What-This-Blog-for\" class=\"headerlink\" title=\"What This Blog for?\"></a>What This Blog for?</h3><p>We build this site to track our life and thoughts.</p>\n<h3 id=\"What-Are-in-This-Blog\"><a href=\"#What-Are-in-This-Blog\" class=\"headerlink\" title=\"What Are in This Blog?\"></a>What Are in This Blog?</h3><p>We are interested in Front-end technologies, Machine Learning &amp; Deep Learning Algorithms.<br>We also track our life moments here.</p>\n"},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-12-08T06:55:16.926Z","path":"archive/index.html","_id":"ck7bsdjsl0004csue6rnmi0f1","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.jpg\"\n---\n","date":"2019-12-08T09:42:13.019Z","updated":"2019-12-08T09:42:13.019Z","path":"tags/index.html","comments":1,"_id":"ck7bsdjso0006csuewnoqfpls","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Paper Reading 2020-02-23","catalog":true,"date":"2020-02-23T12:48:34.000Z","subtitle":null,"header-img":null,"mathjax":true,"_content":"\n两篇论文的记录\n### Scaling Up Neural Architecture Search with Big Single-Stage Models\nUniversal slimmable network的kernel+depth+resolution扩展版，方法上没啥创新，所以被拒了  \n方法上就是Universal slimmable network那一套，然后加上了学习率和初始化的trick，之后要train这种包含多个子网络的网络可以借鉴一下里面的这些trick吧\n\nPaper:[Scaling Up Neural Architecture Search with Big Single-Stage Models](https://openreview.net/forum?id=HJe7unNFDH)  \nCodes:未开源\n\n### Once for All: Train One Network and Specialize it for Efficient Deployment \n和上一篇想法差不多，只是做的比较细，方法上看起来有点东西不是那么糙。\n\n![progressive shrinking](progressive_shrinking.png)\n训练的时候提出了一个progressive shrinking的方法，先训好最大的网络，然后一步一步从kernel，depth和width进行elastic训练，中间kernel使用了一个transformation matrix，width用了channel sortting.\n\n结果方面，最终效果很好就对了，finetune以后效果还能继续提高\n![results](ofa-results1.png)\n\nPaper:[Once for All: Train One Network and Specialize it for Efficient Deployment ](https://openreview.net/forum?id=HylxE1HKwS)  \nCodes:[github](https://github.com/mit-han-lab/once-for-all)  \n总的来看，其实也没有很创新的方法，只是看起来比上一篇细致一些然后实验上也充分，但实现上感觉还是很tricky不知道有多少水分。代码上感觉没有把完整过程开源出来，需要多机多卡的话复现也是个大麻烦，issue也不回，只能再观望一下看看怎么往detection走。\n\n","source":"_posts/PaperReadingNotes2020-0223.md","raw":"---\ntitle: Paper Reading 2020-02-23\ncatalog: true\ndate: 2020-02-23 20:48:34\nsubtitle:\nheader-img:\nmathjax: true\ntags: ML\n---\n\n两篇论文的记录\n### Scaling Up Neural Architecture Search with Big Single-Stage Models\nUniversal slimmable network的kernel+depth+resolution扩展版，方法上没啥创新，所以被拒了  \n方法上就是Universal slimmable network那一套，然后加上了学习率和初始化的trick，之后要train这种包含多个子网络的网络可以借鉴一下里面的这些trick吧\n\nPaper:[Scaling Up Neural Architecture Search with Big Single-Stage Models](https://openreview.net/forum?id=HJe7unNFDH)  \nCodes:未开源\n\n### Once for All: Train One Network and Specialize it for Efficient Deployment \n和上一篇想法差不多，只是做的比较细，方法上看起来有点东西不是那么糙。\n\n![progressive shrinking](progressive_shrinking.png)\n训练的时候提出了一个progressive shrinking的方法，先训好最大的网络，然后一步一步从kernel，depth和width进行elastic训练，中间kernel使用了一个transformation matrix，width用了channel sortting.\n\n结果方面，最终效果很好就对了，finetune以后效果还能继续提高\n![results](ofa-results1.png)\n\nPaper:[Once for All: Train One Network and Specialize it for Efficient Deployment ](https://openreview.net/forum?id=HylxE1HKwS)  \nCodes:[github](https://github.com/mit-han-lab/once-for-all)  \n总的来看，其实也没有很创新的方法，只是看起来比上一篇细致一些然后实验上也充分，但实现上感觉还是很tricky不知道有多少水分。代码上感觉没有把完整过程开源出来，需要多机多卡的话复现也是个大麻烦，issue也不回，只能再观望一下看看怎么往detection走。\n\n","slug":"PaperReadingNotes2020-0223","published":1,"updated":"2020-02-24T06:51:35.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7bsdjsj0003csueaqsyrfl7","content":"<p>两篇论文的记录</p>\n<h3 id=\"scaling-up-neural-architecture-search-with-big-single-stage-models\"><a href=\"#Scaling-Up-Neural-Architecture-Search-with-Big-Single-Stage-Models\" class=\"headerlink\" title=\"Scaling Up Neural Architecture Search with Big Single-Stage Models\"></a>Scaling Up Neural Architecture Search with Big Single-Stage Models</h3><p>Universal slimmable network的kernel+depth+resolution扩展版，方法上没啥创新，所以被拒了<br>方法上就是Universal slimmable network那一套，然后加上了学习率和初始化的trick，之后要train这种包含多个子网络的网络可以借鉴一下里面的这些trick吧</p>\n<p>Paper:<a href=\"https://openreview.net/forum?id=HJe7unNFDH\" target=\"_blank\" rel=\"noopener\">Scaling Up Neural Architecture Search with Big Single-Stage Models</a><br>Codes:未开源</p>\n<h3 id=\"once-for-all-train-one-network-and-specialize-it-for-efficient-deployment\"><a href=\"#Once-for-All-Train-One-Network-and-Specialize-it-for-Efficient-Deployment\" class=\"headerlink\" title=\"Once for All: Train One Network and Specialize it for Efficient Deployment\"></a>Once for All: Train One Network and Specialize it for Efficient Deployment</h3><p>和上一篇想法差不多，只是做的比较细，方法上看起来有点东西不是那么糙。</p>\n<p><img src=\"progressive_shrinking.png\" alt=\"progressive shrinking\"><br>训练的时候提出了一个progressive shrinking的方法，先训好最大的网络，然后一步一步从kernel，depth和width进行elastic训练，中间kernel使用了一个transformation matrix，width用了channel sortting.</p>\n<p>结果方面，最终效果很好就对了，finetune以后效果还能继续提高<br><img src=\"ofa-results1.png\" alt=\"results\"></p>\n<p>Paper:<a href=\"https://openreview.net/forum?id=HylxE1HKwS\" target=\"_blank\" rel=\"noopener\">Once for All: Train One Network and Specialize it for Efficient Deployment </a><br>Codes:<a href=\"https://github.com/mit-han-lab/once-for-all\" target=\"_blank\" rel=\"noopener\">github</a><br>总的来看，其实也没有很创新的方法，只是看起来比上一篇细致一些然后实验上也充分，但实现上感觉还是很tricky不知道有多少水分。代码上感觉没有把完整过程开源出来，需要多机多卡的话复现也是个大麻烦，issue也不回，只能再观望一下看看怎么往detection走。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>两篇论文的记录</p>\n<h3 id=\"Scaling-Up-Neural-Architecture-Search-with-Big-Single-Stage-Models\"><a href=\"#Scaling-Up-Neural-Architecture-Search-with-Big-Single-Stage-Models\" class=\"headerlink\" title=\"Scaling Up Neural Architecture Search with Big Single-Stage Models\"></a>Scaling Up Neural Architecture Search with Big Single-Stage Models</h3><p>Universal slimmable network的kernel+depth+resolution扩展版，方法上没啥创新，所以被拒了<br>方法上就是Universal slimmable network那一套，然后加上了学习率和初始化的trick，之后要train这种包含多个子网络的网络可以借鉴一下里面的这些trick吧</p>\n<p>Paper:<a href=\"https://openreview.net/forum?id=HJe7unNFDH\" target=\"_blank\" rel=\"noopener\">Scaling Up Neural Architecture Search with Big Single-Stage Models</a><br>Codes:未开源</p>\n<h3 id=\"Once-for-All-Train-One-Network-and-Specialize-it-for-Efficient-Deployment\"><a href=\"#Once-for-All-Train-One-Network-and-Specialize-it-for-Efficient-Deployment\" class=\"headerlink\" title=\"Once for All: Train One Network and Specialize it for Efficient Deployment\"></a>Once for All: Train One Network and Specialize it for Efficient Deployment</h3><p>和上一篇想法差不多，只是做的比较细，方法上看起来有点东西不是那么糙。</p>\n<p><img src=\"progressive_shrinking.png\" alt=\"progressive shrinking\"><br>训练的时候提出了一个progressive shrinking的方法，先训好最大的网络，然后一步一步从kernel，depth和width进行elastic训练，中间kernel使用了一个transformation matrix，width用了channel sortting.</p>\n<p>结果方面，最终效果很好就对了，finetune以后效果还能继续提高<br><img src=\"ofa-results1.png\" alt=\"results\"></p>\n<p>Paper:<a href=\"https://openreview.net/forum?id=HylxE1HKwS\" target=\"_blank\" rel=\"noopener\">Once for All: Train One Network and Specialize it for Efficient Deployment </a><br>Codes:<a href=\"https://github.com/mit-han-lab/once-for-all\" target=\"_blank\" rel=\"noopener\">github</a><br>总的来看，其实也没有很创新的方法，只是看起来比上一篇细致一些然后实验上也充分，但实现上感觉还是很tricky不知道有多少水分。代码上感觉没有把完整过程开源出来，需要多机多卡的话复现也是个大麻烦，issue也不回，只能再观望一下看看怎么往detection走。</p>\n"},{"title":"FE Resources Collection","catalog":true,"date":"2020-01-02T02:23:08.000Z","subtitle":null,"header-img":null,"_content":"👷🚧 前端学习资源整合，持续更新中。\n\n### 博客/社区/论坛\n- [Dev Community](https://dev.to/)\n- [Github](https://github.com/)\n- [Medium](https://medium.com/)\n- [Reddit](https://www.reddit.com/)\n- [腾讯 IMWeb 团队前端社区](https://imweb.io/topic/tab/all)\n- [腾讯 AlloyTeam 全端博客](http://www.alloyteam.com/page/0/)\n- [React 团队成员 Dan Abramov 个人博客](https://overreacted.io/)\n- [淘宝前端团队冴羽个人博客](https://github.com/mqyqingfeng/Blog)：包含JavaScript深入系列、JavaScript专题系列、ES6系列、React系列\n\n### 资讯类\n- [每日时报](https://github.com/wubaiqing/zaobao)\n- [前端面试每日三问](https://github.com/haizlin/fe-interview)\n- [Github Daily](https://github.com/GitHubDaily/GitHubDaily)\n\n### 技能图谱/技术清单\n- [Frontend Developer](https://roadmap.sh/frontend)\n- [React Developer Roadmap](https://github.com/adam-golab/react-developer-roadmap)\n- [前端技术清单](https://alienzhou.github.io/frontend-tech-list/)\n\n### 面试宝典\n- [大前端面试宝典 - 图解前端](https://lucifer.ren/fe-interview/#/)\n- [技术面试基础知识](https://cyc2018.github.io/CS-Notes/#/README)\n\n### 其他\n- [Learn X in Y minutes](https://learnxinyminutes.com/)\n\n","source":"_posts/FE-Resources-Collection.md","raw":"---\ntitle: FE Resources Collection\ncatalog: true\ndate: 2020-01-02 10:23:08\nsubtitle:\nheader-img:\ntags: FE \n---\n👷🚧 前端学习资源整合，持续更新中。\n\n### 博客/社区/论坛\n- [Dev Community](https://dev.to/)\n- [Github](https://github.com/)\n- [Medium](https://medium.com/)\n- [Reddit](https://www.reddit.com/)\n- [腾讯 IMWeb 团队前端社区](https://imweb.io/topic/tab/all)\n- [腾讯 AlloyTeam 全端博客](http://www.alloyteam.com/page/0/)\n- [React 团队成员 Dan Abramov 个人博客](https://overreacted.io/)\n- [淘宝前端团队冴羽个人博客](https://github.com/mqyqingfeng/Blog)：包含JavaScript深入系列、JavaScript专题系列、ES6系列、React系列\n\n### 资讯类\n- [每日时报](https://github.com/wubaiqing/zaobao)\n- [前端面试每日三问](https://github.com/haizlin/fe-interview)\n- [Github Daily](https://github.com/GitHubDaily/GitHubDaily)\n\n### 技能图谱/技术清单\n- [Frontend Developer](https://roadmap.sh/frontend)\n- [React Developer Roadmap](https://github.com/adam-golab/react-developer-roadmap)\n- [前端技术清单](https://alienzhou.github.io/frontend-tech-list/)\n\n### 面试宝典\n- [大前端面试宝典 - 图解前端](https://lucifer.ren/fe-interview/#/)\n- [技术面试基础知识](https://cyc2018.github.io/CS-Notes/#/README)\n\n### 其他\n- [Learn X in Y minutes](https://learnxinyminutes.com/)\n\n","slug":"FE-Resources-Collection","published":1,"updated":"2020-03-04T02:48:08.614Z","_id":"ck7bsdjsn0005csue4cevoipf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>👷🚧 前端学习资源整合，持续更新中。</p>\n<h3 id=\"博客社区论坛\">博客/社区/论坛</h3>\n<ul>\n<li><a href=\"https://dev.to/\" target=\"_blank\" rel=\"noopener\">Dev Community</a></li>\n<li><a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n<li><a href=\"https://medium.com/\" target=\"_blank\" rel=\"noopener\">Medium</a></li>\n<li><a href=\"https://www.reddit.com/\" target=\"_blank\" rel=\"noopener\">Reddit</a></li>\n<li><a href=\"https://imweb.io/topic/tab/all\" target=\"_blank\" rel=\"noopener\">腾讯 IMWeb 团队前端社区</a></li>\n<li><a href=\"http://www.alloyteam.com/page/0/\" target=\"_blank\" rel=\"noopener\">腾讯 AlloyTeam 全端博客</a></li>\n<li><a href=\"https://overreacted.io/\" target=\"_blank\" rel=\"noopener\">React 团队成员 Dan Abramov 个人博客</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog\" target=\"_blank\" rel=\"noopener\">淘宝前端团队冴羽个人博客</a>：包含JavaScript深入系列、JavaScript专题系列、ES6系列、React系列</li>\n</ul>\n<h3 id=\"资讯类\">资讯类</h3>\n<ul>\n<li><a href=\"https://github.com/wubaiqing/zaobao\" target=\"_blank\" rel=\"noopener\">每日时报</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\" target=\"_blank\" rel=\"noopener\">前端面试每日三问</a></li>\n<li><a href=\"https://github.com/GitHubDaily/GitHubDaily\" target=\"_blank\" rel=\"noopener\">Github Daily</a></li>\n</ul>\n<h3 id=\"技能图谱技术清单\">技能图谱/技术清单</h3>\n<ul>\n<li><a href=\"https://roadmap.sh/frontend\" target=\"_blank\" rel=\"noopener\">Frontend Developer</a></li>\n<li><a href=\"https://github.com/adam-golab/react-developer-roadmap\" target=\"_blank\" rel=\"noopener\">React Developer Roadmap</a></li>\n<li><a href=\"https://alienzhou.github.io/frontend-tech-list/\" target=\"_blank\" rel=\"noopener\">前端技术清单</a></li>\n</ul>\n<h3 id=\"面试宝典\">面试宝典</h3>\n<ul>\n<li><a href=\"https://lucifer.ren/fe-interview/#/\" target=\"_blank\" rel=\"noopener\">大前端面试宝典 - 图解前端</a></li>\n<li><a href=\"https://cyc2018.github.io/CS-Notes/#/README\" target=\"_blank\" rel=\"noopener\">技术面试基础知识</a></li>\n</ul>\n<h3 id=\"其他\">其他</h3>\n<ul>\n<li><a href=\"https://learnxinyminutes.com/\" target=\"_blank\" rel=\"noopener\">Learn X in Y minutes</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>👷🚧 前端学习资源整合，持续更新中。</p>\n<h3>博客/社区/论坛</h3>\n<ul>\n<li><a href=\"https://dev.to/\" target=\"_blank\" rel=\"noopener\">Dev Community</a></li>\n<li><a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n<li><a href=\"https://medium.com/\" target=\"_blank\" rel=\"noopener\">Medium</a></li>\n<li><a href=\"https://www.reddit.com/\" target=\"_blank\" rel=\"noopener\">Reddit</a></li>\n<li><a href=\"https://imweb.io/topic/tab/all\" target=\"_blank\" rel=\"noopener\">腾讯 IMWeb 团队前端社区</a></li>\n<li><a href=\"http://www.alloyteam.com/page/0/\" target=\"_blank\" rel=\"noopener\">腾讯 AlloyTeam 全端博客</a></li>\n<li><a href=\"https://overreacted.io/\" target=\"_blank\" rel=\"noopener\">React 团队成员 Dan Abramov 个人博客</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog\" target=\"_blank\" rel=\"noopener\">淘宝前端团队冴羽个人博客</a>：包含JavaScript深入系列、JavaScript专题系列、ES6系列、React系列</li>\n</ul>\n<h3>资讯类</h3>\n<ul>\n<li><a href=\"https://github.com/wubaiqing/zaobao\" target=\"_blank\" rel=\"noopener\">每日时报</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\" target=\"_blank\" rel=\"noopener\">前端面试每日三问</a></li>\n<li><a href=\"https://github.com/GitHubDaily/GitHubDaily\" target=\"_blank\" rel=\"noopener\">Github Daily</a></li>\n</ul>\n<h3>技能图谱/技术清单</h3>\n<ul>\n<li><a href=\"https://roadmap.sh/frontend\" target=\"_blank\" rel=\"noopener\">Frontend Developer</a></li>\n<li><a href=\"https://github.com/adam-golab/react-developer-roadmap\" target=\"_blank\" rel=\"noopener\">React Developer Roadmap</a></li>\n<li><a href=\"https://alienzhou.github.io/frontend-tech-list/\" target=\"_blank\" rel=\"noopener\">前端技术清单</a></li>\n</ul>\n<h3>面试宝典</h3>\n<ul>\n<li><a href=\"https://lucifer.ren/fe-interview/#/\" target=\"_blank\" rel=\"noopener\">大前端面试宝典 - 图解前端</a></li>\n<li><a href=\"https://cyc2018.github.io/CS-Notes/#/README\" target=\"_blank\" rel=\"noopener\">技术面试基础知识</a></li>\n</ul>\n<h3>其他</h3>\n<ul>\n<li><a href=\"https://learnxinyminutes.com/\" target=\"_blank\" rel=\"noopener\">Learn X in Y minutes</a></li>\n</ul>\n"},{"title":"We Are Graduated!","catalog":true,"date":"2019-06-13T09:53:24.000Z","subtitle":null,"header-img":null,"_content":"\nWe Are Graduated ! 🎓\n\nReady to move on ! 💪","source":"_posts/We Are Graduated!.md","raw":"---\ntitle: We Are Graduated!\ncatalog: true\ndate: 2019-06-13 17:53:24\nsubtitle:\nheader-img:\ntags: Daily\n---\n\nWe Are Graduated ! 🎓\n\nReady to move on ! 💪","slug":"We Are Graduated!","published":1,"updated":"2019-12-08T06:55:16.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7bsdjsv000acsue3tru7iq8","content":"<p>We Are Graduated ! 🎓</p>\n<p>Ready to move on ! 💪</p>\n","site":{"data":{}},"excerpt":"","more":"<p>We Are Graduated ! 🎓</p>\n<p>Ready to move on ! 💪</p>\n"},{"title":"Technical Docs Collection involved in FE work","catalog":true,"date":"2020-01-07T02:24:22.000Z","subtitle":null,"header-img":null,"_content":"👷🚧 工作中用到的一些技术文档集合，持续更新中。\n\n#### typescript\n- [docs and handbook](https://www.typescriptlang.org/docs/home.html)\n\n#### git\n- [Oh Shit, Git!?!](http://ohshitgit.com/)\n\n#### docker\n- [官方文档](https://docs.docker.com/)\n\n#### sentry\n- [官方文档](https://docs.sentry.io/)\n\n#### JWT\n- [Introduction to JSON Web Tokens](https://jwt.io/introduction/)\n- [阮一峰 JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)，比较通俗易懂\n\n#### jest\n- [官方文档](https://jestjs.io/docs/en/getting-started)\n\n#### enzyme\n- [API introduction](https://airbnb.io/enzyme/)\n\n#### rxjs\n- [官方文档](https://rxjs-dev.firebaseapp.com/guide/overview)\n- [Learn RxJS](https://www.learnrxjs.io/)\n- [RxJS Marbles: Interactive diagrams of Rx Observables](https://rxmarbles.com/)\n\n#### Protocol Buffers\n- [google docs](https://developers.google.com/protocol-buffers)\n\n#### immer\n- [官方文档](https://immerjs.github.io/immer/docs/introduction)\n- [Introducing Immer: Immutability the easy way](https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3) （注意里面提到的 `structural sharing`）\n\n#### react-beautiful-dnd\n- [官方文档](https://github.com/atlassian/react-beautiful-dnd)\n\n### Json Patch\n- [Introduction](http://jsonpatch.com/)","source":"_posts/FE-Technical-Docs-Collection.md","raw":"---\ntitle: Technical Docs Collection involved in FE work\ncatalog: true\ndate: 2020-01-07 10:24:22\nsubtitle:\nheader-img:\ntags: FE\n---\n👷🚧 工作中用到的一些技术文档集合，持续更新中。\n\n#### typescript\n- [docs and handbook](https://www.typescriptlang.org/docs/home.html)\n\n#### git\n- [Oh Shit, Git!?!](http://ohshitgit.com/)\n\n#### docker\n- [官方文档](https://docs.docker.com/)\n\n#### sentry\n- [官方文档](https://docs.sentry.io/)\n\n#### JWT\n- [Introduction to JSON Web Tokens](https://jwt.io/introduction/)\n- [阮一峰 JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)，比较通俗易懂\n\n#### jest\n- [官方文档](https://jestjs.io/docs/en/getting-started)\n\n#### enzyme\n- [API introduction](https://airbnb.io/enzyme/)\n\n#### rxjs\n- [官方文档](https://rxjs-dev.firebaseapp.com/guide/overview)\n- [Learn RxJS](https://www.learnrxjs.io/)\n- [RxJS Marbles: Interactive diagrams of Rx Observables](https://rxmarbles.com/)\n\n#### Protocol Buffers\n- [google docs](https://developers.google.com/protocol-buffers)\n\n#### immer\n- [官方文档](https://immerjs.github.io/immer/docs/introduction)\n- [Introducing Immer: Immutability the easy way](https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3) （注意里面提到的 `structural sharing`）\n\n#### react-beautiful-dnd\n- [官方文档](https://github.com/atlassian/react-beautiful-dnd)\n\n### Json Patch\n- [Introduction](http://jsonpatch.com/)","slug":"FE-Technical-Docs-Collection","published":1,"updated":"2020-02-05T07:09:07.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7bsdjsy000dcsuenbqvrjub","content":"<p>👷🚧 工作中用到的一些技术文档集合，持续更新中。</p>\n<h4 id=\"typescript\"><a href=\"#typescript\" class=\"headerlink\" title=\"typescript\"></a>typescript</h4><ul>\n<li><a href=\"https://www.typescriptlang.org/docs/home.html\" target=\"_blank\" rel=\"noopener\">docs and handbook</a></li>\n</ul>\n<h4 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h4><ul>\n<li><a href=\"http://ohshitgit.com/\" target=\"_blank\" rel=\"noopener\">Oh Shit, Git!?!</a></li>\n</ul>\n<h4 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h4><ul>\n<li><a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"sentry\"><a href=\"#sentry\" class=\"headerlink\" title=\"sentry\"></a>sentry</h4><ul>\n<li><a href=\"https://docs.sentry.io/\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"jwt\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h4><ul>\n<li><a href=\"https://jwt.io/introduction/\" target=\"_blank\" rel=\"noopener\">Introduction to JSON Web Tokens</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\" target=\"_blank\" rel=\"noopener\">阮一峰 JSON Web Token 入门教程</a>，比较通俗易懂</li>\n</ul>\n<h4 id=\"jest\"><a href=\"#jest\" class=\"headerlink\" title=\"jest\"></a>jest</h4><ul>\n<li><a href=\"https://jestjs.io/docs/en/getting-started\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"enzyme\"><a href=\"#enzyme\" class=\"headerlink\" title=\"enzyme\"></a>enzyme</h4><ul>\n<li><a href=\"https://airbnb.io/enzyme/\" target=\"_blank\" rel=\"noopener\">API introduction</a></li>\n</ul>\n<h4 id=\"rxjs\"><a href=\"#rxjs\" class=\"headerlink\" title=\"rxjs\"></a>rxjs</h4><ul>\n<li><a href=\"https://rxjs-dev.firebaseapp.com/guide/overview\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li><a href=\"https://www.learnrxjs.io/\" target=\"_blank\" rel=\"noopener\">Learn RxJS</a></li>\n<li><a href=\"https://rxmarbles.com/\" target=\"_blank\" rel=\"noopener\">RxJS Marbles: Interactive diagrams of Rx Observables</a></li>\n</ul>\n<h4 id=\"protocol-buffers\"><a href=\"#Protocol-Buffers\" class=\"headerlink\" title=\"Protocol Buffers\"></a>Protocol Buffers</h4><ul>\n<li><a href=\"https://developers.google.com/protocol-buffers\" target=\"_blank\" rel=\"noopener\">google docs</a></li>\n</ul>\n<h4 id=\"immer\"><a href=\"#immer\" class=\"headerlink\" title=\"immer\"></a>immer</h4><ul>\n<li><a href=\"https://immerjs.github.io/immer/docs/introduction\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li><a href=\"https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3\" target=\"_blank\" rel=\"noopener\">Introducing Immer: Immutability the easy way</a> （注意里面提到的 <code>structural sharing</code>）</li>\n</ul>\n<h4 id=\"react-beautiful-dnd\"><a href=\"#react-beautiful-dnd\" class=\"headerlink\" title=\"react-beautiful-dnd\"></a>react-beautiful-dnd</h4><ul>\n<li><a href=\"https://github.com/atlassian/react-beautiful-dnd\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h3 id=\"json-patch\"><a href=\"#Json-Patch\" class=\"headerlink\" title=\"Json Patch\"></a>Json Patch</h3><ul>\n<li><a href=\"http://jsonpatch.com/\" target=\"_blank\" rel=\"noopener\">Introduction</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>👷🚧 工作中用到的一些技术文档集合，持续更新中。</p>\n<h4 id=\"typescript\"><a href=\"#typescript\" class=\"headerlink\" title=\"typescript\"></a>typescript</h4><ul>\n<li><a href=\"https://www.typescriptlang.org/docs/home.html\" target=\"_blank\" rel=\"noopener\">docs and handbook</a></li>\n</ul>\n<h4 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h4><ul>\n<li><a href=\"http://ohshitgit.com/\" target=\"_blank\" rel=\"noopener\">Oh Shit, Git!?!</a></li>\n</ul>\n<h4 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h4><ul>\n<li><a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"sentry\"><a href=\"#sentry\" class=\"headerlink\" title=\"sentry\"></a>sentry</h4><ul>\n<li><a href=\"https://docs.sentry.io/\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h4><ul>\n<li><a href=\"https://jwt.io/introduction/\" target=\"_blank\" rel=\"noopener\">Introduction to JSON Web Tokens</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\" target=\"_blank\" rel=\"noopener\">阮一峰 JSON Web Token 入门教程</a>，比较通俗易懂</li>\n</ul>\n<h4 id=\"jest\"><a href=\"#jest\" class=\"headerlink\" title=\"jest\"></a>jest</h4><ul>\n<li><a href=\"https://jestjs.io/docs/en/getting-started\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"enzyme\"><a href=\"#enzyme\" class=\"headerlink\" title=\"enzyme\"></a>enzyme</h4><ul>\n<li><a href=\"https://airbnb.io/enzyme/\" target=\"_blank\" rel=\"noopener\">API introduction</a></li>\n</ul>\n<h4 id=\"rxjs\"><a href=\"#rxjs\" class=\"headerlink\" title=\"rxjs\"></a>rxjs</h4><ul>\n<li><a href=\"https://rxjs-dev.firebaseapp.com/guide/overview\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li><a href=\"https://www.learnrxjs.io/\" target=\"_blank\" rel=\"noopener\">Learn RxJS</a></li>\n<li><a href=\"https://rxmarbles.com/\" target=\"_blank\" rel=\"noopener\">RxJS Marbles: Interactive diagrams of Rx Observables</a></li>\n</ul>\n<h4 id=\"Protocol-Buffers\"><a href=\"#Protocol-Buffers\" class=\"headerlink\" title=\"Protocol Buffers\"></a>Protocol Buffers</h4><ul>\n<li><a href=\"https://developers.google.com/protocol-buffers\" target=\"_blank\" rel=\"noopener\">google docs</a></li>\n</ul>\n<h4 id=\"immer\"><a href=\"#immer\" class=\"headerlink\" title=\"immer\"></a>immer</h4><ul>\n<li><a href=\"https://immerjs.github.io/immer/docs/introduction\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li><a href=\"https://medium.com/hackernoon/introducing-immer-immutability-the-easy-way-9d73d8f71cb3\" target=\"_blank\" rel=\"noopener\">Introducing Immer: Immutability the easy way</a> （注意里面提到的 <code>structural sharing</code>）</li>\n</ul>\n<h4 id=\"react-beautiful-dnd\"><a href=\"#react-beautiful-dnd\" class=\"headerlink\" title=\"react-beautiful-dnd\"></a>react-beautiful-dnd</h4><ul>\n<li><a href=\"https://github.com/atlassian/react-beautiful-dnd\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h3 id=\"Json-Patch\"><a href=\"#Json-Patch\" class=\"headerlink\" title=\"Json Patch\"></a>Json Patch</h3><ul>\n<li><a href=\"http://jsonpatch.com/\" target=\"_blank\" rel=\"noopener\">Introduction</a></li>\n</ul>\n"},{"title":"What is Gumbel-Softmax Trick？","catalog":true,"date":"2019-07-16T12:02:54.000Z","subtitle":null,"header-img":null,"mathjax":true,"_content":"\nGumbel-Softmax trick 在VAE、GAN、NAS等深度学习领域经常出现，那它到底是啥，有什么用呢？  \n\n### 背景问题\n首先简要介绍一下问题的背景。假设我们在网络中有一个有 \\\\(n\\\\) 个取值的离散分布\\\\(P(x)\\\\)，也就是一个\\\\(n\\\\)维的向量，每一个元素就是一个概率值。如果我们只是要对其进行采样或者得到最终概率最大的一个取值，我们很容易就可以直接采样或取\\\\(arg \\max\\\\)得到结果。但是，如果我们希望这个过程是可导的，该怎么办呢？\n\n### Re-Parameterization Trick\n首先介绍一个叫重参数化(Re-Parameterization)的东西，Re-Parameterization解决了上面提到的采样不可导的问题。这里用油管上一个[变分自动编码器教程](https://www.youtube.com/watch?v=9zKuYvjFFS8)中的图片来解释。\n![re-paramerise](re-paramerise.png)\n首先左边是重参数化之前的形式，我们希望通过学习到了标准差\\\\(\\phi\\\\)和均值\\\\(x\\\\)，通过对分布\\\\(q\\\\)进行采样得到\\\\(z\\\\)，然后传入下一层网络。然而这就有个问题，采样过程是没法反传的，这样加载网络中就没法学习了，因此就有了右边的形式。  \n\n在这里呢，其实就是在网络中只保留可以求导的部分，把不可导的采样部分放到网络外用一个新的输入节点\\\\(\\epsilon\\\\)表示。\\\\(\\epsilon\\\\)采样的过程和网络学习是分离的，因此不影响网络反传。  \n\n具体而言，假设我们需要根据均值和方差从正太分布\\\\(N(x,\\phi^2)\\\\)采样，我们可以转化为先从\\\\(\\epsilon=N(0,1)\\\\)采样，然后计算\\\\(z=x+\\epsilon\\cdot \\phi\\\\)来得到我们需要的\\\\(z\\\\)。\n\n### Gumbel-Softmax Trick\n通过Re-Parameterization Trick我们可以一定条件下解决采样不可导的问题。但回到我们最初的问题，我们并不是在连续的高斯分布上采样，而是在一个离散分布\\\\(P(x)\\\\)上采样。上面的重参数后是可导的，而换成离散分布以后，就无法满足了。所以，对于离散分布要怎么处理呢？\n类似与前面的重参数技巧，我们对于离散变量有Gumbel-Max trick的采样方法：\n![gumbel-max](gumbel1.png)\n从上图中可以看出，我们将离散变量\\\\(\\log{\\alpha_1}, \\log{\\alpha_2}, \\log{\\alpha_3}\\\\)加上Gumbel噪声，然后对相加后的随机变量取\\\\(\\arg \\max\\\\)后得到一个onehot向量，就是我们的采样结果，可以表示为：\n$$x_{\\alpha}=\\arg\\max(\\log(\\alpha_i)+G_i)$$\n但\\\\(\\arg \\max\\\\)这个操作是没法求导的，那么我们就用softmax来对\\\\(\\arg \\max\\\\)进行松弛，这就得到了我们的Gumbel-Softmax Trick:\n![gumbel-back](gumbel2.png)\n其中，\\\\(\\lambda\\\\)是softmax函数的temperature参数，用于控制采样 当\\\\(\\lambda \\to \\infty\\\\)时，所有的激活值对应的激活概率趋近于相同（激活概率差异性较小）；而当\\\\(\\lambda \\to 0\\\\)，不同的激活值对应的激活概率差异也就越大，也就越趋向于onehot向量。（温度这个词主要来自于物理学中的温度，当温度高的时候，分子的运动就越剧烈，随机性就越大，反之则越稳定，随机性越小）  \n到这里，我们既可以对分布进行采样，又能够满足在网络中可以反向传播学习。  \n但我们可能还会有这样的问题：为什么不直接就用softmax函数呢，这样不是也能在网络中学习么？我们再回顾下我们的问题就能发现，我们需要采样+能反传，softmax满足能反传但是它不能达到我们根据概率分布采样的目的，而Gumbel-Max Trick就是用来近似分布然后采样的。  \n另外，我们在此用到了Gumbel Distribution--\\\\(G\\\\)，是一个极值分布，通俗来讲就是分布的极值的分布，具体可参考：\n[Gumbel distribution](https://en.wikipedia.org/wiki/Gumbel_distribution)\n\n### 参考\n[Gumbel-Softmax Trick和Gumbel分布](https://www.cnblogs.com/initial-h/p/9468974.html)\n[The Gumbel-Softmax Trick for Inference of Discrete Variables](https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html)\n[Variational Autoencoders](https://www.youtube.com/watch?v=9zKuYvjFFS8)\n[带你认识神奇的Gumbel trick](https://blog.csdn.net/a358463121/article/details/80820878)\n[Talk: Categorical Reparameterization with Gumbel-Softmax & The Concrete Distribution](https://www.youtube.com/watch?v=wVkLM2KKHp8)","source":"_posts/What-is-Gumbel-Softmax-Trick.md","raw":"---\ntitle: What is Gumbel-Softmax Trick？\ncatalog: true\ndate: 2019-07-16 20:02:54\nsubtitle:\nheader-img:\nmathjax: true\ntags: ML\n---\n\nGumbel-Softmax trick 在VAE、GAN、NAS等深度学习领域经常出现，那它到底是啥，有什么用呢？  \n\n### 背景问题\n首先简要介绍一下问题的背景。假设我们在网络中有一个有 \\\\(n\\\\) 个取值的离散分布\\\\(P(x)\\\\)，也就是一个\\\\(n\\\\)维的向量，每一个元素就是一个概率值。如果我们只是要对其进行采样或者得到最终概率最大的一个取值，我们很容易就可以直接采样或取\\\\(arg \\max\\\\)得到结果。但是，如果我们希望这个过程是可导的，该怎么办呢？\n\n### Re-Parameterization Trick\n首先介绍一个叫重参数化(Re-Parameterization)的东西，Re-Parameterization解决了上面提到的采样不可导的问题。这里用油管上一个[变分自动编码器教程](https://www.youtube.com/watch?v=9zKuYvjFFS8)中的图片来解释。\n![re-paramerise](re-paramerise.png)\n首先左边是重参数化之前的形式，我们希望通过学习到了标准差\\\\(\\phi\\\\)和均值\\\\(x\\\\)，通过对分布\\\\(q\\\\)进行采样得到\\\\(z\\\\)，然后传入下一层网络。然而这就有个问题，采样过程是没法反传的，这样加载网络中就没法学习了，因此就有了右边的形式。  \n\n在这里呢，其实就是在网络中只保留可以求导的部分，把不可导的采样部分放到网络外用一个新的输入节点\\\\(\\epsilon\\\\)表示。\\\\(\\epsilon\\\\)采样的过程和网络学习是分离的，因此不影响网络反传。  \n\n具体而言，假设我们需要根据均值和方差从正太分布\\\\(N(x,\\phi^2)\\\\)采样，我们可以转化为先从\\\\(\\epsilon=N(0,1)\\\\)采样，然后计算\\\\(z=x+\\epsilon\\cdot \\phi\\\\)来得到我们需要的\\\\(z\\\\)。\n\n### Gumbel-Softmax Trick\n通过Re-Parameterization Trick我们可以一定条件下解决采样不可导的问题。但回到我们最初的问题，我们并不是在连续的高斯分布上采样，而是在一个离散分布\\\\(P(x)\\\\)上采样。上面的重参数后是可导的，而换成离散分布以后，就无法满足了。所以，对于离散分布要怎么处理呢？\n类似与前面的重参数技巧，我们对于离散变量有Gumbel-Max trick的采样方法：\n![gumbel-max](gumbel1.png)\n从上图中可以看出，我们将离散变量\\\\(\\log{\\alpha_1}, \\log{\\alpha_2}, \\log{\\alpha_3}\\\\)加上Gumbel噪声，然后对相加后的随机变量取\\\\(\\arg \\max\\\\)后得到一个onehot向量，就是我们的采样结果，可以表示为：\n$$x_{\\alpha}=\\arg\\max(\\log(\\alpha_i)+G_i)$$\n但\\\\(\\arg \\max\\\\)这个操作是没法求导的，那么我们就用softmax来对\\\\(\\arg \\max\\\\)进行松弛，这就得到了我们的Gumbel-Softmax Trick:\n![gumbel-back](gumbel2.png)\n其中，\\\\(\\lambda\\\\)是softmax函数的temperature参数，用于控制采样 当\\\\(\\lambda \\to \\infty\\\\)时，所有的激活值对应的激活概率趋近于相同（激活概率差异性较小）；而当\\\\(\\lambda \\to 0\\\\)，不同的激活值对应的激活概率差异也就越大，也就越趋向于onehot向量。（温度这个词主要来自于物理学中的温度，当温度高的时候，分子的运动就越剧烈，随机性就越大，反之则越稳定，随机性越小）  \n到这里，我们既可以对分布进行采样，又能够满足在网络中可以反向传播学习。  \n但我们可能还会有这样的问题：为什么不直接就用softmax函数呢，这样不是也能在网络中学习么？我们再回顾下我们的问题就能发现，我们需要采样+能反传，softmax满足能反传但是它不能达到我们根据概率分布采样的目的，而Gumbel-Max Trick就是用来近似分布然后采样的。  \n另外，我们在此用到了Gumbel Distribution--\\\\(G\\\\)，是一个极值分布，通俗来讲就是分布的极值的分布，具体可参考：\n[Gumbel distribution](https://en.wikipedia.org/wiki/Gumbel_distribution)\n\n### 参考\n[Gumbel-Softmax Trick和Gumbel分布](https://www.cnblogs.com/initial-h/p/9468974.html)\n[The Gumbel-Softmax Trick for Inference of Discrete Variables](https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html)\n[Variational Autoencoders](https://www.youtube.com/watch?v=9zKuYvjFFS8)\n[带你认识神奇的Gumbel trick](https://blog.csdn.net/a358463121/article/details/80820878)\n[Talk: Categorical Reparameterization with Gumbel-Softmax & The Concrete Distribution](https://www.youtube.com/watch?v=wVkLM2KKHp8)","slug":"What-is-Gumbel-Softmax-Trick","published":1,"updated":"2019-12-09T16:09:11.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7bsdjt3000jcsueyf07r7qy","content":"<p>Gumbel-Softmax trick 在VAE、GAN、NAS等深度学习领域经常出现，那它到底是啥，有什么用呢？  </p>\n<h3 id=\"背景问题\"><a href=\"#背景问题\" class=\"headerlink\" title=\"背景问题\"></a>背景问题</h3><p>首先简要介绍一下问题的背景。假设我们在网络中有一个有 \\(n\\) 个取值的离散分布\\(P(x)\\)，也就是一个\\(n\\)维的向量，每一个元素就是一个概率值。如果我们只是要对其进行采样或者得到最终概率最大的一个取值，我们很容易就可以直接采样或取\\(arg \\max\\)得到结果。但是，如果我们希望这个过程是可导的，该怎么办呢？</p>\n<h3 id=\"re-parameterization-trick\"><a href=\"#Re-Parameterization-Trick\" class=\"headerlink\" title=\"Re-Parameterization Trick\"></a>Re-Parameterization Trick</h3><p>首先介绍一个叫重参数化(Re-Parameterization)的东西，Re-Parameterization解决了上面提到的采样不可导的问题。这里用油管上一个<a href=\"https://www.youtube.com/watch?v=9zKuYvjFFS8\" target=\"_blank\" rel=\"noopener\">变分自动编码器教程</a>中的图片来解释。<br><img src=\"re-paramerise.png\" alt=\"re-paramerise\"><br>首先左边是重参数化之前的形式，我们希望通过学习到了标准差\\(\\phi\\)和均值\\(x\\)，通过对分布\\(q\\)进行采样得到\\(z\\)，然后传入下一层网络。然而这就有个问题，采样过程是没法反传的，这样加载网络中就没法学习了，因此就有了右边的形式。  </p>\n<p>在这里呢，其实就是在网络中只保留可以求导的部分，把不可导的采样部分放到网络外用一个新的输入节点\\(\\epsilon\\)表示。\\(\\epsilon\\)采样的过程和网络学习是分离的，因此不影响网络反传。  </p>\n<p>具体而言，假设我们需要根据均值和方差从正太分布\\(N(x,\\phi^2)\\)采样，我们可以转化为先从\\(\\epsilon=N(0,1)\\)采样，然后计算\\(z=x+\\epsilon\\cdot \\phi\\)来得到我们需要的\\(z\\)。</p>\n<h3 id=\"gumbel-softmax-trick\"><a href=\"#Gumbel-Softmax-Trick\" class=\"headerlink\" title=\"Gumbel-Softmax Trick\"></a>Gumbel-Softmax Trick</h3><p>通过Re-Parameterization Trick我们可以一定条件下解决采样不可导的问题。但回到我们最初的问题，我们并不是在连续的高斯分布上采样，而是在一个离散分布\\(P(x)\\)上采样。上面的重参数后是可导的，而换成离散分布以后，就无法满足了。所以，对于离散分布要怎么处理呢？<br>类似与前面的重参数技巧，我们对于离散变量有Gumbel-Max trick的采样方法：<br><img src=\"gumbel1.png\" alt=\"gumbel-max\"><br>从上图中可以看出，我们将离散变量\\(\\log{\\alpha_1}, \\log{\\alpha_2}, \\log{\\alpha_3}\\)加上Gumbel噪声，然后对相加后的随机变量取\\(\\arg \\max\\)后得到一个onehot向量，就是我们的采样结果，可以表示为：</p>\n<script type=\"math/tex; mode=display\">x_{\\alpha}=\\arg\\max(\\log(\\alpha_i)+G_i)</script><p>但\\(\\arg \\max\\)这个操作是没法求导的，那么我们就用softmax来对\\(\\arg \\max\\)进行松弛，这就得到了我们的Gumbel-Softmax Trick:<br><img src=\"gumbel2.png\" alt=\"gumbel-back\"><br>其中，\\(\\lambda\\)是softmax函数的temperature参数，用于控制采样 当\\(\\lambda \\to \\infty\\)时，所有的激活值对应的激活概率趋近于相同（激活概率差异性较小）；而当\\(\\lambda \\to 0\\)，不同的激活值对应的激活概率差异也就越大，也就越趋向于onehot向量。（温度这个词主要来自于物理学中的温度，当温度高的时候，分子的运动就越剧烈，随机性就越大，反之则越稳定，随机性越小）<br>到这里，我们既可以对分布进行采样，又能够满足在网络中可以反向传播学习。<br>但我们可能还会有这样的问题：为什么不直接就用softmax函数呢，这样不是也能在网络中学习么？我们再回顾下我们的问题就能发现，我们需要采样+能反传，softmax满足能反传但是它不能达到我们根据概率分布采样的目的，而Gumbel-Max Trick就是用来近似分布然后采样的。<br>另外，我们在此用到了Gumbel Distribution—\\(G\\)，是一个极值分布，通俗来讲就是分布的极值的分布，具体可参考：<br><a href=\"https://en.wikipedia.org/wiki/Gumbel_distribution\" target=\"_blank\" rel=\"noopener\">Gumbel distribution</a></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.cnblogs.com/initial-h/p/9468974.html\" target=\"_blank\" rel=\"noopener\">Gumbel-Softmax Trick和Gumbel分布</a><br><a href=\"https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html\" target=\"_blank\" rel=\"noopener\">The Gumbel-Softmax Trick for Inference of Discrete Variables</a><br><a href=\"https://www.youtube.com/watch?v=9zKuYvjFFS8\" target=\"_blank\" rel=\"noopener\">Variational Autoencoders</a><br><a href=\"https://blog.csdn.net/a358463121/article/details/80820878\" target=\"_blank\" rel=\"noopener\">带你认识神奇的Gumbel trick</a><br><a href=\"https://www.youtube.com/watch?v=wVkLM2KKHp8\" target=\"_blank\" rel=\"noopener\">Talk: Categorical Reparameterization with Gumbel-Softmax &amp; The Concrete Distribution</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Gumbel-Softmax trick 在VAE、GAN、NAS等深度学习领域经常出现，那它到底是啥，有什么用呢？  </p>\n<h3 id=\"背景问题\"><a href=\"#背景问题\" class=\"headerlink\" title=\"背景问题\"></a>背景问题</h3><p>首先简要介绍一下问题的背景。假设我们在网络中有一个有 \\(n\\) 个取值的离散分布\\(P(x)\\)，也就是一个\\(n\\)维的向量，每一个元素就是一个概率值。如果我们只是要对其进行采样或者得到最终概率最大的一个取值，我们很容易就可以直接采样或取\\(arg \\max\\)得到结果。但是，如果我们希望这个过程是可导的，该怎么办呢？</p>\n<h3 id=\"Re-Parameterization-Trick\"><a href=\"#Re-Parameterization-Trick\" class=\"headerlink\" title=\"Re-Parameterization Trick\"></a>Re-Parameterization Trick</h3><p>首先介绍一个叫重参数化(Re-Parameterization)的东西，Re-Parameterization解决了上面提到的采样不可导的问题。这里用油管上一个<a href=\"https://www.youtube.com/watch?v=9zKuYvjFFS8\" target=\"_blank\" rel=\"noopener\">变分自动编码器教程</a>中的图片来解释。<br><img src=\"re-paramerise.png\" alt=\"re-paramerise\"><br>首先左边是重参数化之前的形式，我们希望通过学习到了标准差\\(\\phi\\)和均值\\(x\\)，通过对分布\\(q\\)进行采样得到\\(z\\)，然后传入下一层网络。然而这就有个问题，采样过程是没法反传的，这样加载网络中就没法学习了，因此就有了右边的形式。  </p>\n<p>在这里呢，其实就是在网络中只保留可以求导的部分，把不可导的采样部分放到网络外用一个新的输入节点\\(\\epsilon\\)表示。\\(\\epsilon\\)采样的过程和网络学习是分离的，因此不影响网络反传。  </p>\n<p>具体而言，假设我们需要根据均值和方差从正太分布\\(N(x,\\phi^2)\\)采样，我们可以转化为先从\\(\\epsilon=N(0,1)\\)采样，然后计算\\(z=x+\\epsilon\\cdot \\phi\\)来得到我们需要的\\(z\\)。</p>\n<h3 id=\"Gumbel-Softmax-Trick\"><a href=\"#Gumbel-Softmax-Trick\" class=\"headerlink\" title=\"Gumbel-Softmax Trick\"></a>Gumbel-Softmax Trick</h3><p>通过Re-Parameterization Trick我们可以一定条件下解决采样不可导的问题。但回到我们最初的问题，我们并不是在连续的高斯分布上采样，而是在一个离散分布\\(P(x)\\)上采样。上面的重参数后是可导的，而换成离散分布以后，就无法满足了。所以，对于离散分布要怎么处理呢？<br>类似与前面的重参数技巧，我们对于离散变量有Gumbel-Max trick的采样方法：<br><img src=\"gumbel1.png\" alt=\"gumbel-max\"><br>从上图中可以看出，我们将离散变量\\(\\log{\\alpha_1}, \\log{\\alpha_2}, \\log{\\alpha_3}\\)加上Gumbel噪声，然后对相加后的随机变量取\\(\\arg \\max\\)后得到一个onehot向量，就是我们的采样结果，可以表示为：</p>\n<script type=\"math/tex; mode=display\">x_{\\alpha}=\\arg\\max(\\log(\\alpha_i)+G_i)</script><p>但\\(\\arg \\max\\)这个操作是没法求导的，那么我们就用softmax来对\\(\\arg \\max\\)进行松弛，这就得到了我们的Gumbel-Softmax Trick:<br><img src=\"gumbel2.png\" alt=\"gumbel-back\"><br>其中，\\(\\lambda\\)是softmax函数的temperature参数，用于控制采样 当\\(\\lambda \\to \\infty\\)时，所有的激活值对应的激活概率趋近于相同（激活概率差异性较小）；而当\\(\\lambda \\to 0\\)，不同的激活值对应的激活概率差异也就越大，也就越趋向于onehot向量。（温度这个词主要来自于物理学中的温度，当温度高的时候，分子的运动就越剧烈，随机性就越大，反之则越稳定，随机性越小）<br>到这里，我们既可以对分布进行采样，又能够满足在网络中可以反向传播学习。<br>但我们可能还会有这样的问题：为什么不直接就用softmax函数呢，这样不是也能在网络中学习么？我们再回顾下我们的问题就能发现，我们需要采样+能反传，softmax满足能反传但是它不能达到我们根据概率分布采样的目的，而Gumbel-Max Trick就是用来近似分布然后采样的。<br>另外，我们在此用到了Gumbel Distribution—\\(G\\)，是一个极值分布，通俗来讲就是分布的极值的分布，具体可参考：<br><a href=\"https://en.wikipedia.org/wiki/Gumbel_distribution\" target=\"_blank\" rel=\"noopener\">Gumbel distribution</a></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.cnblogs.com/initial-h/p/9468974.html\" target=\"_blank\" rel=\"noopener\">Gumbel-Softmax Trick和Gumbel分布</a><br><a href=\"https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html\" target=\"_blank\" rel=\"noopener\">The Gumbel-Softmax Trick for Inference of Discrete Variables</a><br><a href=\"https://www.youtube.com/watch?v=9zKuYvjFFS8\" target=\"_blank\" rel=\"noopener\">Variational Autoencoders</a><br><a href=\"https://blog.csdn.net/a358463121/article/details/80820878\" target=\"_blank\" rel=\"noopener\">带你认识神奇的Gumbel trick</a><br><a href=\"https://www.youtube.com/watch?v=wVkLM2KKHp8\" target=\"_blank\" rel=\"noopener\">Talk: Categorical Reparameterization with Gumbel-Softmax &amp; The Concrete Distribution</a></p>\n"},{"title":"React 官方文档阅读笔记","catalog":true,"date":"2020-02-05T06:52:05.000Z","subtitle":null,"header-img":null,"_content":"\n## ADVANCED GUIDES\n### Accessibility\n[link](https://reactjs.org/docs/accessibility.html)\n1. 表单控件如 `<input/>` 、 `<textarea/>` 等，通常需要 `<label/>` 标签提高可访问性。在 react 中，属性 `for` 被替代为 `htmlFor` ：\n```\n<label htmlFor=\"namedInput\">Name:</label>\n<input id=\"namedInput\" type=\"text\" name=\"name\"/>\n```\n\n2. 聚焦 input 组件的方法：ref 也可以在父组件创建，通过 props 转发给子组件。\n```\nclass CustomTextInput extends React.Component {\n  constructor(props) {\n    super(props);\n    // Create a ref to store the textInput DOM element\n    this.textInput = React.createRef();\n  }\n  render() {\n  // Use the `ref` callback to store a reference to the text input DOM\n  // element in an instance field (for example, this.textInput).\n    return (\n      <input\n        type=\"text\"\n        ref={this.textInput}\n      />\n    );\n  }\n}\n\n// focus it elsewhere in our component when needed:\nfocus() {\n  // Explicitly focus the text input using the raw DOM API\n  // Note: we're accessing \"current\" to get the DOM node\n  this.textInput.current.focus();\n}\n```\n3. HTMLELement 上有 `onBlur` 及 `onFocus` 两个属性，可用于判断当前元素是否获得焦点。实际应用中，可以用于控制 popover 的显示：当离开某元素时， 隐藏 popover 。\n\n### Code-Splitting\n[link](https://reactjs.org/docs/code-splitting.html)\n1. **Dynamic import**\n```\n// before\nimport { add } from './math';\nconsole.log(add(16, 26));\n\n// after\nimport(\"./math\").then(math => {\n  console.log(math.add(16, 26));\n});\n```\n2. **React.lazy**\n可以将动态导入变成一个组件，返回值必须包裹在 `<Suspense></Suspense>` 内部（可包裹多个 lazy compoments）：\n```\n// before\nimport OtherComponent from './OtherComponent';\n\n// after\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <OtherComponent />\n      </Suspense>\n    </div>\n  );\n}\n```\n3. **Error boundaries**\n之后有专门的章节介绍这部分。\n4. **Route-based code splitting**\n基于路由的动态引入，与 React Router 配合使用：\n```\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport React, { Suspense, lazy } from 'react';\n\nconst Home = lazy(() => import('./routes/Home'));\nconst About = lazy(() => import('./routes/About'));\n\nconst App = () => (\n  <Router>\n    <Suspense fallback={<div>Loading...</div>}>\n      <Switch>\n        <Route exact path=\"/\" component={Home}/>\n        <Route path=\"/about\" component={About}/>\n      </Switch>\n    </Suspense>\n  </Router>\n);\n```\n5. **Named Exports**\n若需要动态导入的模块不是默认导出，那我们可以创建多一个文件，将需要导入的模块转为默认导出：\n```\n// ManyComponents.js\nexport const MyComponent = /* ... */;\nexport const MyUnusedComponent = /* ... */;\n\n// MyComponent.js\nexport { MyComponent as default } from \"./ManyComponents.js\";\n\n// MyApp.js\nimport React, { lazy } from 'react';\nconst MyComponent = lazy(() => import(\"./MyComponent.js\"));\n```\n\n### Context\n[link](https://reactjs.org/docs/context.html)\n上下文提供了一种通过组件树传递数据的方法，而不必逐层传递 props 。\n1. 在类中使用方法如下：\n```\n// Context lets us pass a value deep into the component tree\n// without explicitly threading it through every component.\n// Create a context for the current theme (with \"light\" as the default).\nconst ThemeContext = React.createContext('light');\n\nclass App extends React.Component {\n  render() {\n    // Use a Provider to pass the current theme to the tree below.\n    // Any component can read it, no matter how deep it is.\n    // In this example, we're passing \"dark\" as the current value.\n    return (\n      <ThemeContext.Provider value=\"dark\">\n        <Toolbar />\n      </ThemeContext.Provider>\n    );\n  }\n}\n\n// A component in the middle doesn't have to\n// pass the theme down explicitly anymore.\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\nclass ThemedButton extends React.Component {\n  // Assign a contextType to read the current theme context.\n  // React will find the closest theme Provider above and use its value.\n  // In this example, the current theme is \"dark\".\n  static contextType = ThemeContext;\n  render() {\n    return <Button theme={this.context} />;\n  }\n}\n```\n2. **API**\n(1) React.creatContext : `const MyContext = React.createContext(defaultValue);`\n默认值只会在未找到 `Provider` 的时候使用。\n(2) Context.Provider : `<MyContext.Provider value={/* some value */}>`\n当 `Provider` 修改了 value 值时，所有消费者子孙都会重新渲染。子组件的 `shouldComponentUpdate` 无法捕获到这种更新，因此即使父组件取消更新，子组件也会照常更新。\n(3) Class.contentType : 在类外 `ClassName.contentType = MyContent`，在类中 `static contextType = MyContext;`\n类中有 `contentType` 属性， context 赋值给这个属性（订阅），通过 `this.content` 取到值。\n(4) Context.Consumer : `<MyContext.Consumer>{alue => /* render something based on the context value */}</MyContext.Consumer>`\n(5) Context.displayName : `MyContext.displayName = 'MyDisplayName';`\n用于 React DevTools 。\n3. **从嵌套组件更新 context**\n初始值除了包含默认值，还可以包含一个 `onChange` 函数。\n```\n// Make sure the shape of the default value passed to\n// createContext matches the shape that the consumers expect!\nexport const ThemeContext = React.createContext({\n  theme: themes.dark,\n  toggleTheme: () => {},\n});\n```\n\n### Error Boundaries\n[link](https://reactjs.org/docs/error-boundaries.html)\n错误边界是 React 16 引入的新概念，可以在 render 过程、生命周期方法、以及组件树的构造中捕获**子组件**的错误，显示备用的 UI 而不是崩溃界面。注意，它无法捕获事件处理、异步代码、服务端渲染及它本身的错误。\n将一个类组件转换为一个错误边界组件主要是实现两个方法：在 `static getDerivedStateFromError()` 中捕获子组件错误并触发备用 UI 的渲染；在 `componentDidCatch()` 中打印错误信息。\n```\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n\n// use it as a regular component\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n### Forwarding Refs\n[link](https://reactjs.org/docs/forwarding-refs.html)\nReact 提供了一个向下转发子组件 ref 的方法 `React.forwardRef`，用法如下：\n```\nconst FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"FancyButton\">\n    {props.children}\n  </button>\n));\n\n// You can now get a ref directly to the DOM button:\nconst ref = React.createRef();\n<FancyButton ref={ref}>Click me!</FancyButton>;\n```\n`React.forwardRef` 接受两个参数，第一个参数是 props ，第二个参数是 ref ，作为子组件引用的赋值对象。如果是普通的类组件和函数组件，不会接受 ref 作为参数，也不能在 props 中访问到。\n文档接下来还举了一个在高阶组件中转发 ref 的例子，目前还没完全看懂。🧐\n\n### Fragments\n[link](https://reactjs.org/docs/fragments.html)\n当我们需要对一组子元素进行分组，又不希望添加额外的 DOM 节点时，可以使用 fragments ，有两种写法：`<></>` 和 `<React.Fragment></React.Fragment>` ，第二种写法可以添加 `key` 属性。\n```\nrender() {\n  return (\n    <React.Fragment>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </React.Fragment>\n  );\n}\n\n// or\nrender() {\n  return (\n    <>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </>\n  );\n}\n```\n\n### Higher-Order Components\n[link](https://reactjs.org/docs/higher-order-components.html)\n定义：高阶组件是一个接受组件作为参数，返回新组件的函数。\n```\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n```\n既然是函数组件，那就应该是 pure fuction ，且不能有任何的副作用。它是通过将原始组件包裹在一个新的类组件，并返回这个类组件来实现功能的：\n```\n// This function takes a component...\nfunction withSubscription(WrappedComponent, selectData) {\n  // ...and returns another component...\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.handleChange = this.handleChange.bind(this);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      // ... that takes care of the subscription...\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange() {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    }\n\n    render() {\n      // ... and renders the wrapped component with the fresh data!\n      // Notice that we pass through any additional props\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n}\n```\n注意区分 HOCs 和 container components 。HOCs 使用了 容器组件作为其实现的一部分。\n此外，注意不能在 render 函数中使用 HOCs ，否则会导致每次 render 时整个子组件熟4都会卸载再装载，丢失状态。\n```\nrender() {\n  // A new version of EnhancedComponent is created on every render\n  // EnhancedComponent1 !== EnhancedComponent2\n  const EnhancedComponent = enhance(MyComponent);\n  // That causes the entire subtree to unmount/remount each time!\n  return <EnhancedComponent />;\n}\n```\n\n### JSX In Depth\n[link](https://reactjs.org/docs/jsx-in-depth.html)\nJSX 是 `React.createElement(component, props, ...children)` 的语法糖，编译示例如下：\n```\n<MyButton color=\"blue\" shadowSize={2}>\n  Click Me\n</MyButton>\n\n// compiles into:\nReact.createElement(\n  MyButton,\n  {color: 'blue', shadowSize: 2},\n  'Click Me'\n)\n```\n若是 self-closing tag 如 `<div/>` ，第三个参数是 `null` 。注意组件的首字母一定要大写，否则会被当成普通的内置组件。\n可以在 JSX 中使用点运算符引用 React 组件：\n```\nimport React from 'react';\n\nconst MyComponents = {\n  DatePicker: function DatePicker(props) {\n    return <div>Imagine a {props.color} datepicker here.</div>;\n  }\n}\n\n// use dot-notation\nfunction BlueDatePicker() {\n  return <MyComponents.DatePicker color=\"blue\" />;\n}\n```\n但普通的表达式不能指示 React 元素类型，如果想要动态显示组件，需要先赋值给一个大写字母开头的变量：\n```\nimport React from 'react';\nimport { PhotoStory, VideoStory } from './stories';\n\nconst components = {\n  photo: PhotoStory,\n  video: VideoStory\n};\n\nfunction Story(props) {\n  // you can't write `return <components[props.storyType] story={props.story} />;`\n  // Correct! JSX type can be a capitalized variable.\n  const SpecificStory = components[props.storyType];\n  return <SpecificStory story={props.story} />;\n}\n```\n在同时包含开始标签和结束标签的JSX表达式中，tag 之间的内容作为特殊的 props：`props.children` 传递。\n布尔值、null 和 undefined 会被 React 忽略，下述表达式渲染结果相同：\n```\n<div />\n<div></div>\n<div>{false}</div>\n<div>{null}</div>\n<div>{undefined}</div>\n<div>{true}</div>\n```","source":"_posts/React-官方文档阅读笔记.md","raw":"---\ntitle: React 官方文档阅读笔记\ncatalog: true\ndate: 2020-02-05 14:52:05\nsubtitle:\nheader-img:\ntags: FE \n---\n\n## ADVANCED GUIDES\n### Accessibility\n[link](https://reactjs.org/docs/accessibility.html)\n1. 表单控件如 `<input/>` 、 `<textarea/>` 等，通常需要 `<label/>` 标签提高可访问性。在 react 中，属性 `for` 被替代为 `htmlFor` ：\n```\n<label htmlFor=\"namedInput\">Name:</label>\n<input id=\"namedInput\" type=\"text\" name=\"name\"/>\n```\n\n2. 聚焦 input 组件的方法：ref 也可以在父组件创建，通过 props 转发给子组件。\n```\nclass CustomTextInput extends React.Component {\n  constructor(props) {\n    super(props);\n    // Create a ref to store the textInput DOM element\n    this.textInput = React.createRef();\n  }\n  render() {\n  // Use the `ref` callback to store a reference to the text input DOM\n  // element in an instance field (for example, this.textInput).\n    return (\n      <input\n        type=\"text\"\n        ref={this.textInput}\n      />\n    );\n  }\n}\n\n// focus it elsewhere in our component when needed:\nfocus() {\n  // Explicitly focus the text input using the raw DOM API\n  // Note: we're accessing \"current\" to get the DOM node\n  this.textInput.current.focus();\n}\n```\n3. HTMLELement 上有 `onBlur` 及 `onFocus` 两个属性，可用于判断当前元素是否获得焦点。实际应用中，可以用于控制 popover 的显示：当离开某元素时， 隐藏 popover 。\n\n### Code-Splitting\n[link](https://reactjs.org/docs/code-splitting.html)\n1. **Dynamic import**\n```\n// before\nimport { add } from './math';\nconsole.log(add(16, 26));\n\n// after\nimport(\"./math\").then(math => {\n  console.log(math.add(16, 26));\n});\n```\n2. **React.lazy**\n可以将动态导入变成一个组件，返回值必须包裹在 `<Suspense></Suspense>` 内部（可包裹多个 lazy compoments）：\n```\n// before\nimport OtherComponent from './OtherComponent';\n\n// after\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <OtherComponent />\n      </Suspense>\n    </div>\n  );\n}\n```\n3. **Error boundaries**\n之后有专门的章节介绍这部分。\n4. **Route-based code splitting**\n基于路由的动态引入，与 React Router 配合使用：\n```\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport React, { Suspense, lazy } from 'react';\n\nconst Home = lazy(() => import('./routes/Home'));\nconst About = lazy(() => import('./routes/About'));\n\nconst App = () => (\n  <Router>\n    <Suspense fallback={<div>Loading...</div>}>\n      <Switch>\n        <Route exact path=\"/\" component={Home}/>\n        <Route path=\"/about\" component={About}/>\n      </Switch>\n    </Suspense>\n  </Router>\n);\n```\n5. **Named Exports**\n若需要动态导入的模块不是默认导出，那我们可以创建多一个文件，将需要导入的模块转为默认导出：\n```\n// ManyComponents.js\nexport const MyComponent = /* ... */;\nexport const MyUnusedComponent = /* ... */;\n\n// MyComponent.js\nexport { MyComponent as default } from \"./ManyComponents.js\";\n\n// MyApp.js\nimport React, { lazy } from 'react';\nconst MyComponent = lazy(() => import(\"./MyComponent.js\"));\n```\n\n### Context\n[link](https://reactjs.org/docs/context.html)\n上下文提供了一种通过组件树传递数据的方法，而不必逐层传递 props 。\n1. 在类中使用方法如下：\n```\n// Context lets us pass a value deep into the component tree\n// without explicitly threading it through every component.\n// Create a context for the current theme (with \"light\" as the default).\nconst ThemeContext = React.createContext('light');\n\nclass App extends React.Component {\n  render() {\n    // Use a Provider to pass the current theme to the tree below.\n    // Any component can read it, no matter how deep it is.\n    // In this example, we're passing \"dark\" as the current value.\n    return (\n      <ThemeContext.Provider value=\"dark\">\n        <Toolbar />\n      </ThemeContext.Provider>\n    );\n  }\n}\n\n// A component in the middle doesn't have to\n// pass the theme down explicitly anymore.\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\nclass ThemedButton extends React.Component {\n  // Assign a contextType to read the current theme context.\n  // React will find the closest theme Provider above and use its value.\n  // In this example, the current theme is \"dark\".\n  static contextType = ThemeContext;\n  render() {\n    return <Button theme={this.context} />;\n  }\n}\n```\n2. **API**\n(1) React.creatContext : `const MyContext = React.createContext(defaultValue);`\n默认值只会在未找到 `Provider` 的时候使用。\n(2) Context.Provider : `<MyContext.Provider value={/* some value */}>`\n当 `Provider` 修改了 value 值时，所有消费者子孙都会重新渲染。子组件的 `shouldComponentUpdate` 无法捕获到这种更新，因此即使父组件取消更新，子组件也会照常更新。\n(3) Class.contentType : 在类外 `ClassName.contentType = MyContent`，在类中 `static contextType = MyContext;`\n类中有 `contentType` 属性， context 赋值给这个属性（订阅），通过 `this.content` 取到值。\n(4) Context.Consumer : `<MyContext.Consumer>{alue => /* render something based on the context value */}</MyContext.Consumer>`\n(5) Context.displayName : `MyContext.displayName = 'MyDisplayName';`\n用于 React DevTools 。\n3. **从嵌套组件更新 context**\n初始值除了包含默认值，还可以包含一个 `onChange` 函数。\n```\n// Make sure the shape of the default value passed to\n// createContext matches the shape that the consumers expect!\nexport const ThemeContext = React.createContext({\n  theme: themes.dark,\n  toggleTheme: () => {},\n});\n```\n\n### Error Boundaries\n[link](https://reactjs.org/docs/error-boundaries.html)\n错误边界是 React 16 引入的新概念，可以在 render 过程、生命周期方法、以及组件树的构造中捕获**子组件**的错误，显示备用的 UI 而不是崩溃界面。注意，它无法捕获事件处理、异步代码、服务端渲染及它本身的错误。\n将一个类组件转换为一个错误边界组件主要是实现两个方法：在 `static getDerivedStateFromError()` 中捕获子组件错误并触发备用 UI 的渲染；在 `componentDidCatch()` 中打印错误信息。\n```\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    logErrorToMyService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n\n// use it as a regular component\n<ErrorBoundary>\n  <MyWidget />\n</ErrorBoundary>\n```\n\n### Forwarding Refs\n[link](https://reactjs.org/docs/forwarding-refs.html)\nReact 提供了一个向下转发子组件 ref 的方法 `React.forwardRef`，用法如下：\n```\nconst FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"FancyButton\">\n    {props.children}\n  </button>\n));\n\n// You can now get a ref directly to the DOM button:\nconst ref = React.createRef();\n<FancyButton ref={ref}>Click me!</FancyButton>;\n```\n`React.forwardRef` 接受两个参数，第一个参数是 props ，第二个参数是 ref ，作为子组件引用的赋值对象。如果是普通的类组件和函数组件，不会接受 ref 作为参数，也不能在 props 中访问到。\n文档接下来还举了一个在高阶组件中转发 ref 的例子，目前还没完全看懂。🧐\n\n### Fragments\n[link](https://reactjs.org/docs/fragments.html)\n当我们需要对一组子元素进行分组，又不希望添加额外的 DOM 节点时，可以使用 fragments ，有两种写法：`<></>` 和 `<React.Fragment></React.Fragment>` ，第二种写法可以添加 `key` 属性。\n```\nrender() {\n  return (\n    <React.Fragment>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </React.Fragment>\n  );\n}\n\n// or\nrender() {\n  return (\n    <>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </>\n  );\n}\n```\n\n### Higher-Order Components\n[link](https://reactjs.org/docs/higher-order-components.html)\n定义：高阶组件是一个接受组件作为参数，返回新组件的函数。\n```\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n```\n既然是函数组件，那就应该是 pure fuction ，且不能有任何的副作用。它是通过将原始组件包裹在一个新的类组件，并返回这个类组件来实现功能的：\n```\n// This function takes a component...\nfunction withSubscription(WrappedComponent, selectData) {\n  // ...and returns another component...\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.handleChange = this.handleChange.bind(this);\n      this.state = {\n        data: selectData(DataSource, props)\n      };\n    }\n\n    componentDidMount() {\n      // ... that takes care of the subscription...\n      DataSource.addChangeListener(this.handleChange);\n    }\n\n    componentWillUnmount() {\n      DataSource.removeChangeListener(this.handleChange);\n    }\n\n    handleChange() {\n      this.setState({\n        data: selectData(DataSource, this.props)\n      });\n    }\n\n    render() {\n      // ... and renders the wrapped component with the fresh data!\n      // Notice that we pass through any additional props\n      return <WrappedComponent data={this.state.data} {...this.props} />;\n    }\n  };\n}\n```\n注意区分 HOCs 和 container components 。HOCs 使用了 容器组件作为其实现的一部分。\n此外，注意不能在 render 函数中使用 HOCs ，否则会导致每次 render 时整个子组件熟4都会卸载再装载，丢失状态。\n```\nrender() {\n  // A new version of EnhancedComponent is created on every render\n  // EnhancedComponent1 !== EnhancedComponent2\n  const EnhancedComponent = enhance(MyComponent);\n  // That causes the entire subtree to unmount/remount each time!\n  return <EnhancedComponent />;\n}\n```\n\n### JSX In Depth\n[link](https://reactjs.org/docs/jsx-in-depth.html)\nJSX 是 `React.createElement(component, props, ...children)` 的语法糖，编译示例如下：\n```\n<MyButton color=\"blue\" shadowSize={2}>\n  Click Me\n</MyButton>\n\n// compiles into:\nReact.createElement(\n  MyButton,\n  {color: 'blue', shadowSize: 2},\n  'Click Me'\n)\n```\n若是 self-closing tag 如 `<div/>` ，第三个参数是 `null` 。注意组件的首字母一定要大写，否则会被当成普通的内置组件。\n可以在 JSX 中使用点运算符引用 React 组件：\n```\nimport React from 'react';\n\nconst MyComponents = {\n  DatePicker: function DatePicker(props) {\n    return <div>Imagine a {props.color} datepicker here.</div>;\n  }\n}\n\n// use dot-notation\nfunction BlueDatePicker() {\n  return <MyComponents.DatePicker color=\"blue\" />;\n}\n```\n但普通的表达式不能指示 React 元素类型，如果想要动态显示组件，需要先赋值给一个大写字母开头的变量：\n```\nimport React from 'react';\nimport { PhotoStory, VideoStory } from './stories';\n\nconst components = {\n  photo: PhotoStory,\n  video: VideoStory\n};\n\nfunction Story(props) {\n  // you can't write `return <components[props.storyType] story={props.story} />;`\n  // Correct! JSX type can be a capitalized variable.\n  const SpecificStory = components[props.storyType];\n  return <SpecificStory story={props.story} />;\n}\n```\n在同时包含开始标签和结束标签的JSX表达式中，tag 之间的内容作为特殊的 props：`props.children` 传递。\n布尔值、null 和 undefined 会被 React 忽略，下述表达式渲染结果相同：\n```\n<div />\n<div></div>\n<div>{false}</div>\n<div>{null}</div>\n<div>{undefined}</div>\n<div>{true}</div>\n```","slug":"React-官方文档阅读笔记","published":1,"updated":"2020-02-07T07:53:11.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7bsdjt5000mcsuet8q93a0a","content":"<h2 id=\"advanced-guides\"><a href=\"#ADVANCED-GUIDES\" class=\"headerlink\" title=\"ADVANCED GUIDES\"></a>ADVANCED GUIDES</h2><h3 id=\"accessibility\"><a href=\"#Accessibility\" class=\"headerlink\" title=\"Accessibility\"></a>Accessibility</h3><p><a href=\"https://reactjs.org/docs/accessibility.html\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<ol>\n<li><p>表单控件如 <code>&lt;input/&gt;</code> 、 <code>&lt;textarea/&gt;</code> 等，通常需要 <code>&lt;label/&gt;</code> 标签提高可访问性。在 react 中，属性 <code>for</code> 被替代为 <code>htmlFor</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;label htmlFor=&quot;namedInput&quot;&gt;Name:&lt;/label&gt;</span><br><span class=\"line\">&lt;input id=&quot;namedInput&quot; type=&quot;text&quot; name=&quot;name&quot;/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>聚焦 input 组件的方法：ref 也可以在父组件创建，通过 props 转发给子组件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CustomTextInput extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    // Create a ref to store the textInput DOM element</span><br><span class=\"line\">    this.textInput = React.createRef();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">  // Use the `ref` callback to store a reference to the text input DOM</span><br><span class=\"line\">  // element in an instance field (for example, this.textInput).</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        type=&quot;text&quot;</span><br><span class=\"line\">        ref=&#123;this.textInput&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// focus it elsewhere in our component when needed:</span><br><span class=\"line\">focus() &#123;</span><br><span class=\"line\">  // Explicitly focus the text input using the raw DOM API</span><br><span class=\"line\">  // Note: we&apos;re accessing &quot;current&quot; to get the DOM node</span><br><span class=\"line\">  this.textInput.current.focus();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTMLELement 上有 <code>onBlur</code> 及 <code>onFocus</code> 两个属性，可用于判断当前元素是否获得焦点。实际应用中，可以用于控制 popover 的显示：当离开某元素时， 隐藏 popover 。</p>\n</li>\n</ol>\n<h3 id=\"code-splitting\"><a href=\"#Code-Splitting\" class=\"headerlink\" title=\"Code-Splitting\"></a>Code-Splitting</h3><p><a href=\"https://reactjs.org/docs/code-splitting.html\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<ol>\n<li><p><strong>Dynamic import</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// before</span><br><span class=\"line\">import &#123; add &#125; from &apos;./math&apos;;</span><br><span class=\"line\">console.log(add(16, 26));</span><br><span class=\"line\"></span><br><span class=\"line\">// after</span><br><span class=\"line\">import(&quot;./math&quot;).then(math =&gt; &#123;</span><br><span class=\"line\">  console.log(math.add(16, 26));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>React.lazy</strong><br>可以将动态导入变成一个组件，返回值必须包裹在 <code>&lt;Suspense&gt;&lt;/Suspense&gt;</code> 内部（可包裹多个 lazy compoments）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// before</span><br><span class=\"line\">import OtherComponent from &apos;./OtherComponent&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// after</span><br><span class=\"line\">const OtherComponent = React.lazy(() =&gt; import(&apos;./OtherComponent&apos;));</span><br><span class=\"line\"></span><br><span class=\"line\">function MyComponent() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class=\"line\">        &lt;OtherComponent /&gt;</span><br><span class=\"line\">      &lt;/Suspense&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Error boundaries</strong><br>之后有专门的章节介绍这部分。</p>\n</li>\n<li><p><strong>Route-based code splitting</strong><br>基于路由的动态引入，与 React Router 配合使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; BrowserRouter as Router, Route, Switch &#125; from &apos;react-router-dom&apos;;</span><br><span class=\"line\">import React, &#123; Suspense, lazy &#125; from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const Home = lazy(() =&gt; import(&apos;./routes/Home&apos;));</span><br><span class=\"line\">const About = lazy(() =&gt; import(&apos;./routes/About&apos;));</span><br><span class=\"line\"></span><br><span class=\"line\">const App = () =&gt; (</span><br><span class=\"line\">  &lt;Router&gt;</span><br><span class=\"line\">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class=\"line\">      &lt;Switch&gt;</span><br><span class=\"line\">        &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class=\"line\">        &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class=\"line\">      &lt;/Switch&gt;</span><br><span class=\"line\">    &lt;/Suspense&gt;</span><br><span class=\"line\">  &lt;/Router&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Named Exports</strong><br>若需要动态导入的模块不是默认导出，那我们可以创建多一个文件，将需要导入的模块转为默认导出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ManyComponents.js</span><br><span class=\"line\">export const MyComponent = /* ... */;</span><br><span class=\"line\">export const MyUnusedComponent = /* ... */;</span><br><span class=\"line\"></span><br><span class=\"line\">// MyComponent.js</span><br><span class=\"line\">export &#123; MyComponent as default &#125; from &quot;./ManyComponents.js&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// MyApp.js</span><br><span class=\"line\">import React, &#123; lazy &#125; from &apos;react&apos;;</span><br><span class=\"line\">const MyComponent = lazy(() =&gt; import(&quot;./MyComponent.js&quot;));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h3><p><a href=\"https://reactjs.org/docs/context.html\" target=\"_blank\" rel=\"noopener\">link</a><br>上下文提供了一种通过组件树传递数据的方法，而不必逐层传递 props 。</p>\n<ol>\n<li><p>在类中使用方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Context lets us pass a value deep into the component tree</span><br><span class=\"line\">// without explicitly threading it through every component.</span><br><span class=\"line\">// Create a context for the current theme (with &quot;light&quot; as the default).</span><br><span class=\"line\">const ThemeContext = React.createContext(&apos;light&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    // Use a Provider to pass the current theme to the tree below.</span><br><span class=\"line\">    // Any component can read it, no matter how deep it is.</span><br><span class=\"line\">    // In this example, we&apos;re passing &quot;dark&quot; as the current value.</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;</span><br><span class=\"line\">        &lt;Toolbar /&gt;</span><br><span class=\"line\">      &lt;/ThemeContext.Provider&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// A component in the middle doesn&apos;t have to</span><br><span class=\"line\">// pass the theme down explicitly anymore.</span><br><span class=\"line\">function Toolbar(props) &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;ThemedButton /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ThemedButton extends React.Component &#123;</span><br><span class=\"line\">  // Assign a contextType to read the current theme context.</span><br><span class=\"line\">  // React will find the closest theme Provider above and use its value.</span><br><span class=\"line\">  // In this example, the current theme is &quot;dark&quot;.</span><br><span class=\"line\">  static contextType = ThemeContext;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;Button theme=&#123;this.context&#125; /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>API</strong><br>(1) React.creatContext : <code>const MyContext = React.createContext(defaultValue);</code><br>默认值只会在未找到 <code>Provider</code> 的时候使用。<br>(2) Context.Provider : <code>&lt;MyContext.Provider value={/* some value */}&gt;</code><br>当 <code>Provider</code> 修改了 value 值时，所有消费者子孙都会重新渲染。子组件的 <code>shouldComponentUpdate</code> 无法捕获到这种更新，因此即使父组件取消更新，子组件也会照常更新。<br>(3) Class.contentType : 在类外 <code>ClassName.contentType = MyContent</code>，在类中 <code>static contextType = MyContext;</code><br>类中有 <code>contentType</code> 属性， context 赋值给这个属性（订阅），通过 <code>this.content</code> 取到值。<br>(4) Context.Consumer : <code>&lt;MyContext.Consumer&gt;{alue =&gt; /* render something based on the context value */}&lt;/MyContext.Consumer&gt;</code><br>(5) Context.displayName : <code>MyContext.displayName = &#39;MyDisplayName&#39;;</code><br>用于 React DevTools 。</p>\n</li>\n<li><strong>从嵌套组件更新 context</strong><br>初始值除了包含默认值，还可以包含一个 <code>onChange</code> 函数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Make sure the shape of the default value passed to</span><br><span class=\"line\">// createContext matches the shape that the consumers expect!</span><br><span class=\"line\">export const ThemeContext = React.createContext(&#123;</span><br><span class=\"line\">  theme: themes.dark,</span><br><span class=\"line\">  toggleTheme: () =&gt; &#123;&#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"error-boundaries\"><a href=\"#Error-Boundaries\" class=\"headerlink\" title=\"Error Boundaries\"></a>Error Boundaries</h3><p><a href=\"https://reactjs.org/docs/error-boundaries.html\" target=\"_blank\" rel=\"noopener\">link</a><br>错误边界是 React 16 引入的新概念，可以在 render 过程、生命周期方法、以及组件树的构造中捕获<strong>子组件</strong>的错误，显示备用的 UI 而不是崩溃界面。注意，它无法捕获事件处理、异步代码、服务端渲染及它本身的错误。<br>将一个类组件转换为一个错误边界组件主要是实现两个方法：在 <code>static getDerivedStateFromError()</code> 中捕获子组件错误并触发备用 UI 的渲染；在 <code>componentDidCatch()</code> 中打印错误信息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ErrorBoundary extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; hasError: false &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static getDerivedStateFromError(error) &#123;</span><br><span class=\"line\">    // Update state so the next render will show the fallback UI.</span><br><span class=\"line\">    return &#123; hasError: true &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidCatch(error, errorInfo) &#123;</span><br><span class=\"line\">    // You can also log the error to an error reporting service</span><br><span class=\"line\">    logErrorToMyService(error, errorInfo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    if (this.state.hasError) &#123;</span><br><span class=\"line\">      // You can render any custom fallback UI</span><br><span class=\"line\">      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return this.props.children; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// use it as a regular component</span><br><span class=\"line\">&lt;ErrorBoundary&gt;</span><br><span class=\"line\">  &lt;MyWidget /&gt;</span><br><span class=\"line\">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"forwarding-refs\"><a href=\"#Forwarding-Refs\" class=\"headerlink\" title=\"Forwarding Refs\"></a>Forwarding Refs</h3><p><a href=\"https://reactjs.org/docs/forwarding-refs.html\" target=\"_blank\" rel=\"noopener\">link</a><br>React 提供了一个向下转发子组件 ref 的方法 <code>React.forwardRef</code>，用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const FancyButton = React.forwardRef((props, ref) =&gt; (</span><br><span class=\"line\">  &lt;button ref=&#123;ref&#125; className=&quot;FancyButton&quot;&gt;</span><br><span class=\"line\">    &#123;props.children&#125;</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">));</span><br><span class=\"line\"></span><br><span class=\"line\">// You can now get a ref directly to the DOM button:</span><br><span class=\"line\">const ref = React.createRef();</span><br><span class=\"line\">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure></p>\n<p><code>React.forwardRef</code> 接受两个参数，第一个参数是 props ，第二个参数是 ref ，作为子组件引用的赋值对象。如果是普通的类组件和函数组件，不会接受 ref 作为参数，也不能在 props 中访问到。<br>文档接下来还举了一个在高阶组件中转发 ref 的例子，目前还没完全看懂。🧐</p>\n<h3 id=\"fragments\"><a href=\"#Fragments\" class=\"headerlink\" title=\"Fragments\"></a>Fragments</h3><p><a href=\"https://reactjs.org/docs/fragments.html\" target=\"_blank\" rel=\"noopener\">link</a><br>当我们需要对一组子元素进行分组，又不希望添加额外的 DOM 节点时，可以使用 fragments ，有两种写法：<code>&lt;&gt;&lt;/&gt;</code> 和 <code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code> ，第二种写法可以添加 <code>key</code> 属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;React.Fragment&gt;</span><br><span class=\"line\">      &lt;ChildA /&gt;</span><br><span class=\"line\">      &lt;ChildB /&gt;</span><br><span class=\"line\">      &lt;ChildC /&gt;</span><br><span class=\"line\">    &lt;/React.Fragment&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// or</span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;ChildA /&gt;</span><br><span class=\"line\">      &lt;ChildB /&gt;</span><br><span class=\"line\">      &lt;ChildC /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"higher-order-components\"><a href=\"#Higher-Order-Components\" class=\"headerlink\" title=\"Higher-Order Components\"></a>Higher-Order Components</h3><p><a href=\"https://reactjs.org/docs/higher-order-components.html\" target=\"_blank\" rel=\"noopener\">link</a><br>定义：高阶组件是一个接受组件作为参数，返回新组件的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure></p>\n<p>既然是函数组件，那就应该是 pure fuction ，且不能有任何的副作用。它是通过将原始组件包裹在一个新的类组件，并返回这个类组件来实现功能的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This function takes a component...</span><br><span class=\"line\">function withSubscription(WrappedComponent, selectData) &#123;</span><br><span class=\"line\">  // ...and returns another component...</span><br><span class=\"line\">  return class extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.handleChange = this.handleChange.bind(this);</span><br><span class=\"line\">      this.state = &#123;</span><br><span class=\"line\">        data: selectData(DataSource, props)</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      // ... that takes care of the subscription...</span><br><span class=\"line\">      DataSource.addChangeListener(this.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      DataSource.removeChangeListener(this.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange() &#123;</span><br><span class=\"line\">      this.setState(&#123;</span><br><span class=\"line\">        data: selectData(DataSource, this.props)</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      // ... and renders the wrapped component with the fresh data!</span><br><span class=\"line\">      // Notice that we pass through any additional props</span><br><span class=\"line\">      return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意区分 HOCs 和 container components 。HOCs 使用了 容器组件作为其实现的一部分。<br>此外，注意不能在 render 函数中使用 HOCs ，否则会导致每次 render 时整个子组件熟4都会卸载再装载，丢失状态。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  // A new version of EnhancedComponent is created on every render</span><br><span class=\"line\">  // EnhancedComponent1 !== EnhancedComponent2</span><br><span class=\"line\">  const EnhancedComponent = enhance(MyComponent);</span><br><span class=\"line\">  // That causes the entire subtree to unmount/remount each time!</span><br><span class=\"line\">  return &lt;EnhancedComponent /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"jsx-in-depth\"><a href=\"#JSX-In-Depth\" class=\"headerlink\" title=\"JSX In Depth\"></a>JSX In Depth</h3><p><a href=\"https://reactjs.org/docs/jsx-in-depth.html\" target=\"_blank\" rel=\"noopener\">link</a><br>JSX 是 <code>React.createElement(component, props, ...children)</code> 的语法糖，编译示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt;</span><br><span class=\"line\">  Click Me</span><br><span class=\"line\">&lt;/MyButton&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// compiles into:</span><br><span class=\"line\">React.createElement(</span><br><span class=\"line\">  MyButton,</span><br><span class=\"line\">  &#123;color: &apos;blue&apos;, shadowSize: 2&#125;,</span><br><span class=\"line\">  &apos;Click Me&apos;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>若是 self-closing tag 如 <code>&lt;div/&gt;</code> ，第三个参数是 <code>null</code> 。注意组件的首字母一定要大写，否则会被当成普通的内置组件。<br>可以在 JSX 中使用点运算符引用 React 组件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const MyComponents = &#123;</span><br><span class=\"line\">  DatePicker: function DatePicker(props) &#123;</span><br><span class=\"line\">    return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// use dot-notation</span><br><span class=\"line\">function BlueDatePicker() &#123;</span><br><span class=\"line\">  return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但普通的表达式不能指示 React 元素类型，如果想要动态显示组件，需要先赋值给一个大写字母开头的变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const components = &#123;</span><br><span class=\"line\">  photo: PhotoStory,</span><br><span class=\"line\">  video: VideoStory</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function Story(props) &#123;</span><br><span class=\"line\">  // you can&apos;t write `return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;`</span><br><span class=\"line\">  // Correct! JSX type can be a capitalized variable.</span><br><span class=\"line\">  const SpecificStory = components[props.storyType];</span><br><span class=\"line\">  return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在同时包含开始标签和结束标签的JSX表达式中，tag 之间的内容作为特殊的 props：<code>props.children</code> 传递。<br>布尔值、null 和 undefined 会被 React 忽略，下述表达式渲染结果相同：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div /&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&#123;false&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&#123;null&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&#123;true&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ADVANCED-GUIDES\"><a href=\"#ADVANCED-GUIDES\" class=\"headerlink\" title=\"ADVANCED GUIDES\"></a>ADVANCED GUIDES</h2><h3 id=\"Accessibility\"><a href=\"#Accessibility\" class=\"headerlink\" title=\"Accessibility\"></a>Accessibility</h3><p><a href=\"https://reactjs.org/docs/accessibility.html\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<ol>\n<li><p>表单控件如 <code>&lt;input/&gt;</code> 、 <code>&lt;textarea/&gt;</code> 等，通常需要 <code>&lt;label/&gt;</code> 标签提高可访问性。在 react 中，属性 <code>for</code> 被替代为 <code>htmlFor</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;label htmlFor=&quot;namedInput&quot;&gt;Name:&lt;/label&gt;</span><br><span class=\"line\">&lt;input id=&quot;namedInput&quot; type=&quot;text&quot; name=&quot;name&quot;/&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>聚焦 input 组件的方法：ref 也可以在父组件创建，通过 props 转发给子组件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CustomTextInput extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    // Create a ref to store the textInput DOM element</span><br><span class=\"line\">    this.textInput = React.createRef();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">  // Use the `ref` callback to store a reference to the text input DOM</span><br><span class=\"line\">  // element in an instance field (for example, this.textInput).</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;input</span><br><span class=\"line\">        type=&quot;text&quot;</span><br><span class=\"line\">        ref=&#123;this.textInput&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// focus it elsewhere in our component when needed:</span><br><span class=\"line\">focus() &#123;</span><br><span class=\"line\">  // Explicitly focus the text input using the raw DOM API</span><br><span class=\"line\">  // Note: we&apos;re accessing &quot;current&quot; to get the DOM node</span><br><span class=\"line\">  this.textInput.current.focus();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTMLELement 上有 <code>onBlur</code> 及 <code>onFocus</code> 两个属性，可用于判断当前元素是否获得焦点。实际应用中，可以用于控制 popover 的显示：当离开某元素时， 隐藏 popover 。</p>\n</li>\n</ol>\n<h3 id=\"Code-Splitting\"><a href=\"#Code-Splitting\" class=\"headerlink\" title=\"Code-Splitting\"></a>Code-Splitting</h3><p><a href=\"https://reactjs.org/docs/code-splitting.html\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<ol>\n<li><p><strong>Dynamic import</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// before</span><br><span class=\"line\">import &#123; add &#125; from &apos;./math&apos;;</span><br><span class=\"line\">console.log(add(16, 26));</span><br><span class=\"line\"></span><br><span class=\"line\">// after</span><br><span class=\"line\">import(&quot;./math&quot;).then(math =&gt; &#123;</span><br><span class=\"line\">  console.log(math.add(16, 26));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>React.lazy</strong><br>可以将动态导入变成一个组件，返回值必须包裹在 <code>&lt;Suspense&gt;&lt;/Suspense&gt;</code> 内部（可包裹多个 lazy compoments）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// before</span><br><span class=\"line\">import OtherComponent from &apos;./OtherComponent&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// after</span><br><span class=\"line\">const OtherComponent = React.lazy(() =&gt; import(&apos;./OtherComponent&apos;));</span><br><span class=\"line\"></span><br><span class=\"line\">function MyComponent() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class=\"line\">        &lt;OtherComponent /&gt;</span><br><span class=\"line\">      &lt;/Suspense&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Error boundaries</strong><br>之后有专门的章节介绍这部分。</p>\n</li>\n<li><p><strong>Route-based code splitting</strong><br>基于路由的动态引入，与 React Router 配合使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; BrowserRouter as Router, Route, Switch &#125; from &apos;react-router-dom&apos;;</span><br><span class=\"line\">import React, &#123; Suspense, lazy &#125; from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const Home = lazy(() =&gt; import(&apos;./routes/Home&apos;));</span><br><span class=\"line\">const About = lazy(() =&gt; import(&apos;./routes/About&apos;));</span><br><span class=\"line\"></span><br><span class=\"line\">const App = () =&gt; (</span><br><span class=\"line\">  &lt;Router&gt;</span><br><span class=\"line\">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class=\"line\">      &lt;Switch&gt;</span><br><span class=\"line\">        &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class=\"line\">        &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class=\"line\">      &lt;/Switch&gt;</span><br><span class=\"line\">    &lt;/Suspense&gt;</span><br><span class=\"line\">  &lt;/Router&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Named Exports</strong><br>若需要动态导入的模块不是默认导出，那我们可以创建多一个文件，将需要导入的模块转为默认导出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ManyComponents.js</span><br><span class=\"line\">export const MyComponent = /* ... */;</span><br><span class=\"line\">export const MyUnusedComponent = /* ... */;</span><br><span class=\"line\"></span><br><span class=\"line\">// MyComponent.js</span><br><span class=\"line\">export &#123; MyComponent as default &#125; from &quot;./ManyComponents.js&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// MyApp.js</span><br><span class=\"line\">import React, &#123; lazy &#125; from &apos;react&apos;;</span><br><span class=\"line\">const MyComponent = lazy(() =&gt; import(&quot;./MyComponent.js&quot;));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h3><p><a href=\"https://reactjs.org/docs/context.html\" target=\"_blank\" rel=\"noopener\">link</a><br>上下文提供了一种通过组件树传递数据的方法，而不必逐层传递 props 。</p>\n<ol>\n<li><p>在类中使用方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Context lets us pass a value deep into the component tree</span><br><span class=\"line\">// without explicitly threading it through every component.</span><br><span class=\"line\">// Create a context for the current theme (with &quot;light&quot; as the default).</span><br><span class=\"line\">const ThemeContext = React.createContext(&apos;light&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">class App extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    // Use a Provider to pass the current theme to the tree below.</span><br><span class=\"line\">    // Any component can read it, no matter how deep it is.</span><br><span class=\"line\">    // In this example, we&apos;re passing &quot;dark&quot; as the current value.</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;</span><br><span class=\"line\">        &lt;Toolbar /&gt;</span><br><span class=\"line\">      &lt;/ThemeContext.Provider&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// A component in the middle doesn&apos;t have to</span><br><span class=\"line\">// pass the theme down explicitly anymore.</span><br><span class=\"line\">function Toolbar(props) &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;ThemedButton /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ThemedButton extends React.Component &#123;</span><br><span class=\"line\">  // Assign a contextType to read the current theme context.</span><br><span class=\"line\">  // React will find the closest theme Provider above and use its value.</span><br><span class=\"line\">  // In this example, the current theme is &quot;dark&quot;.</span><br><span class=\"line\">  static contextType = ThemeContext;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return &lt;Button theme=&#123;this.context&#125; /&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>API</strong><br>(1) React.creatContext : <code>const MyContext = React.createContext(defaultValue);</code><br>默认值只会在未找到 <code>Provider</code> 的时候使用。<br>(2) Context.Provider : <code>&lt;MyContext.Provider value={/* some value */}&gt;</code><br>当 <code>Provider</code> 修改了 value 值时，所有消费者子孙都会重新渲染。子组件的 <code>shouldComponentUpdate</code> 无法捕获到这种更新，因此即使父组件取消更新，子组件也会照常更新。<br>(3) Class.contentType : 在类外 <code>ClassName.contentType = MyContent</code>，在类中 <code>static contextType = MyContext;</code><br>类中有 <code>contentType</code> 属性， context 赋值给这个属性（订阅），通过 <code>this.content</code> 取到值。<br>(4) Context.Consumer : <code>&lt;MyContext.Consumer&gt;{alue =&gt; /* render something based on the context value */}&lt;/MyContext.Consumer&gt;</code><br>(5) Context.displayName : <code>MyContext.displayName = &#39;MyDisplayName&#39;;</code><br>用于 React DevTools 。</p>\n</li>\n<li><strong>从嵌套组件更新 context</strong><br>初始值除了包含默认值，还可以包含一个 <code>onChange</code> 函数。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Make sure the shape of the default value passed to</span><br><span class=\"line\">// createContext matches the shape that the consumers expect!</span><br><span class=\"line\">export const ThemeContext = React.createContext(&#123;</span><br><span class=\"line\">  theme: themes.dark,</span><br><span class=\"line\">  toggleTheme: () =&gt; &#123;&#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Error-Boundaries\"><a href=\"#Error-Boundaries\" class=\"headerlink\" title=\"Error Boundaries\"></a>Error Boundaries</h3><p><a href=\"https://reactjs.org/docs/error-boundaries.html\" target=\"_blank\" rel=\"noopener\">link</a><br>错误边界是 React 16 引入的新概念，可以在 render 过程、生命周期方法、以及组件树的构造中捕获<strong>子组件</strong>的错误，显示备用的 UI 而不是崩溃界面。注意，它无法捕获事件处理、异步代码、服务端渲染及它本身的错误。<br>将一个类组件转换为一个错误边界组件主要是实现两个方法：在 <code>static getDerivedStateFromError()</code> 中捕获子组件错误并触发备用 UI 的渲染；在 <code>componentDidCatch()</code> 中打印错误信息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ErrorBoundary extends React.Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123; hasError: false &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static getDerivedStateFromError(error) &#123;</span><br><span class=\"line\">    // Update state so the next render will show the fallback UI.</span><br><span class=\"line\">    return &#123; hasError: true &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidCatch(error, errorInfo) &#123;</span><br><span class=\"line\">    // You can also log the error to an error reporting service</span><br><span class=\"line\">    logErrorToMyService(error, errorInfo);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    if (this.state.hasError) &#123;</span><br><span class=\"line\">      // You can render any custom fallback UI</span><br><span class=\"line\">      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return this.props.children; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// use it as a regular component</span><br><span class=\"line\">&lt;ErrorBoundary&gt;</span><br><span class=\"line\">  &lt;MyWidget /&gt;</span><br><span class=\"line\">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Forwarding-Refs\"><a href=\"#Forwarding-Refs\" class=\"headerlink\" title=\"Forwarding Refs\"></a>Forwarding Refs</h3><p><a href=\"https://reactjs.org/docs/forwarding-refs.html\" target=\"_blank\" rel=\"noopener\">link</a><br>React 提供了一个向下转发子组件 ref 的方法 <code>React.forwardRef</code>，用法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const FancyButton = React.forwardRef((props, ref) =&gt; (</span><br><span class=\"line\">  &lt;button ref=&#123;ref&#125; className=&quot;FancyButton&quot;&gt;</span><br><span class=\"line\">    &#123;props.children&#125;</span><br><span class=\"line\">  &lt;/button&gt;</span><br><span class=\"line\">));</span><br><span class=\"line\"></span><br><span class=\"line\">// You can now get a ref directly to the DOM button:</span><br><span class=\"line\">const ref = React.createRef();</span><br><span class=\"line\">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure></p>\n<p><code>React.forwardRef</code> 接受两个参数，第一个参数是 props ，第二个参数是 ref ，作为子组件引用的赋值对象。如果是普通的类组件和函数组件，不会接受 ref 作为参数，也不能在 props 中访问到。<br>文档接下来还举了一个在高阶组件中转发 ref 的例子，目前还没完全看懂。🧐</p>\n<h3 id=\"Fragments\"><a href=\"#Fragments\" class=\"headerlink\" title=\"Fragments\"></a>Fragments</h3><p><a href=\"https://reactjs.org/docs/fragments.html\" target=\"_blank\" rel=\"noopener\">link</a><br>当我们需要对一组子元素进行分组，又不希望添加额外的 DOM 节点时，可以使用 fragments ，有两种写法：<code>&lt;&gt;&lt;/&gt;</code> 和 <code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code> ，第二种写法可以添加 <code>key</code> 属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;React.Fragment&gt;</span><br><span class=\"line\">      &lt;ChildA /&gt;</span><br><span class=\"line\">      &lt;ChildB /&gt;</span><br><span class=\"line\">      &lt;ChildC /&gt;</span><br><span class=\"line\">    &lt;/React.Fragment&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// or</span><br><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;ChildA /&gt;</span><br><span class=\"line\">      &lt;ChildB /&gt;</span><br><span class=\"line\">      &lt;ChildC /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Higher-Order-Components\"><a href=\"#Higher-Order-Components\" class=\"headerlink\" title=\"Higher-Order Components\"></a>Higher-Order Components</h3><p><a href=\"https://reactjs.org/docs/higher-order-components.html\" target=\"_blank\" rel=\"noopener\">link</a><br>定义：高阶组件是一个接受组件作为参数，返回新组件的函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure></p>\n<p>既然是函数组件，那就应该是 pure fuction ，且不能有任何的副作用。它是通过将原始组件包裹在一个新的类组件，并返回这个类组件来实现功能的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This function takes a component...</span><br><span class=\"line\">function withSubscription(WrappedComponent, selectData) &#123;</span><br><span class=\"line\">  // ...and returns another component...</span><br><span class=\"line\">  return class extends React.Component &#123;</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.handleChange = this.handleChange.bind(this);</span><br><span class=\"line\">      this.state = &#123;</span><br><span class=\"line\">        data: selectData(DataSource, props)</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">      // ... that takes care of the subscription...</span><br><span class=\"line\">      DataSource.addChangeListener(this.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">      DataSource.removeChangeListener(this.handleChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handleChange() &#123;</span><br><span class=\"line\">      this.setState(&#123;</span><br><span class=\"line\">        data: selectData(DataSource, this.props)</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      // ... and renders the wrapped component with the fresh data!</span><br><span class=\"line\">      // Notice that we pass through any additional props</span><br><span class=\"line\">      return &lt;WrappedComponent data=&#123;this.state.data&#125; &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意区分 HOCs 和 container components 。HOCs 使用了 容器组件作为其实现的一部分。<br>此外，注意不能在 render 函数中使用 HOCs ，否则会导致每次 render 时整个子组件熟4都会卸载再装载，丢失状态。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  // A new version of EnhancedComponent is created on every render</span><br><span class=\"line\">  // EnhancedComponent1 !== EnhancedComponent2</span><br><span class=\"line\">  const EnhancedComponent = enhance(MyComponent);</span><br><span class=\"line\">  // That causes the entire subtree to unmount/remount each time!</span><br><span class=\"line\">  return &lt;EnhancedComponent /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"JSX-In-Depth\"><a href=\"#JSX-In-Depth\" class=\"headerlink\" title=\"JSX In Depth\"></a>JSX In Depth</h3><p><a href=\"https://reactjs.org/docs/jsx-in-depth.html\" target=\"_blank\" rel=\"noopener\">link</a><br>JSX 是 <code>React.createElement(component, props, ...children)</code> 的语法糖，编译示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt;</span><br><span class=\"line\">  Click Me</span><br><span class=\"line\">&lt;/MyButton&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// compiles into:</span><br><span class=\"line\">React.createElement(</span><br><span class=\"line\">  MyButton,</span><br><span class=\"line\">  &#123;color: &apos;blue&apos;, shadowSize: 2&#125;,</span><br><span class=\"line\">  &apos;Click Me&apos;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>若是 self-closing tag 如 <code>&lt;div/&gt;</code> ，第三个参数是 <code>null</code> 。注意组件的首字母一定要大写，否则会被当成普通的内置组件。<br>可以在 JSX 中使用点运算符引用 React 组件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const MyComponents = &#123;</span><br><span class=\"line\">  DatePicker: function DatePicker(props) &#123;</span><br><span class=\"line\">    return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// use dot-notation</span><br><span class=\"line\">function BlueDatePicker() &#123;</span><br><span class=\"line\">  return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但普通的表达式不能指示 React 元素类型，如果想要动态显示组件，需要先赋值给一个大写字母开头的变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const components = &#123;</span><br><span class=\"line\">  photo: PhotoStory,</span><br><span class=\"line\">  video: VideoStory</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function Story(props) &#123;</span><br><span class=\"line\">  // you can&apos;t write `return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;`</span><br><span class=\"line\">  // Correct! JSX type can be a capitalized variable.</span><br><span class=\"line\">  const SpecificStory = components[props.storyType];</span><br><span class=\"line\">  return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在同时包含开始标签和结束标签的JSX表达式中，tag 之间的内容作为特殊的 props：<code>props.children</code> 传递。<br>布尔值、null 和 undefined 会被 React 忽略，下述表达式渲染结果相同：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div /&gt;</span><br><span class=\"line\">&lt;div&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&#123;false&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&#123;null&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;div&gt;&#123;true&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"ML Resources Collection","catalog":true,"date":"2019-10-06T09:52:54.000Z","subtitle":null,"header-img":null,"mathjax":true,"_content":"\n## Tools\n\n1. Loss Landscape Visualization \nA tools for visualizing the Loss Landscape of Neural Nets.  \nNote: Support PyTorch 0.4 and 0.4+ is not evaluated.\nLink: [Github](https://github.com/tomgoldstein/loss-landscape)  \n2. Wasabi: A lightweight console printing and formatting toolkit\nNote: Work in progress but no updates since May 2019.\nLink: [Github](https://github.com/ines/wasabi)\n\n\n## Writing Guide\n1. [Research Proposal Guide](https://www.monash.edu/rlo/graduate-research-writing/write-the-thesis/writing-a-research-proposal)\n2. [How to write research paper](https://m.v.qq.com/play.html?&vid=k07751x7n6y&ptag=v_qq_com%23v.play.adaptor%233), 短短16分钟，针针见血，这个看了挺好的\n\n## Blog\n1. [Tim Dettmers](https://timdettmers.com/): UW 的ML PhD，写了些学术思考\n2. [Marvin Petersen\n](https://vinpetersen.github.io/): Dl入门的文章","source":"_posts/Resources.md","raw":"---\ntitle: ML Resources Collection\ncatalog: true\ndate: 2019-10-06 17:52:54\nsubtitle:\nheader-img:\nmathjax: true\ntags: ML\n---\n\n## Tools\n\n1. Loss Landscape Visualization \nA tools for visualizing the Loss Landscape of Neural Nets.  \nNote: Support PyTorch 0.4 and 0.4+ is not evaluated.\nLink: [Github](https://github.com/tomgoldstein/loss-landscape)  \n2. Wasabi: A lightweight console printing and formatting toolkit\nNote: Work in progress but no updates since May 2019.\nLink: [Github](https://github.com/ines/wasabi)\n\n\n## Writing Guide\n1. [Research Proposal Guide](https://www.monash.edu/rlo/graduate-research-writing/write-the-thesis/writing-a-research-proposal)\n2. [How to write research paper](https://m.v.qq.com/play.html?&vid=k07751x7n6y&ptag=v_qq_com%23v.play.adaptor%233), 短短16分钟，针针见血，这个看了挺好的\n\n## Blog\n1. [Tim Dettmers](https://timdettmers.com/): UW 的ML PhD，写了些学术思考\n2. [Marvin Petersen\n](https://vinpetersen.github.io/): Dl入门的文章","slug":"Resources","published":1,"updated":"2020-01-02T02:00:52.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7bsdjt6000ocsueqv17rczw","content":"<h2 id=\"tools\"><a href=\"#Tools\" class=\"headerlink\" title=\"Tools\"></a>Tools</h2><ol>\n<li>Loss Landscape Visualization<br>A tools for visualizing the Loss Landscape of Neural Nets.<br>Note: Support PyTorch 0.4 and 0.4+ is not evaluated.<br>Link: <a href=\"https://github.com/tomgoldstein/loss-landscape\" target=\"_blank\" rel=\"noopener\">Github</a>  </li>\n<li>Wasabi: A lightweight console printing and formatting toolkit<br>Note: Work in progress but no updates since May 2019.<br>Link: <a href=\"https://github.com/ines/wasabi\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n</ol>\n<h2 id=\"writing-guide\"><a href=\"#Writing-Guide\" class=\"headerlink\" title=\"Writing Guide\"></a>Writing Guide</h2><ol>\n<li><a href=\"https://www.monash.edu/rlo/graduate-research-writing/write-the-thesis/writing-a-research-proposal\" target=\"_blank\" rel=\"noopener\">Research Proposal Guide</a></li>\n<li><a href=\"https://m.v.qq.com/play.html?&amp;vid=k07751x7n6y&amp;ptag=v_qq_com%23v.play.adaptor%233\" target=\"_blank\" rel=\"noopener\">How to write research paper</a>, 短短16分钟，针针见血，这个看了挺好的</li>\n</ol>\n<h2 id=\"blog\"><a href=\"#Blog\" class=\"headerlink\" title=\"Blog\"></a>Blog</h2><ol>\n<li><a href=\"https://timdettmers.com/\" target=\"_blank\" rel=\"noopener\">Tim Dettmers</a>: UW 的ML PhD，写了些学术思考</li>\n<li><a href=\"https://vinpetersen.github.io/\" target=\"_blank\" rel=\"noopener\">Marvin Petersen\n</a>: Dl入门的文章</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Tools\"><a href=\"#Tools\" class=\"headerlink\" title=\"Tools\"></a>Tools</h2><ol>\n<li>Loss Landscape Visualization<br>A tools for visualizing the Loss Landscape of Neural Nets.<br>Note: Support PyTorch 0.4 and 0.4+ is not evaluated.<br>Link: <a href=\"https://github.com/tomgoldstein/loss-landscape\" target=\"_blank\" rel=\"noopener\">Github</a>  </li>\n<li>Wasabi: A lightweight console printing and formatting toolkit<br>Note: Work in progress but no updates since May 2019.<br>Link: <a href=\"https://github.com/ines/wasabi\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n</ol>\n<h2 id=\"Writing-Guide\"><a href=\"#Writing-Guide\" class=\"headerlink\" title=\"Writing Guide\"></a>Writing Guide</h2><ol>\n<li><a href=\"https://www.monash.edu/rlo/graduate-research-writing/write-the-thesis/writing-a-research-proposal\" target=\"_blank\" rel=\"noopener\">Research Proposal Guide</a></li>\n<li><a href=\"https://m.v.qq.com/play.html?&amp;vid=k07751x7n6y&amp;ptag=v_qq_com%23v.play.adaptor%233\" target=\"_blank\" rel=\"noopener\">How to write research paper</a>, 短短16分钟，针针见血，这个看了挺好的</li>\n</ol>\n<h2 id=\"Blog\"><a href=\"#Blog\" class=\"headerlink\" title=\"Blog\"></a>Blog</h2><ol>\n<li><a href=\"https://timdettmers.com/\" target=\"_blank\" rel=\"noopener\">Tim Dettmers</a>: UW 的ML PhD，写了些学术思考</li>\n<li><a href=\"https://vinpetersen.github.io/\" target=\"_blank\" rel=\"noopener\">Marvin Petersen\n</a>: Dl入门的文章</li>\n</ol>\n"},{"title":"gitlab runners 配置笔记","catalog":true,"date":"2020-02-27T14:46:42.000Z","subtitle":null,"header-img":null,"_content":"\nrunners 用于跑 `.gitlab-ci.yml` 代码，有 shared runners 、specific runners 、group runners 三种类型，关于这三种类型的区别可以查看官方文档这一[部分](https://docs.gitlab.com/ee/ci/runners/README.html)。\n之前想迁移文档到 gitlab pages 上时因为没有找到可用的 shared runners，决定在自己的 Linux 虚拟机上试着注册一个，文档上的[步骤](https://docs.gitlab.com/runner/register/)写得很详细，照着做就 OK 了。\n\n### Install the runner\n根据操作系统类型选择的是这个[链接](https://docs.gitlab.com/runner/install/linux-repository.html)。\n\n添加 gitlab 的官方仓库：\n```\n// add GitLab’s official repository\ncurl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash\n```\n\n安装最新版本的 gitlab runner ：\n```\n// install the latest version of GitLab Runner\nsudo apt-get install gitlab-runner\n```\n\n### Obtain a token\n在项目的 **Setting > CI/CD > Runners > Specific Runners** 找到 url 和 token，下一步注册时需要用到。\n\n### Register the runner\nLinux 上的注册方法见此[链接](https://docs.gitlab.com/runner/register/index.html)。\n\n开始注册：\n```\nsudo gitlab-runner register\n```\n\n输入第二步中的 url 和 token ：\n```\nPlease enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )\nhttps://gitlab.com\n\nPlease enter the gitlab-ci token for this runner\nxxx\n```\n\n简单描述一下该 runner 的信息：\n```\nPlease enter the gitlab-ci description for this runner\n[hostname] my-runner\n```\n\n定义 tags ，这个 tags 就是我们在 `.gitlab-ci.yml` 中为 jobs 指定的 tags ：\n```\nPlease enter the gitlab-ci tags for this runner (comma separated):\nmy-tag,another-tag\n```\n\n选择执行器，选择的是 docker 。注意电脑上必须先安装好 docker ：\n```\nPlease enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:\ndocker\n```\n\n为 docker 选择默认镜像，因为做的是 JS 项目，所以选择 node 镜像：\n```\nPlease enter the Docker image (eg. ruby:2.6):\nnode:11.7.0\n```\n\n### Start Runner\n注册完成后，就可以运行了：\n```\ngitlab-runner start\n```\n如果在 **Setting > CI/CD > Runners > Specific Runners** 看到 runner 实例并且显示 \"activated\" ，证明已经成功注册并启动了，接下来就可以开始愉快地跑 pipeline 了。\n\n更多命令介绍可以参考这个[链接](https://docs.gitlab.com/runner/commands/)。","source":"_posts/gitlab-runners-配置笔记.md","raw":"---\ntitle: gitlab runners 配置笔记\ncatalog: true\ndate: 2020-02-27 22:46:42\nsubtitle:\nheader-img:\ntags: FE\n---\n\nrunners 用于跑 `.gitlab-ci.yml` 代码，有 shared runners 、specific runners 、group runners 三种类型，关于这三种类型的区别可以查看官方文档这一[部分](https://docs.gitlab.com/ee/ci/runners/README.html)。\n之前想迁移文档到 gitlab pages 上时因为没有找到可用的 shared runners，决定在自己的 Linux 虚拟机上试着注册一个，文档上的[步骤](https://docs.gitlab.com/runner/register/)写得很详细，照着做就 OK 了。\n\n### Install the runner\n根据操作系统类型选择的是这个[链接](https://docs.gitlab.com/runner/install/linux-repository.html)。\n\n添加 gitlab 的官方仓库：\n```\n// add GitLab’s official repository\ncurl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash\n```\n\n安装最新版本的 gitlab runner ：\n```\n// install the latest version of GitLab Runner\nsudo apt-get install gitlab-runner\n```\n\n### Obtain a token\n在项目的 **Setting > CI/CD > Runners > Specific Runners** 找到 url 和 token，下一步注册时需要用到。\n\n### Register the runner\nLinux 上的注册方法见此[链接](https://docs.gitlab.com/runner/register/index.html)。\n\n开始注册：\n```\nsudo gitlab-runner register\n```\n\n输入第二步中的 url 和 token ：\n```\nPlease enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )\nhttps://gitlab.com\n\nPlease enter the gitlab-ci token for this runner\nxxx\n```\n\n简单描述一下该 runner 的信息：\n```\nPlease enter the gitlab-ci description for this runner\n[hostname] my-runner\n```\n\n定义 tags ，这个 tags 就是我们在 `.gitlab-ci.yml` 中为 jobs 指定的 tags ：\n```\nPlease enter the gitlab-ci tags for this runner (comma separated):\nmy-tag,another-tag\n```\n\n选择执行器，选择的是 docker 。注意电脑上必须先安装好 docker ：\n```\nPlease enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:\ndocker\n```\n\n为 docker 选择默认镜像，因为做的是 JS 项目，所以选择 node 镜像：\n```\nPlease enter the Docker image (eg. ruby:2.6):\nnode:11.7.0\n```\n\n### Start Runner\n注册完成后，就可以运行了：\n```\ngitlab-runner start\n```\n如果在 **Setting > CI/CD > Runners > Specific Runners** 看到 runner 实例并且显示 \"activated\" ，证明已经成功注册并启动了，接下来就可以开始愉快地跑 pipeline 了。\n\n更多命令介绍可以参考这个[链接](https://docs.gitlab.com/runner/commands/)。","slug":"gitlab-runners-配置笔记","published":1,"updated":"2020-02-27T15:24:45.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7bsdjt7000rcsue7jehi3vv","content":"<p>runners 用于跑 <code>.gitlab-ci.yml</code> 代码，有 shared runners 、specific runners 、group runners 三种类型，关于这三种类型的区别可以查看官方文档这一<a href=\"https://docs.gitlab.com/ee/ci/runners/README.html\" target=\"_blank\" rel=\"noopener\">部分</a>。<br>之前想迁移文档到 gitlab pages 上时因为没有找到可用的 shared runners，决定在自己的 Linux 虚拟机上试着注册一个，文档上的<a href=\"https://docs.gitlab.com/runner/register/\" target=\"_blank\" rel=\"noopener\">步骤</a>写得很详细，照着做就 OK 了。</p>\n<h3 id=\"install-the-runner\"><a href=\"#Install-the-runner\" class=\"headerlink\" title=\"Install the runner\"></a>Install the runner</h3><p>根据操作系统类型选择的是这个<a href=\"https://docs.gitlab.com/runner/install/linux-repository.html\" target=\"_blank\" rel=\"noopener\">链接</a>。</p>\n<p>添加 gitlab 的官方仓库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// add GitLab’s official repository</span><br><span class=\"line\">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure></p>\n<p>安装最新版本的 gitlab runner ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// install the latest version of GitLab Runner</span><br><span class=\"line\">sudo apt-get install gitlab-runner</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"obtain-a-token\"><a href=\"#Obtain-a-token\" class=\"headerlink\" title=\"Obtain a token\"></a>Obtain a token</h3><p>在项目的 <strong>Setting &gt; CI/CD &gt; Runners &gt; Specific Runners</strong> 找到 url 和 token，下一步注册时需要用到。</p>\n<h3 id=\"register-the-runner\"><a href=\"#Register-the-runner\" class=\"headerlink\" title=\"Register the runner\"></a>Register the runner</h3><p>Linux 上的注册方法见此<a href=\"https://docs.gitlab.com/runner/register/index.html\" target=\"_blank\" rel=\"noopener\">链接</a>。</p>\n<p>开始注册：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gitlab-runner register</span><br></pre></td></tr></table></figure></p>\n<p>输入第二步中的 url 和 token ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class=\"line\">https://gitlab.com</span><br><span class=\"line\"></span><br><span class=\"line\">Please enter the gitlab-ci token for this runner</span><br><span class=\"line\">xxx</span><br></pre></td></tr></table></figure></p>\n<p>简单描述一下该 runner 的信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please enter the gitlab-ci description for this runner</span><br><span class=\"line\">[hostname] my-runner</span><br></pre></td></tr></table></figure></p>\n<p>定义 tags ，这个 tags 就是我们在 <code>.gitlab-ci.yml</code> 中为 jobs 指定的 tags ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please enter the gitlab-ci tags for this runner (comma separated):</span><br><span class=\"line\">my-tag,another-tag</span><br></pre></td></tr></table></figure></p>\n<p>选择执行器，选择的是 docker 。注意电脑上必须先安装好 docker ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:</span><br><span class=\"line\">docker</span><br></pre></td></tr></table></figure></p>\n<p>为 docker 选择默认镜像，因为做的是 JS 项目，所以选择 node 镜像：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please enter the Docker image (eg. ruby:2.6):</span><br><span class=\"line\">node:11.7.0</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"start-runner\"><a href=\"#Start-Runner\" class=\"headerlink\" title=\"Start Runner\"></a>Start Runner</h3><p>注册完成后，就可以运行了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitlab-runner start</span><br></pre></td></tr></table></figure></p>\n<p>如果在 <strong>Setting &gt; CI/CD &gt; Runners &gt; Specific Runners</strong> 看到 runner 实例并且显示 “activated” ，证明已经成功注册并启动了，接下来就可以开始愉快地跑 pipeline 了。</p>\n<p>更多命令介绍可以参考这个<a href=\"https://docs.gitlab.com/runner/commands/\" target=\"_blank\" rel=\"noopener\">链接</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>runners 用于跑 <code>.gitlab-ci.yml</code> 代码，有 shared runners 、specific runners 、group runners 三种类型，关于这三种类型的区别可以查看官方文档这一<a href=\"https://docs.gitlab.com/ee/ci/runners/README.html\" target=\"_blank\" rel=\"noopener\">部分</a>。<br>之前想迁移文档到 gitlab pages 上时因为没有找到可用的 shared runners，决定在自己的 Linux 虚拟机上试着注册一个，文档上的<a href=\"https://docs.gitlab.com/runner/register/\" target=\"_blank\" rel=\"noopener\">步骤</a>写得很详细，照着做就 OK 了。</p>\n<h3 id=\"Install-the-runner\"><a href=\"#Install-the-runner\" class=\"headerlink\" title=\"Install the runner\"></a>Install the runner</h3><p>根据操作系统类型选择的是这个<a href=\"https://docs.gitlab.com/runner/install/linux-repository.html\" target=\"_blank\" rel=\"noopener\">链接</a>。</p>\n<p>添加 gitlab 的官方仓库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// add GitLab’s official repository</span><br><span class=\"line\">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure></p>\n<p>安装最新版本的 gitlab runner ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// install the latest version of GitLab Runner</span><br><span class=\"line\">sudo apt-get install gitlab-runner</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Obtain-a-token\"><a href=\"#Obtain-a-token\" class=\"headerlink\" title=\"Obtain a token\"></a>Obtain a token</h3><p>在项目的 <strong>Setting &gt; CI/CD &gt; Runners &gt; Specific Runners</strong> 找到 url 和 token，下一步注册时需要用到。</p>\n<h3 id=\"Register-the-runner\"><a href=\"#Register-the-runner\" class=\"headerlink\" title=\"Register the runner\"></a>Register the runner</h3><p>Linux 上的注册方法见此<a href=\"https://docs.gitlab.com/runner/register/index.html\" target=\"_blank\" rel=\"noopener\">链接</a>。</p>\n<p>开始注册：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gitlab-runner register</span><br></pre></td></tr></table></figure></p>\n<p>输入第二步中的 url 和 token ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class=\"line\">https://gitlab.com</span><br><span class=\"line\"></span><br><span class=\"line\">Please enter the gitlab-ci token for this runner</span><br><span class=\"line\">xxx</span><br></pre></td></tr></table></figure></p>\n<p>简单描述一下该 runner 的信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please enter the gitlab-ci description for this runner</span><br><span class=\"line\">[hostname] my-runner</span><br></pre></td></tr></table></figure></p>\n<p>定义 tags ，这个 tags 就是我们在 <code>.gitlab-ci.yml</code> 中为 jobs 指定的 tags ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please enter the gitlab-ci tags for this runner (comma separated):</span><br><span class=\"line\">my-tag,another-tag</span><br></pre></td></tr></table></figure></p>\n<p>选择执行器，选择的是 docker 。注意电脑上必须先安装好 docker ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:</span><br><span class=\"line\">docker</span><br></pre></td></tr></table></figure></p>\n<p>为 docker 选择默认镜像，因为做的是 JS 项目，所以选择 node 镜像：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please enter the Docker image (eg. ruby:2.6):</span><br><span class=\"line\">node:11.7.0</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Start-Runner\"><a href=\"#Start-Runner\" class=\"headerlink\" title=\"Start Runner\"></a>Start Runner</h3><p>注册完成后，就可以运行了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitlab-runner start</span><br></pre></td></tr></table></figure></p>\n<p>如果在 <strong>Setting &gt; CI/CD &gt; Runners &gt; Specific Runners</strong> 看到 runner 实例并且显示 “activated” ，证明已经成功注册并启动了，接下来就可以开始愉快地跑 pipeline 了。</p>\n<p>更多命令介绍可以参考这个<a href=\"https://docs.gitlab.com/runner/commands/\" target=\"_blank\" rel=\"noopener\">链接</a>。</p>\n"},{"title":"《你不知道的 JavaScript》（上卷）- 读书笔记","catalog":true,"date":"2020-01-16T03:47:52.000Z","subtitle":null,"header-img":null,"_content":"\n# DEPRECATED !!!\n⚠️⚠️⚠️\n不出意外的话本系列弃更了。\n阅读及笔记都在微信读书上完成了。\n\n## 第一章：作用域是什么\n### 1.1 编译原理\n1. 编译的三个步骤：分词/词法分析（Tokenizing/Lexing）；解析/语法分析（Parsing）；代码生成（AST->可执行代码）。\n简单而言，考虑语句 `var a = 2;` ，引擎有办法将该语句对应的 AST 转换为机器能理解的一组指令：创建一个叫做 a 的变量（分配内存等），并将一个值存储在 a 中。\n2. 尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。与大多数语言不同的是， JavaScript 的编译不是发生在构建之前的，而是通常发生在代码执行前的几微秒。\n\n### 1.2 理解作用域\n1. 理解三个概念：\n**引擎**：从头到尾负责整个 JavaScript 程序的编译及执行过程；\n**编译器**：负责语法分析及代码生成等；\n**作用域**：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，确定当前执行的代码对这些标识符的访问权限。\n2. `var a = 2;` 看起来是一句声明，但事实上引擎会当成两个完全不同的声明：一个由编译器在编译时处理，在当前作用域声明一个 a 变量；一个由引擎在运行时处理，在作用域中查找该变量，若找到，则对他进行赋值。","source":"_posts/《你不知道的-JavaScript》（上卷）-读书笔记.md","raw":"---\ntitle: 《你不知道的 JavaScript》（上卷）- 读书笔记\ncatalog: true\ndate: 2020-01-16 11:47:52\nsubtitle:\nheader-img:\ntags: [FE,YDKJS]\n---\n\n# DEPRECATED !!!\n⚠️⚠️⚠️\n不出意外的话本系列弃更了。\n阅读及笔记都在微信读书上完成了。\n\n## 第一章：作用域是什么\n### 1.1 编译原理\n1. 编译的三个步骤：分词/词法分析（Tokenizing/Lexing）；解析/语法分析（Parsing）；代码生成（AST->可执行代码）。\n简单而言，考虑语句 `var a = 2;` ，引擎有办法将该语句对应的 AST 转换为机器能理解的一组指令：创建一个叫做 a 的变量（分配内存等），并将一个值存储在 a 中。\n2. 尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。与大多数语言不同的是， JavaScript 的编译不是发生在构建之前的，而是通常发生在代码执行前的几微秒。\n\n### 1.2 理解作用域\n1. 理解三个概念：\n**引擎**：从头到尾负责整个 JavaScript 程序的编译及执行过程；\n**编译器**：负责语法分析及代码生成等；\n**作用域**：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，确定当前执行的代码对这些标识符的访问权限。\n2. `var a = 2;` 看起来是一句声明，但事实上引擎会当成两个完全不同的声明：一个由编译器在编译时处理，在当前作用域声明一个 a 变量；一个由引擎在运行时处理，在作用域中查找该变量，若找到，则对他进行赋值。","slug":"《你不知道的-JavaScript》（上卷）-读书笔记","published":1,"updated":"2020-02-24T06:50:24.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7bsdjt8000tcsue78f03yg1","content":"<h1 id=\"deprecated\"><a href=\"#DEPRECATED\" class=\"headerlink\" title=\"DEPRECATED !!!\"></a>DEPRECATED !!!</h1><p>⚠️⚠️⚠️<br>不出意外的话本系列弃更了。<br>阅读及笔记都在微信读书上完成了。</p>\n<h2 id=\"第一章作用域是什么\"><a href=\"#第一章：作用域是什么\" class=\"headerlink\" title=\"第一章：作用域是什么\"></a>第一章：作用域是什么</h2><h3 id=\"11-编译原理\"><a href=\"#1-1-编译原理\" class=\"headerlink\" title=\"1.1 编译原理\"></a>1.1 编译原理</h3><ol>\n<li>编译的三个步骤：分词/词法分析（Tokenizing/Lexing）；解析/语法分析（Parsing）；代码生成（AST-&gt;可执行代码）。<br>简单而言，考虑语句 <code>var a = 2;</code> ，引擎有办法将该语句对应的 AST 转换为机器能理解的一组指令：创建一个叫做 a 的变量（分配内存等），并将一个值存储在 a 中。</li>\n<li>尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。与大多数语言不同的是， JavaScript 的编译不是发生在构建之前的，而是通常发生在代码执行前的几微秒。</li>\n</ol>\n<h3 id=\"12-理解作用域\"><a href=\"#1-2-理解作用域\" class=\"headerlink\" title=\"1.2 理解作用域\"></a>1.2 理解作用域</h3><ol>\n<li>理解三个概念：<br><strong>引擎</strong>：从头到尾负责整个 JavaScript 程序的编译及执行过程；<br><strong>编译器</strong>：负责语法分析及代码生成等；<br><strong>作用域</strong>：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，确定当前执行的代码对这些标识符的访问权限。</li>\n<li><code>var a = 2;</code> 看起来是一句声明，但事实上引擎会当成两个完全不同的声明：一个由编译器在编译时处理，在当前作用域声明一个 a 变量；一个由引擎在运行时处理，在作用域中查找该变量，若找到，则对他进行赋值。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DEPRECATED\"><a href=\"#DEPRECATED\" class=\"headerlink\" title=\"DEPRECATED !!!\"></a>DEPRECATED !!!</h1><p>⚠️⚠️⚠️<br>不出意外的话本系列弃更了。<br>阅读及笔记都在微信读书上完成了。</p>\n<h2 id=\"第一章：作用域是什么\"><a href=\"#第一章：作用域是什么\" class=\"headerlink\" title=\"第一章：作用域是什么\"></a>第一章：作用域是什么</h2><h3 id=\"1-1-编译原理\"><a href=\"#1-1-编译原理\" class=\"headerlink\" title=\"1.1 编译原理\"></a>1.1 编译原理</h3><ol>\n<li>编译的三个步骤：分词/词法分析（Tokenizing/Lexing）；解析/语法分析（Parsing）；代码生成（AST-&gt;可执行代码）。<br>简单而言，考虑语句 <code>var a = 2;</code> ，引擎有办法将该语句对应的 AST 转换为机器能理解的一组指令：创建一个叫做 a 的变量（分配内存等），并将一个值存储在 a 中。</li>\n<li>尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。与大多数语言不同的是， JavaScript 的编译不是发生在构建之前的，而是通常发生在代码执行前的几微秒。</li>\n</ol>\n<h3 id=\"1-2-理解作用域\"><a href=\"#1-2-理解作用域\" class=\"headerlink\" title=\"1.2 理解作用域\"></a>1.2 理解作用域</h3><ol>\n<li>理解三个概念：<br><strong>引擎</strong>：从头到尾负责整个 JavaScript 程序的编译及执行过程；<br><strong>编译器</strong>：负责语法分析及代码生成等；<br><strong>作用域</strong>：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，确定当前执行的代码对这些标识符的访问权限。</li>\n<li><code>var a = 2;</code> 看起来是一句声明，但事实上引擎会当成两个完全不同的声明：一个由编译器在编译时处理，在当前作用域声明一个 a 变量；一个由引擎在运行时处理，在作用域中查找该变量，若找到，则对他进行赋值。</li>\n</ol>\n"},{"title":"FrontEnd Daily Learning [2020.03]","catalog":true,"date":"2020-03-03T08:48:47.000Z","subtitle":null,"header-img":null,"_content":"#### About\n\n📅 2020 年 3 月的零散学习记录。\n\n🤦‍♀️ 新的一月，新的打气。希望自己这个月能多记笔记。\n\n预告：上传下载\n正则专题\n\n#### 2020/03/20\nCSS 中换行属性：\n![image.png](https://i.loli.net/2020/03/20/FRoCfSyxQhAT9Ln.png)\n\n#### 2020/03/18\n今日阅读：[Center flex items with one at the end of the row](https://stackoverflow.com/questions/35250367/center-flex-items-with-one-at-the-end-of-the-row)\n在 flex 容器中，如果我们需要从左到右排列 items ，但最后一个 item 需要靠右（例如实现一个 Header ，avatar 需要靠右），可以在此 item 上加上 CSS 属性 `margin-left: auto` 。更详细的解释可以参考 StackOverflow 上这个[答案](https://stackoverflow.com/questions/32551291/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties/33856609#33856609) 。有关 flex 布局的属性介绍参考该[文档](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)。\n\n#### 2020/03/10\n[prettier](https://prettier.io/docs/en/) 可用于格式化特定文件格式的代码，可与很多 pre-commit 工具配合使用，在提交 commit 之前自动格式化你通过 `git add` 加入暂存区的代码。\n使用文档可参考[官方链接](https://prettier.io/docs/en/precommit.html)，实际项目中用得较多的是 `lint-staged` ，它可以和其他很多代码质量工具如 ESLint 、 Stylelint 等结合使用。需要的依赖是 `prettier` 、 `husky` 以及 `lint-staged` :\n```\n// yarn\nyarn add prettier husky lint-stage --dev\n\n// npm\nnpm install prettier husky lint-stage --save-dev\n```\n注意官网提供了以下命令用于直接配置 lint-staged ：`npx mrm lint-staged` 。但试验中发现不生效，参考该[答案](https://stackoverflow.com/questions/50048717/lint-staged-not-running-on-precommit/56212836#56212836)后发现该命令确实只在 package.json 中设置了 husky 和 lint-stage 配置，而没有将其作为依赖项添加或安装。为确保正确运行，还是直接安装比较省事。\n安装完所需依赖后，在 package.json 加入以下代码：\n```\n\"husky\": {\n  \"hooks\": {\n    \"pre-commit\": \"lint-staged\"\n  }\n},\n\"lint-staged\": {\n  \"src/**/*.{js,jsx,ts,tsx,json,css,less,md}\": [\n    \"prettier --write\",\n    \"git add\"\n  ]\n}\n```\n详细的配置说明可参考 [lint-staged 文档](https://github.com/okonet/lint-staged#configuration)。上述配置中，在 src 文件夹下的 js、jsx、ts、tsx、json、css、less、md 文件都会在提交前自动格式化。\n\n#### 2020/03/09\n[Yarn vs NPM](https://www.keycdn.com/blog/npm-vs-yarn)\nnpm 和 yarn 都是包管理工具，yarn 是 Facebook 研发的，意在解决 npm 一致性、安全性和速度方面的一些问题。两者只是安装的手段不同，内部依赖的 npm structure 是相同的。yarn 相比 npm 的优势在于：\n1. yarn.lock 文件可以保证每个设备上安装的包都是相同的\n2. npm 只能通过序列化的方式一个接一个地安装包，yarn 可以同时执行多个安装步骤，因此速度更快\n3. npm 会自动从依赖项运行代码并允许动态添加软件包，yarn 只能从 yarn.lock 或 package.json 文件安装，因此更安全；且其在安装前使用校验和，以确保每个包的完整性\n\n关于如何从 npm 迁移到 yarn ，以及一些常用命令的比对，可以参考[官方文档](https://classic.yarnpkg.com/en/docs/migrating-from-npm/)。常用的有：\n\n|NPM|Yarn|\n|---|---|\n|npm install | yarn add|\n|npm install [package] --save|yarn add [package]|\n|npm install [package] --save-dev|yarn add [package --dev]|\n|npm install [package] --global|yarn global add [package]|\n|npm uninstall [package]|yarn remove [package]|\n\n注：`--save-dev` 用于安装仅开发阶段所需的依赖，`--save` 用于安装应用运行所需的依赖。\n\n#### 2020/03/07\n一、TDZ: [What is the temporal dead zone?](https://stackoverflow.com/questions/33198849/what-is-the-temporal-dead-zone)\nES6 新增了 `const` 和 `let` 两个关键字。他们与 `var` 一样，声明都会被提升（hoisted）。但对于 `const` 和 `let` 而言，存在一个“暂时性死区”的概念：如果在声明之前访问一个 `var` 变量，会返回 `undefined` ，但访问 `let` 或 `const` 变量会返回 `ReferenceError` ：\n```\nconsole.log(aVar); // undefined\nconsole.log(aLet); // causes ReferenceError: aLet is not defined\nvar aVar = 1;\nlet aLet = 2;\n```\n只有声明了变量（不是赋值），TDZ 才会结束：\n```\n//console.log(aLet)  // would throw ReferenceError\n\nlet aLet;\nconsole.log(aLet); // undefined\naLet = 10;\nconsole.log(aLet); // 10\n```\n从上面的例子很容易陷入 “let 声明不会被提升” 的误区，实际上通过下面这个例子就可以证明声明会被提升：\n```\nlet x = 'outer value';\n(function() {\n  // start TDZ for x\n  console.log(x);\n  let x = 'inner value'; // declaration ends TDZ for x\n}());\n```\n上面例子输出 `ReferenceError`，如果声明没有提升，会输出 \"outer value\" 。\n\n二、[What is Waiting (TTFB) in DevTools, and what to do about it](https://scaleyourcode.com/blog/article/27)\n\n#### 2020/03/06\n考虑如下树形数据结构：\n```\n// interface TreeData\n{\n  value: \"\",\n  children: [\n    {\n      value: \"\",\n      children: [\n        {value:\"\",children:[{value:\"\"}]},\n        {value:\"\"}\n      ]\n    }\n  ]\n}\n```\n当我们有一组 children 标签和一个节点的 value 值，想要得到该节点在树形结构中的详细信息，可以使用递归遍历：\n```\nexport function getLabelDetail(value: string, labels: TreeData[]) {\n  const checkIfHitNode = (value: string, node: TreeData) => {\n    if (node.value === value) {\n      return node;\n    } else if (node.children) {\n      for (let i = 0; i < node.children.length; i++) {\n        const result = checkIfHitNode(value, node.children[i]);\n        if (result) {\n          return result;\n        }\n      }\n    } else {\n      return null;\n    }\n  };\n\n  for (let i = 0; i < labels.length; i++) {\n    const hit = checkIfHitNode(value, labels[i]);\n    if (hit) {\n      return hit;\n    }\n  }\n}\n```\n注意 `checkIfHitNode()` 函数的输入值是 value 以及一个根节点，我们从根节点出发，依次检查 `children` 中是否包含要寻找的节点。\n\n#### 2020/03/05\n`URL()` 函数用于构造 URL，参考 [mdn](https://developer.mozilla.org/en-US/docs/Web/API/URL)，内置多种静态属性，常用属性的输出值如下：\n示例：`https://domain.cc:80/article?page=1`\n\n|properties|meaning|output|\n|---|---|---|\n|href|完整 URL|`https://domain.cc:80/article?page=1`|\n|origin|URL 协议、域名及端口号|`https://domain.cc:80`|\n|protocol|URL 协议|`https:`|\n|host|URL 域名及端口号|`domain.cc:80`|\n|hostname|URL 域名|`domain.cc`|\n|port|URL 端口号|`80`|\n|pathname| \"/\" 后的文件路径|`/article`|\n|search|URL 请求参数|`?page=1`|\n|hash|\"#\" 后的内容||\n\n在 URL 对象上调用 `toString()` 方法，返回 `url.href` :\n```\nconst url = new URL(\"http://......\")\nurl.toString() // a synonym for URL.href\n```\n\n#### 2020/03/04\nBroadcastChannel（[mdn](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel)）提供了在同源的不同的 windows，tabs，frames，iframes 之间通信的方法。通过触发一个 message 事件，消息可以广播到所有监听了该频道的 BroadcastChannel 对象。\n实际应用中，我们可以用于检测用户是否打开了多个窗口。在 window 中注册一个 BroadcastChannel 对象，监听 `load` 和 `hashchange` 事件，广播当前页面的 url ，并监听 message 事件。这样当打开第二个页面时，第一个页面就会接收到其发送的消息，提示用户执行相关操作。代码如下：\n```\nif (\n  process.env.NODE_ENV === \"production\" &&\n  typeof BroadcastChannel !== \"undefined\"\n) {\n  function warn() {\n    Modal.warn({\n      title: \"Warning!\",\n      content: <p>\"该页面已在另一窗口打开，同时打开两个窗口可能导致数据无法提交。\"</p>,\n      width: 600\n    });\n  }\n  const bc = new BroadcastChannel(\"page\");\n  bc.onmessage = ev => {\n    if (ev.data.url === window.location.href) {\n      warn();\n    }\n  };\n  window.addEventListener(\"load\", () => {\n    bc.postMessage({\n      url: window.location.href\n    });\n  });\n\n  window.addEventListener(\"hashchange\", function(event) {\n    bc.postMessage({\n      url: window.location.href\n    });\n  });\n}\n```\n\n#### 2020/03/03\n如果我们希望升级应用时，前端页面也可以感知到并收到提示，可以每隔一定时间请求 currentScript（返回当前正在执行的 `<script>` 元素，[mdn](https://developer.mozilla.org/en-US/docs/Web/API/Document/currentScript)），由于升级时文件的 hash 会发生变动，当返回 404 时，即可提示用户刷新页面。\n注意：请求时加上时间戳，保证了不会取到浏览器的 cache 。\n```\nconst selfUrl = (document.currentScript as HTMLScriptElement).src;\nconst it = setInterval(() => {\n  axios[process.env.NODE_ENV === \"development\" ? \"get\" : \"head\"](selfUrl, {\n    params: { t: Date.now() }\n  }).catch(err => {\n    if (err.response && err.response.status === 404) {\n      clearInterval(it);\n      Modal.confirm({\n        title: \"系统升级，是否刷新页面？\",\n        onOk() {\n          window.location.reload();\n        }\n      });\n    }\n  });\n}, 60000);\n```\n关于 `document.currentScript`，注意如果当前正在执行的代码是处在某个回调函数或者事件处理函数中的，那么 currentScript 属性不会指向包含那个函数的 `<script>` 元素,而是会返回 `null` 。\n","source":"_posts/FrontEnd-Daily-Learning-2020-03.md","raw":"---\ntitle: 'FrontEnd Daily Learning [2020.03]'\ncatalog: true\ndate: 2020-03-03 16:48:47\nsubtitle:\nheader-img:\ntags: FE\n---\n#### About\n\n📅 2020 年 3 月的零散学习记录。\n\n🤦‍♀️ 新的一月，新的打气。希望自己这个月能多记笔记。\n\n预告：上传下载\n正则专题\n\n#### 2020/03/20\nCSS 中换行属性：\n![image.png](https://i.loli.net/2020/03/20/FRoCfSyxQhAT9Ln.png)\n\n#### 2020/03/18\n今日阅读：[Center flex items with one at the end of the row](https://stackoverflow.com/questions/35250367/center-flex-items-with-one-at-the-end-of-the-row)\n在 flex 容器中，如果我们需要从左到右排列 items ，但最后一个 item 需要靠右（例如实现一个 Header ，avatar 需要靠右），可以在此 item 上加上 CSS 属性 `margin-left: auto` 。更详细的解释可以参考 StackOverflow 上这个[答案](https://stackoverflow.com/questions/32551291/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties/33856609#33856609) 。有关 flex 布局的属性介绍参考该[文档](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)。\n\n#### 2020/03/10\n[prettier](https://prettier.io/docs/en/) 可用于格式化特定文件格式的代码，可与很多 pre-commit 工具配合使用，在提交 commit 之前自动格式化你通过 `git add` 加入暂存区的代码。\n使用文档可参考[官方链接](https://prettier.io/docs/en/precommit.html)，实际项目中用得较多的是 `lint-staged` ，它可以和其他很多代码质量工具如 ESLint 、 Stylelint 等结合使用。需要的依赖是 `prettier` 、 `husky` 以及 `lint-staged` :\n```\n// yarn\nyarn add prettier husky lint-stage --dev\n\n// npm\nnpm install prettier husky lint-stage --save-dev\n```\n注意官网提供了以下命令用于直接配置 lint-staged ：`npx mrm lint-staged` 。但试验中发现不生效，参考该[答案](https://stackoverflow.com/questions/50048717/lint-staged-not-running-on-precommit/56212836#56212836)后发现该命令确实只在 package.json 中设置了 husky 和 lint-stage 配置，而没有将其作为依赖项添加或安装。为确保正确运行，还是直接安装比较省事。\n安装完所需依赖后，在 package.json 加入以下代码：\n```\n\"husky\": {\n  \"hooks\": {\n    \"pre-commit\": \"lint-staged\"\n  }\n},\n\"lint-staged\": {\n  \"src/**/*.{js,jsx,ts,tsx,json,css,less,md}\": [\n    \"prettier --write\",\n    \"git add\"\n  ]\n}\n```\n详细的配置说明可参考 [lint-staged 文档](https://github.com/okonet/lint-staged#configuration)。上述配置中，在 src 文件夹下的 js、jsx、ts、tsx、json、css、less、md 文件都会在提交前自动格式化。\n\n#### 2020/03/09\n[Yarn vs NPM](https://www.keycdn.com/blog/npm-vs-yarn)\nnpm 和 yarn 都是包管理工具，yarn 是 Facebook 研发的，意在解决 npm 一致性、安全性和速度方面的一些问题。两者只是安装的手段不同，内部依赖的 npm structure 是相同的。yarn 相比 npm 的优势在于：\n1. yarn.lock 文件可以保证每个设备上安装的包都是相同的\n2. npm 只能通过序列化的方式一个接一个地安装包，yarn 可以同时执行多个安装步骤，因此速度更快\n3. npm 会自动从依赖项运行代码并允许动态添加软件包，yarn 只能从 yarn.lock 或 package.json 文件安装，因此更安全；且其在安装前使用校验和，以确保每个包的完整性\n\n关于如何从 npm 迁移到 yarn ，以及一些常用命令的比对，可以参考[官方文档](https://classic.yarnpkg.com/en/docs/migrating-from-npm/)。常用的有：\n\n|NPM|Yarn|\n|---|---|\n|npm install | yarn add|\n|npm install [package] --save|yarn add [package]|\n|npm install [package] --save-dev|yarn add [package --dev]|\n|npm install [package] --global|yarn global add [package]|\n|npm uninstall [package]|yarn remove [package]|\n\n注：`--save-dev` 用于安装仅开发阶段所需的依赖，`--save` 用于安装应用运行所需的依赖。\n\n#### 2020/03/07\n一、TDZ: [What is the temporal dead zone?](https://stackoverflow.com/questions/33198849/what-is-the-temporal-dead-zone)\nES6 新增了 `const` 和 `let` 两个关键字。他们与 `var` 一样，声明都会被提升（hoisted）。但对于 `const` 和 `let` 而言，存在一个“暂时性死区”的概念：如果在声明之前访问一个 `var` 变量，会返回 `undefined` ，但访问 `let` 或 `const` 变量会返回 `ReferenceError` ：\n```\nconsole.log(aVar); // undefined\nconsole.log(aLet); // causes ReferenceError: aLet is not defined\nvar aVar = 1;\nlet aLet = 2;\n```\n只有声明了变量（不是赋值），TDZ 才会结束：\n```\n//console.log(aLet)  // would throw ReferenceError\n\nlet aLet;\nconsole.log(aLet); // undefined\naLet = 10;\nconsole.log(aLet); // 10\n```\n从上面的例子很容易陷入 “let 声明不会被提升” 的误区，实际上通过下面这个例子就可以证明声明会被提升：\n```\nlet x = 'outer value';\n(function() {\n  // start TDZ for x\n  console.log(x);\n  let x = 'inner value'; // declaration ends TDZ for x\n}());\n```\n上面例子输出 `ReferenceError`，如果声明没有提升，会输出 \"outer value\" 。\n\n二、[What is Waiting (TTFB) in DevTools, and what to do about it](https://scaleyourcode.com/blog/article/27)\n\n#### 2020/03/06\n考虑如下树形数据结构：\n```\n// interface TreeData\n{\n  value: \"\",\n  children: [\n    {\n      value: \"\",\n      children: [\n        {value:\"\",children:[{value:\"\"}]},\n        {value:\"\"}\n      ]\n    }\n  ]\n}\n```\n当我们有一组 children 标签和一个节点的 value 值，想要得到该节点在树形结构中的详细信息，可以使用递归遍历：\n```\nexport function getLabelDetail(value: string, labels: TreeData[]) {\n  const checkIfHitNode = (value: string, node: TreeData) => {\n    if (node.value === value) {\n      return node;\n    } else if (node.children) {\n      for (let i = 0; i < node.children.length; i++) {\n        const result = checkIfHitNode(value, node.children[i]);\n        if (result) {\n          return result;\n        }\n      }\n    } else {\n      return null;\n    }\n  };\n\n  for (let i = 0; i < labels.length; i++) {\n    const hit = checkIfHitNode(value, labels[i]);\n    if (hit) {\n      return hit;\n    }\n  }\n}\n```\n注意 `checkIfHitNode()` 函数的输入值是 value 以及一个根节点，我们从根节点出发，依次检查 `children` 中是否包含要寻找的节点。\n\n#### 2020/03/05\n`URL()` 函数用于构造 URL，参考 [mdn](https://developer.mozilla.org/en-US/docs/Web/API/URL)，内置多种静态属性，常用属性的输出值如下：\n示例：`https://domain.cc:80/article?page=1`\n\n|properties|meaning|output|\n|---|---|---|\n|href|完整 URL|`https://domain.cc:80/article?page=1`|\n|origin|URL 协议、域名及端口号|`https://domain.cc:80`|\n|protocol|URL 协议|`https:`|\n|host|URL 域名及端口号|`domain.cc:80`|\n|hostname|URL 域名|`domain.cc`|\n|port|URL 端口号|`80`|\n|pathname| \"/\" 后的文件路径|`/article`|\n|search|URL 请求参数|`?page=1`|\n|hash|\"#\" 后的内容||\n\n在 URL 对象上调用 `toString()` 方法，返回 `url.href` :\n```\nconst url = new URL(\"http://......\")\nurl.toString() // a synonym for URL.href\n```\n\n#### 2020/03/04\nBroadcastChannel（[mdn](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel)）提供了在同源的不同的 windows，tabs，frames，iframes 之间通信的方法。通过触发一个 message 事件，消息可以广播到所有监听了该频道的 BroadcastChannel 对象。\n实际应用中，我们可以用于检测用户是否打开了多个窗口。在 window 中注册一个 BroadcastChannel 对象，监听 `load` 和 `hashchange` 事件，广播当前页面的 url ，并监听 message 事件。这样当打开第二个页面时，第一个页面就会接收到其发送的消息，提示用户执行相关操作。代码如下：\n```\nif (\n  process.env.NODE_ENV === \"production\" &&\n  typeof BroadcastChannel !== \"undefined\"\n) {\n  function warn() {\n    Modal.warn({\n      title: \"Warning!\",\n      content: <p>\"该页面已在另一窗口打开，同时打开两个窗口可能导致数据无法提交。\"</p>,\n      width: 600\n    });\n  }\n  const bc = new BroadcastChannel(\"page\");\n  bc.onmessage = ev => {\n    if (ev.data.url === window.location.href) {\n      warn();\n    }\n  };\n  window.addEventListener(\"load\", () => {\n    bc.postMessage({\n      url: window.location.href\n    });\n  });\n\n  window.addEventListener(\"hashchange\", function(event) {\n    bc.postMessage({\n      url: window.location.href\n    });\n  });\n}\n```\n\n#### 2020/03/03\n如果我们希望升级应用时，前端页面也可以感知到并收到提示，可以每隔一定时间请求 currentScript（返回当前正在执行的 `<script>` 元素，[mdn](https://developer.mozilla.org/en-US/docs/Web/API/Document/currentScript)），由于升级时文件的 hash 会发生变动，当返回 404 时，即可提示用户刷新页面。\n注意：请求时加上时间戳，保证了不会取到浏览器的 cache 。\n```\nconst selfUrl = (document.currentScript as HTMLScriptElement).src;\nconst it = setInterval(() => {\n  axios[process.env.NODE_ENV === \"development\" ? \"get\" : \"head\"](selfUrl, {\n    params: { t: Date.now() }\n  }).catch(err => {\n    if (err.response && err.response.status === 404) {\n      clearInterval(it);\n      Modal.confirm({\n        title: \"系统升级，是否刷新页面？\",\n        onOk() {\n          window.location.reload();\n        }\n      });\n    }\n  });\n}, 60000);\n```\n关于 `document.currentScript`，注意如果当前正在执行的代码是处在某个回调函数或者事件处理函数中的，那么 currentScript 属性不会指向包含那个函数的 `<script>` 元素,而是会返回 `null` 。\n","slug":"FrontEnd-Daily-Learning-2020-03","published":1,"updated":"2020-03-20T06:10:01.626Z","_id":"ck7ef1vgj0000qsuep0ntbnn9","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"about\">About</h4>\n<p>📅 2020 年 3 月的零散学习记录。</p>\n<p>🤦‍♀️ 新的一月，新的打气。希望自己这个月能多记笔记。</p>\n<p>预告：上传下载<br>\n正则专题</p>\n<h4 id=\"20200320\">2020/03/20</h4>\n<p>CSS 中换行属性：<br>\n<img src=\"https://i.loli.net/2020/03/20/FRoCfSyxQhAT9Ln.png\" alt=\"image.png\"></p>\n<h4 id=\"20200318\">2020/03/18</h4>\n<p>今日阅读：<a href=\"https://stackoverflow.com/questions/35250367/center-flex-items-with-one-at-the-end-of-the-row\" target=\"_blank\" rel=\"noopener\">Center flex items with one at the end of the row</a><br>\n在 flex 容器中，如果我们需要从左到右排列 items ，但最后一个 item 需要靠右（例如实现一个 Header ，avatar 需要靠右），可以在此 item 上加上 CSS 属性 <code>margin-left: auto</code> 。更详细的解释可以参考 StackOverflow 上这个<a href=\"https://stackoverflow.com/questions/32551291/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties/33856609#33856609\" target=\"_blank\" rel=\"noopener\">答案</a> 。有关 flex 布局的属性介绍参考该<a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h4 id=\"20200310\">2020/03/10</h4>\n<p><a href=\"https://prettier.io/docs/en/\" target=\"_blank\" rel=\"noopener\">prettier</a> 可用于格式化特定文件格式的代码，可与很多 pre-commit 工具配合使用，在提交 commit 之前自动格式化你通过 <code>git add</code> 加入暂存区的代码。<br>\n使用文档可参考<a href=\"https://prettier.io/docs/en/precommit.html\" target=\"_blank\" rel=\"noopener\">官方链接</a>，实际项目中用得较多的是 <code>lint-staged</code> ，它可以和其他很多代码质量工具如 ESLint 、 Stylelint 等结合使用。需要的依赖是 <code>prettier</code> 、 <code>husky</code> 以及 <code>lint-staged</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// yarn</span><br><span class=\"line\">yarn add prettier husky lint-stage --dev</span><br><span class=\"line\"></span><br><span class=\"line\">// npm</span><br><span class=\"line\">npm install prettier husky lint-stage --save-dev</span><br></pre></td></tr></table></figure>\n<p>注意官网提供了以下命令用于直接配置 lint-staged ：<code>npx mrm lint-staged</code> 。但试验中发现不生效，参考该<a href=\"https://stackoverflow.com/questions/50048717/lint-staged-not-running-on-precommit/56212836#56212836\" target=\"_blank\" rel=\"noopener\">答案</a>后发现该命令确实只在 package.json 中设置了 husky 和 lint-stage 配置，而没有将其作为依赖项添加或安装。为确保正确运行，还是直接安装比较省事。<br>\n安装完所需依赖后，在 package.json 加入以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">  &quot;hooks&quot;: &#123;</span><br><span class=\"line\">    &quot;pre-commit&quot;: &quot;lint-staged&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">  &quot;src/**/*.&#123;js,jsx,ts,tsx,json,css,less,md&#125;&quot;: [</span><br><span class=\"line\">    &quot;prettier --write&quot;,</span><br><span class=\"line\">    &quot;git add&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>详细的配置说明可参考 <a href=\"https://github.com/okonet/lint-staged#configuration\" target=\"_blank\" rel=\"noopener\">lint-staged 文档</a>。上述配置中，在 src 文件夹下的 js、jsx、ts、tsx、json、css、less、md 文件都会在提交前自动格式化。</p>\n<h4 id=\"20200309\">2020/03/09</h4>\n<p><a href=\"https://www.keycdn.com/blog/npm-vs-yarn\" target=\"_blank\" rel=\"noopener\">Yarn vs NPM</a><br>\nnpm 和 yarn 都是包管理工具，yarn 是 Facebook 研发的，意在解决 npm 一致性、安全性和速度方面的一些问题。两者只是安装的手段不同，内部依赖的 npm structure 是相同的。yarn 相比 npm 的优势在于：</p>\n<ol>\n<li>yarn.lock 文件可以保证每个设备上安装的包都是相同的</li>\n<li>npm 只能通过序列化的方式一个接一个地安装包，yarn 可以同时执行多个安装步骤，因此速度更快</li>\n<li>npm 会自动从依赖项运行代码并允许动态添加软件包，yarn 只能从 yarn.lock 或 package.json 文件安装，因此更安全；且其在安装前使用校验和，以确保每个包的完整性</li>\n</ol>\n<p>关于如何从 npm 迁移到 yarn ，以及一些常用命令的比对，可以参考<a href=\"https://classic.yarnpkg.com/en/docs/migrating-from-npm/\" target=\"_blank\" rel=\"noopener\">官方文档</a>。常用的有：</p>\n<table>\n<thead>\n<tr>\n<th>NPM</th>\n<th>Yarn</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install</td>\n<td>yarn add</td>\n</tr>\n<tr>\n<td>npm install [package] --save</td>\n<td>yarn add [package]</td>\n</tr>\n<tr>\n<td>npm install [package] --save-dev</td>\n<td>yarn add [package --dev]</td>\n</tr>\n<tr>\n<td>npm install [package] --global</td>\n<td>yarn global add [package]</td>\n</tr>\n<tr>\n<td>npm uninstall [package]</td>\n<td>yarn remove [package]</td>\n</tr>\n</tbody>\n</table>\n<p>注：<code>--save-dev</code> 用于安装仅开发阶段所需的依赖，<code>--save</code> 用于安装应用运行所需的依赖。</p>\n<h4 id=\"20200307\">2020/03/07</h4>\n<p>一、TDZ: <a href=\"https://stackoverflow.com/questions/33198849/what-is-the-temporal-dead-zone\" target=\"_blank\" rel=\"noopener\">What is the temporal dead zone?</a><br>\nES6 新增了 <code>const</code> 和 <code>let</code> 两个关键字。他们与 <code>var</code> 一样，声明都会被提升（hoisted）。但对于 <code>const</code> 和 <code>let</code> 而言，存在一个“暂时性死区”的概念：如果在声明之前访问一个 <code>var</code> 变量，会返回 <code>undefined</code> ，但访问 <code>let</code> 或 <code>const</code> 变量会返回 <code>ReferenceError</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(aVar); // undefined</span><br><span class=\"line\">console.log(aLet); // causes ReferenceError: aLet is not defined</span><br><span class=\"line\">var aVar = 1;</span><br><span class=\"line\">let aLet = 2;</span><br></pre></td></tr></table></figure>\n<p>只有声明了变量（不是赋值），TDZ 才会结束：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//console.log(aLet)  // would throw ReferenceError</span><br><span class=\"line\"></span><br><span class=\"line\">let aLet;</span><br><span class=\"line\">console.log(aLet); // undefined</span><br><span class=\"line\">aLet = 10;</span><br><span class=\"line\">console.log(aLet); // 10</span><br></pre></td></tr></table></figure>\n<p>从上面的例子很容易陷入 “let 声明不会被提升” 的误区，实际上通过下面这个例子就可以证明声明会被提升：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x = &apos;outer value&apos;;</span><br><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  // start TDZ for x</span><br><span class=\"line\">  console.log(x);</span><br><span class=\"line\">  let x = &apos;inner value&apos;; // declaration ends TDZ for x</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>上面例子输出 <code>ReferenceError</code>，如果声明没有提升，会输出 “outer value” 。</p>\n<p>二、<a href=\"https://scaleyourcode.com/blog/article/27\" target=\"_blank\" rel=\"noopener\">What is Waiting (TTFB) in DevTools, and what to do about it</a></p>\n<h4 id=\"20200306\">2020/03/06</h4>\n<p>考虑如下树形数据结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// interface TreeData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  value: &quot;&quot;,</span><br><span class=\"line\">  children: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: &quot;&quot;,</span><br><span class=\"line\">      children: [</span><br><span class=\"line\">        &#123;value:&quot;&quot;,children:[&#123;value:&quot;&quot;&#125;]&#125;,</span><br><span class=\"line\">        &#123;value:&quot;&quot;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们有一组 children 标签和一个节点的 value 值，想要得到该节点在树形结构中的详细信息，可以使用递归遍历：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function getLabelDetail(value: string, labels: TreeData[]) &#123;</span><br><span class=\"line\">  const checkIfHitNode = (value: string, node: TreeData) =&gt; &#123;</span><br><span class=\"line\">    if (node.value === value) &#123;</span><br><span class=\"line\">      return node;</span><br><span class=\"line\">    &#125; else if (node.children) &#123;</span><br><span class=\"line\">      for (let i = 0; i &lt; node.children.length; i++) &#123;</span><br><span class=\"line\">        const result = checkIfHitNode(value, node.children[i]);</span><br><span class=\"line\">        if (result) &#123;</span><br><span class=\"line\">          return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (let i = 0; i &lt; labels.length; i++) &#123;</span><br><span class=\"line\">    const hit = checkIfHitNode(value, labels[i]);</span><br><span class=\"line\">    if (hit) &#123;</span><br><span class=\"line\">      return hit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意 <code>checkIfHitNode()</code> 函数的输入值是 value 以及一个根节点，我们从根节点出发，依次检查 <code>children</code> 中是否包含要寻找的节点。</p>\n<h4 id=\"20200305\">2020/03/05</h4>\n<p><code>URL()</code> 函数用于构造 URL，参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL\" target=\"_blank\" rel=\"noopener\">mdn</a>，内置多种静态属性，常用属性的输出值如下：<br>\n示例：<code>https://domain.cc:80/article?page=1</code></p>\n<table>\n<thead>\n<tr>\n<th>properties</th>\n<th>meaning</th>\n<th>output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>href</td>\n<td>完整 URL</td>\n<td><code>https://domain.cc:80/article?page=1</code></td>\n</tr>\n<tr>\n<td>origin</td>\n<td>URL 协议、域名及端口号</td>\n<td><code>https://domain.cc:80</code></td>\n</tr>\n<tr>\n<td>protocol</td>\n<td>URL 协议</td>\n<td><code>https:</code></td>\n</tr>\n<tr>\n<td>host</td>\n<td>URL 域名及端口号</td>\n<td><code>domain.cc:80</code></td>\n</tr>\n<tr>\n<td>hostname</td>\n<td>URL 域名</td>\n<td><code>domain.cc</code></td>\n</tr>\n<tr>\n<td>port</td>\n<td>URL 端口号</td>\n<td><code>80</code></td>\n</tr>\n<tr>\n<td>pathname</td>\n<td>“/” 后的文件路径</td>\n<td><code>/article</code></td>\n</tr>\n<tr>\n<td>search</td>\n<td>URL 请求参数</td>\n<td><code>?page=1</code></td>\n</tr>\n<tr>\n<td>hash</td>\n<td>“#” 后的内容</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>在 URL 对象上调用 <code>toString()</code> 方法，返回 <code>url.href</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const url = new URL(&quot;http://......&quot;)</span><br><span class=\"line\">url.toString() // a synonym for URL.href</span><br></pre></td></tr></table></figure>\n<h4 id=\"20200304\">2020/03/04</h4>\n<p>BroadcastChannel（<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel\" target=\"_blank\" rel=\"noopener\">mdn</a>）提供了在同源的不同的 windows，tabs，frames，iframes 之间通信的方法。通过触发一个 message 事件，消息可以广播到所有监听了该频道的 BroadcastChannel 对象。<br>\n实际应用中，我们可以用于检测用户是否打开了多个窗口。在 window 中注册一个 BroadcastChannel 对象，监听 <code>load</code> 和 <code>hashchange</code> 事件，广播当前页面的 url ，并监听 message 事件。这样当打开第二个页面时，第一个页面就会接收到其发送的消息，提示用户执行相关操作。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (</span><br><span class=\"line\">  process.env.NODE_ENV === &quot;production&quot; &amp;&amp;</span><br><span class=\"line\">  typeof BroadcastChannel !== &quot;undefined&quot;</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  function warn() &#123;</span><br><span class=\"line\">    Modal.warn(&#123;</span><br><span class=\"line\">      title: &quot;Warning!&quot;,</span><br><span class=\"line\">      content: &lt;p&gt;&quot;该页面已在另一窗口打开，同时打开两个窗口可能导致数据无法提交。&quot;&lt;/p&gt;,</span><br><span class=\"line\">      width: 600</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const bc = new BroadcastChannel(&quot;page&quot;);</span><br><span class=\"line\">  bc.onmessage = ev =&gt; &#123;</span><br><span class=\"line\">    if (ev.data.url === window.location.href) &#123;</span><br><span class=\"line\">      warn();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  window.addEventListener(&quot;load&quot;, () =&gt; &#123;</span><br><span class=\"line\">    bc.postMessage(&#123;</span><br><span class=\"line\">      url: window.location.href</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  window.addEventListener(&quot;hashchange&quot;, function(event) &#123;</span><br><span class=\"line\">    bc.postMessage(&#123;</span><br><span class=\"line\">      url: window.location.href</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"20200303\">2020/03/03</h4>\n<p>如果我们希望升级应用时，前端页面也可以感知到并收到提示，可以每隔一定时间请求 currentScript（返回当前正在执行的 <code>&lt;script&gt;</code> 元素，<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/currentScript\" target=\"_blank\" rel=\"noopener\">mdn</a>），由于升级时文件的 hash 会发生变动，当返回 404 时，即可提示用户刷新页面。<br>\n注意：请求时加上时间戳，保证了不会取到浏览器的 cache 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const selfUrl = (document.currentScript as HTMLScriptElement).src;</span><br><span class=\"line\">const it = setInterval(() =&gt; &#123;</span><br><span class=\"line\">  axios[process.env.NODE_ENV === &quot;development&quot; ? &quot;get&quot; : &quot;head&quot;](selfUrl, &#123;</span><br><span class=\"line\">    params: &#123; t: Date.now() &#125;</span><br><span class=\"line\">  &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">    if (err.response &amp;&amp; err.response.status === 404) &#123;</span><br><span class=\"line\">      clearInterval(it);</span><br><span class=\"line\">      Modal.confirm(&#123;</span><br><span class=\"line\">        title: &quot;系统升级，是否刷新页面？&quot;,</span><br><span class=\"line\">        onOk() &#123;</span><br><span class=\"line\">          window.location.reload();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;, 60000);</span><br></pre></td></tr></table></figure>\n<p>关于 <code>document.currentScript</code>，注意如果当前正在执行的代码是处在某个回调函数或者事件处理函数中的，那么 currentScript 属性不会指向包含那个函数的 <code>&lt;script&gt;</code> 元素,而是会返回 <code>null</code> 。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>About</h4>\n<p>📅 2020 年 3 月的零散学习记录。</p>\n<p>🤦‍♀️ 新的一月，新的打气。希望自己这个月能多记笔记。</p>\n<p>预告：上传下载<br>\n正则专题</p>\n<h4>2020/03/20</h4>\n<p>CSS 中换行属性：<br>\n<img src=\"https://i.loli.net/2020/03/20/FRoCfSyxQhAT9Ln.png\" alt=\"image.png\"></p>\n<h4>2020/03/18</h4>\n<p>今日阅读：<a href=\"https://stackoverflow.com/questions/35250367/center-flex-items-with-one-at-the-end-of-the-row\" target=\"_blank\" rel=\"noopener\">Center flex items with one at the end of the row</a><br>\n在 flex 容器中，如果我们需要从左到右排列 items ，但最后一个 item 需要靠右（例如实现一个 Header ，avatar 需要靠右），可以在此 item 上加上 CSS 属性 <code>margin-left: auto</code> 。更详细的解释可以参考 StackOverflow 上这个<a href=\"https://stackoverflow.com/questions/32551291/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties/33856609#33856609\" target=\"_blank\" rel=\"noopener\">答案</a> 。有关 flex 布局的属性介绍参考该<a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\" target=\"_blank\" rel=\"noopener\">文档</a>。</p>\n<h4>2020/03/10</h4>\n<p><a href=\"https://prettier.io/docs/en/\" target=\"_blank\" rel=\"noopener\">prettier</a> 可用于格式化特定文件格式的代码，可与很多 pre-commit 工具配合使用，在提交 commit 之前自动格式化你通过 <code>git add</code> 加入暂存区的代码。<br>\n使用文档可参考<a href=\"https://prettier.io/docs/en/precommit.html\" target=\"_blank\" rel=\"noopener\">官方链接</a>，实际项目中用得较多的是 <code>lint-staged</code> ，它可以和其他很多代码质量工具如 ESLint 、 Stylelint 等结合使用。需要的依赖是 <code>prettier</code> 、 <code>husky</code> 以及 <code>lint-staged</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// yarn</span><br><span class=\"line\">yarn add prettier husky lint-stage --dev</span><br><span class=\"line\"></span><br><span class=\"line\">// npm</span><br><span class=\"line\">npm install prettier husky lint-stage --save-dev</span><br></pre></td></tr></table></figure>\n<p>注意官网提供了以下命令用于直接配置 lint-staged ：<code>npx mrm lint-staged</code> 。但试验中发现不生效，参考该<a href=\"https://stackoverflow.com/questions/50048717/lint-staged-not-running-on-precommit/56212836#56212836\" target=\"_blank\" rel=\"noopener\">答案</a>后发现该命令确实只在 package.json 中设置了 husky 和 lint-stage 配置，而没有将其作为依赖项添加或安装。为确保正确运行，还是直接安装比较省事。<br>\n安装完所需依赖后，在 package.json 加入以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">  &quot;hooks&quot;: &#123;</span><br><span class=\"line\">    &quot;pre-commit&quot;: &quot;lint-staged&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">  &quot;src/**/*.&#123;js,jsx,ts,tsx,json,css,less,md&#125;&quot;: [</span><br><span class=\"line\">    &quot;prettier --write&quot;,</span><br><span class=\"line\">    &quot;git add&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>详细的配置说明可参考 <a href=\"https://github.com/okonet/lint-staged#configuration\" target=\"_blank\" rel=\"noopener\">lint-staged 文档</a>。上述配置中，在 src 文件夹下的 js、jsx、ts、tsx、json、css、less、md 文件都会在提交前自动格式化。</p>\n<h4>2020/03/09</h4>\n<p><a href=\"https://www.keycdn.com/blog/npm-vs-yarn\" target=\"_blank\" rel=\"noopener\">Yarn vs NPM</a><br>\nnpm 和 yarn 都是包管理工具，yarn 是 Facebook 研发的，意在解决 npm 一致性、安全性和速度方面的一些问题。两者只是安装的手段不同，内部依赖的 npm structure 是相同的。yarn 相比 npm 的优势在于：</p>\n<ol>\n<li>yarn.lock 文件可以保证每个设备上安装的包都是相同的</li>\n<li>npm 只能通过序列化的方式一个接一个地安装包，yarn 可以同时执行多个安装步骤，因此速度更快</li>\n<li>npm 会自动从依赖项运行代码并允许动态添加软件包，yarn 只能从 yarn.lock 或 package.json 文件安装，因此更安全；且其在安装前使用校验和，以确保每个包的完整性</li>\n</ol>\n<p>关于如何从 npm 迁移到 yarn ，以及一些常用命令的比对，可以参考<a href=\"https://classic.yarnpkg.com/en/docs/migrating-from-npm/\" target=\"_blank\" rel=\"noopener\">官方文档</a>。常用的有：</p>\n<table>\n<thead>\n<tr>\n<th>NPM</th>\n<th>Yarn</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>npm install</td>\n<td>yarn add</td>\n</tr>\n<tr>\n<td>npm install [package] --save</td>\n<td>yarn add [package]</td>\n</tr>\n<tr>\n<td>npm install [package] --save-dev</td>\n<td>yarn add [package --dev]</td>\n</tr>\n<tr>\n<td>npm install [package] --global</td>\n<td>yarn global add [package]</td>\n</tr>\n<tr>\n<td>npm uninstall [package]</td>\n<td>yarn remove [package]</td>\n</tr>\n</tbody>\n</table>\n<p>注：<code>--save-dev</code> 用于安装仅开发阶段所需的依赖，<code>--save</code> 用于安装应用运行所需的依赖。</p>\n<h4>2020/03/07</h4>\n<p>一、TDZ: <a href=\"https://stackoverflow.com/questions/33198849/what-is-the-temporal-dead-zone\" target=\"_blank\" rel=\"noopener\">What is the temporal dead zone?</a><br>\nES6 新增了 <code>const</code> 和 <code>let</code> 两个关键字。他们与 <code>var</code> 一样，声明都会被提升（hoisted）。但对于 <code>const</code> 和 <code>let</code> 而言，存在一个“暂时性死区”的概念：如果在声明之前访问一个 <code>var</code> 变量，会返回 <code>undefined</code> ，但访问 <code>let</code> 或 <code>const</code> 变量会返回 <code>ReferenceError</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(aVar); // undefined</span><br><span class=\"line\">console.log(aLet); // causes ReferenceError: aLet is not defined</span><br><span class=\"line\">var aVar = 1;</span><br><span class=\"line\">let aLet = 2;</span><br></pre></td></tr></table></figure>\n<p>只有声明了变量（不是赋值），TDZ 才会结束：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//console.log(aLet)  // would throw ReferenceError</span><br><span class=\"line\"></span><br><span class=\"line\">let aLet;</span><br><span class=\"line\">console.log(aLet); // undefined</span><br><span class=\"line\">aLet = 10;</span><br><span class=\"line\">console.log(aLet); // 10</span><br></pre></td></tr></table></figure>\n<p>从上面的例子很容易陷入 “let 声明不会被提升” 的误区，实际上通过下面这个例子就可以证明声明会被提升：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x = &apos;outer value&apos;;</span><br><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  // start TDZ for x</span><br><span class=\"line\">  console.log(x);</span><br><span class=\"line\">  let x = &apos;inner value&apos;; // declaration ends TDZ for x</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>上面例子输出 <code>ReferenceError</code>，如果声明没有提升，会输出 “outer value” 。</p>\n<p>二、<a href=\"https://scaleyourcode.com/blog/article/27\" target=\"_blank\" rel=\"noopener\">What is Waiting (TTFB) in DevTools, and what to do about it</a></p>\n<h4>2020/03/06</h4>\n<p>考虑如下树形数据结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// interface TreeData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  value: &quot;&quot;,</span><br><span class=\"line\">  children: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      value: &quot;&quot;,</span><br><span class=\"line\">      children: [</span><br><span class=\"line\">        &#123;value:&quot;&quot;,children:[&#123;value:&quot;&quot;&#125;]&#125;,</span><br><span class=\"line\">        &#123;value:&quot;&quot;&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们有一组 children 标签和一个节点的 value 值，想要得到该节点在树形结构中的详细信息，可以使用递归遍历：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function getLabelDetail(value: string, labels: TreeData[]) &#123;</span><br><span class=\"line\">  const checkIfHitNode = (value: string, node: TreeData) =&gt; &#123;</span><br><span class=\"line\">    if (node.value === value) &#123;</span><br><span class=\"line\">      return node;</span><br><span class=\"line\">    &#125; else if (node.children) &#123;</span><br><span class=\"line\">      for (let i = 0; i &lt; node.children.length; i++) &#123;</span><br><span class=\"line\">        const result = checkIfHitNode(value, node.children[i]);</span><br><span class=\"line\">        if (result) &#123;</span><br><span class=\"line\">          return result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (let i = 0; i &lt; labels.length; i++) &#123;</span><br><span class=\"line\">    const hit = checkIfHitNode(value, labels[i]);</span><br><span class=\"line\">    if (hit) &#123;</span><br><span class=\"line\">      return hit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意 <code>checkIfHitNode()</code> 函数的输入值是 value 以及一个根节点，我们从根节点出发，依次检查 <code>children</code> 中是否包含要寻找的节点。</p>\n<h4>2020/03/05</h4>\n<p><code>URL()</code> 函数用于构造 URL，参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL\" target=\"_blank\" rel=\"noopener\">mdn</a>，内置多种静态属性，常用属性的输出值如下：<br>\n示例：<code>https://domain.cc:80/article?page=1</code></p>\n<table>\n<thead>\n<tr>\n<th>properties</th>\n<th>meaning</th>\n<th>output</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>href</td>\n<td>完整 URL</td>\n<td><code>https://domain.cc:80/article?page=1</code></td>\n</tr>\n<tr>\n<td>origin</td>\n<td>URL 协议、域名及端口号</td>\n<td><code>https://domain.cc:80</code></td>\n</tr>\n<tr>\n<td>protocol</td>\n<td>URL 协议</td>\n<td><code>https:</code></td>\n</tr>\n<tr>\n<td>host</td>\n<td>URL 域名及端口号</td>\n<td><code>domain.cc:80</code></td>\n</tr>\n<tr>\n<td>hostname</td>\n<td>URL 域名</td>\n<td><code>domain.cc</code></td>\n</tr>\n<tr>\n<td>port</td>\n<td>URL 端口号</td>\n<td><code>80</code></td>\n</tr>\n<tr>\n<td>pathname</td>\n<td>“/” 后的文件路径</td>\n<td><code>/article</code></td>\n</tr>\n<tr>\n<td>search</td>\n<td>URL 请求参数</td>\n<td><code>?page=1</code></td>\n</tr>\n<tr>\n<td>hash</td>\n<td>“#” 后的内容</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>在 URL 对象上调用 <code>toString()</code> 方法，返回 <code>url.href</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const url = new URL(&quot;http://......&quot;)</span><br><span class=\"line\">url.toString() // a synonym for URL.href</span><br></pre></td></tr></table></figure>\n<h4>2020/03/04</h4>\n<p>BroadcastChannel（<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel\" target=\"_blank\" rel=\"noopener\">mdn</a>）提供了在同源的不同的 windows，tabs，frames，iframes 之间通信的方法。通过触发一个 message 事件，消息可以广播到所有监听了该频道的 BroadcastChannel 对象。<br>\n实际应用中，我们可以用于检测用户是否打开了多个窗口。在 window 中注册一个 BroadcastChannel 对象，监听 <code>load</code> 和 <code>hashchange</code> 事件，广播当前页面的 url ，并监听 message 事件。这样当打开第二个页面时，第一个页面就会接收到其发送的消息，提示用户执行相关操作。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (</span><br><span class=\"line\">  process.env.NODE_ENV === &quot;production&quot; &amp;&amp;</span><br><span class=\"line\">  typeof BroadcastChannel !== &quot;undefined&quot;</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  function warn() &#123;</span><br><span class=\"line\">    Modal.warn(&#123;</span><br><span class=\"line\">      title: &quot;Warning!&quot;,</span><br><span class=\"line\">      content: &lt;p&gt;&quot;该页面已在另一窗口打开，同时打开两个窗口可能导致数据无法提交。&quot;&lt;/p&gt;,</span><br><span class=\"line\">      width: 600</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const bc = new BroadcastChannel(&quot;page&quot;);</span><br><span class=\"line\">  bc.onmessage = ev =&gt; &#123;</span><br><span class=\"line\">    if (ev.data.url === window.location.href) &#123;</span><br><span class=\"line\">      warn();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  window.addEventListener(&quot;load&quot;, () =&gt; &#123;</span><br><span class=\"line\">    bc.postMessage(&#123;</span><br><span class=\"line\">      url: window.location.href</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  window.addEventListener(&quot;hashchange&quot;, function(event) &#123;</span><br><span class=\"line\">    bc.postMessage(&#123;</span><br><span class=\"line\">      url: window.location.href</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>2020/03/03</h4>\n<p>如果我们希望升级应用时，前端页面也可以感知到并收到提示，可以每隔一定时间请求 currentScript（返回当前正在执行的 <code>&lt;script&gt;</code> 元素，<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/currentScript\" target=\"_blank\" rel=\"noopener\">mdn</a>），由于升级时文件的 hash 会发生变动，当返回 404 时，即可提示用户刷新页面。<br>\n注意：请求时加上时间戳，保证了不会取到浏览器的 cache 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const selfUrl = (document.currentScript as HTMLScriptElement).src;</span><br><span class=\"line\">const it = setInterval(() =&gt; &#123;</span><br><span class=\"line\">  axios[process.env.NODE_ENV === &quot;development&quot; ? &quot;get&quot; : &quot;head&quot;](selfUrl, &#123;</span><br><span class=\"line\">    params: &#123; t: Date.now() &#125;</span><br><span class=\"line\">  &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">    if (err.response &amp;&amp; err.response.status === 404) &#123;</span><br><span class=\"line\">      clearInterval(it);</span><br><span class=\"line\">      Modal.confirm(&#123;</span><br><span class=\"line\">        title: &quot;系统升级，是否刷新页面？&quot;,</span><br><span class=\"line\">        onOk() &#123;</span><br><span class=\"line\">          window.location.reload();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;, 60000);</span><br></pre></td></tr></table></figure>\n<p>关于 <code>document.currentScript</code>，注意如果当前正在执行的代码是处在某个回调函数或者事件处理函数中的，那么 currentScript 属性不会指向包含那个函数的 <code>&lt;script&gt;</code> 元素,而是会返回 <code>null</code> 。</p>\n"},{"title":"FrontEnd Daily Learning [2020.01]","catalog":true,"date":"2020-01-02T01:57:13.000Z","subtitle":null,"header-img":null,"_content":"#### About\n\n📅 2020 年 1 月的零散学习记录。\n\n新年快乐！希望新的一年能坚持记笔记！\n\n#### 2020/01/29\n今日阅读：[Here’s Why Mapping a Constructed Array in JavaScript Doesn’t Work](https://itnext.io/heres-why-mapping-a-constructed-array-doesn-t-work-in-javascript-f1195138615a)\n当我们想要生成一个 0 ~ 99 的数组时，除了最基础的遍历赋值，还可以利用 [Array()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Array) 方法。\n但使用 `Array.map()` ，并不会正确赋值：\n```\nconst arr = Array(100).map((_, i) => i);\nconsole.log(arr[0] === undefined);  // true\n```\n造成这个问题的原因是，在 JS 中 数组其实是一个对象，索引是 `key` ，数组元素是 `value` ，如：\n```\n['a', 'b', 'c']\n=> \n{\n  0: 'a',\n  1: 'b',\n  2: 'c',\n  length: 3\n}\n```\n当使用 `Array()` 构造函数时，只会生成一个“真空”对象：\n```\n{\n  //no index keys!\n  length: 100\n}\n```\n由于对象上并不存在 `key` ，`map` 函数并不会进行遍历，`reduce` 、`filter` 、`forEach` 等迭代函数也有同样的表现。解决办法是使用展开操作符：\n```\nconst arr = [...Array(100)].map((_, i) => i);\nconsole.log(arr[0]); // 0\n```\n\n#### 2020/01/28\n今日阅读：[How to Deep Copy Objects and Arrays in JavaScript](https://medium.com/javascript-in-plain-english/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089)\n如果数组/对象中都是 `primitive value` ，要实现深复制，常用的有下面三种方法：\n1. spread operator ...\n```\nconst array = ['😉','😊','😇']\n\nconst copyWithEquals = array // Changes to array will change copyWithEquals\nconsole.log(copyWithEquals === array) // true (The assignment operator did not make a copy)\n\nconst copyWithSpread = [...array] // Changes to array will not change copyWithSpread\nconsole.log(copyWithSpread === array) // false (The spread operator made a shallow copy)\n\narray[0] = '😡' // Whoops, a bug\n\nconsole.log(...array) // 😡 😊 😇\nconsole.log(...copyWithEquals) // 😡 😊 😇\nconsole.log(...copyWithSpread) // 😉 😊 😇\n```\n2. .slice()\n```\nconst array = ['😉','😊','😇']\n\nconst copyWithEquals = array // Changes to array will change copyWithEquals\nconsole.log(copyWithEquals === array) // true (The assignment operator did not make a copy)\n\nconst copyWithSlice = array.slice() // Changes to array will not change copyWithSlice\nconsole.log(copyWithSlice === array) // false (Using .slice() made a shallow copy of the array)\n\narray[0] = '😡' // Whoops, a bug\n\nconsole.log(...array) // 😡 😊 😇\nconsole.log(...copyWithEquals) // 😡 😊 😇\nconsole.log(...copyWithSlice) // 😉 😊 😇\n```\n3. .assign()\n```\nconst array = ['😉','😊','😇']\n\nconst copyWithEquals = array // Changes to array will change copyWithEquals\nconst copyWithAssign = [] // Changes to array will not change copyWithAssign\nObject.assign(copyWithAssign, array) // Object.assign(target, source)\n\narray[0] = '😡' // Whoops, a bug\n\nconsole.log(...array) // 😡 😊 😇\nconsole.log(...copyWithEquals) // 😡 😊 😇\nconsole.log(...copyWithAssign) // 😉 😊 😇\n```\n\n如果数组中的元素也是数组/对象，上述方法只能实现第一层次但深复制，没法对元素也进行深复制。作者提供了5种方法：\n1. [lodash](https://lodash.com/)\n`lodash` 提供了 `_.clone()` 以及 `_.cloneDeep()` 两个方法，第一个方法实现的是第一层面的深复制，第二个方法可以实现完全的深复制。\n2. [Ramda](https://ramdajs.com/)\n提供了 `R.clone()` 方法实现完全的深复制，相当于 `lodash.cloneDeep()` 。\n3. custom function\n可以自己实现一个深复制函数，基本思想是判断输入是否为数组/对象，如果是则继续逐层遍历赋值，否则返回原始值。还需考虑值为 `null` 的特殊情况，因为 `typeof null = \"object\"`\n```\nconst deepCopyFunction = inObject => {\n  let outObject, value, key;\n\n  if(typeof inObject !== \"object\" || inObject === null) {\n    return inObject;\n  };\n\n  outObject = Array.isArray(inObject) ? [] : {};\n\n  for(key in inObject) {\n    value = inObject[key];\n\n    outObject[key] = (typeof value === \"object\" && value !== null) ? deepCopyFunction(value) : value\n  };\n\n  return outObject;\n}\n```\n4. `JSON.parse(JSON.stringify(object))`\n该方法对元素有一定的要求，详见 stackoverflow 上[这个回答](https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/122704#122704)。总结而言，如果元素只是普通的数组对象，可以使用这个方法。\n5. [rfdc](https://www.npmjs.com/package/rfdc)\n作者想要推广的一个库，优点是速度很快。\n\n#### 2020/01/17\n[TypeScript: Conditional Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types)\n考虑以下场景：我们有一个获取资源的接口，根据资源类型返回不同的数据类型的数据，代码大致如下：  \n```\ngetResources<T>(type: \"tasks\"|\"jobs\"|\"queues\") {\n  return axios.get<T>('http://.......')\n}\n\n// use\nconst tasks = await getResources<TaskList>(\"tasks\")\nconst jobs = await getResources<JobList>(\"jobs\")\n```\n如果我们想要并行发送请求，可以使用 `Promise.all()` ：\n```\nconst [tasks, jobs] = await Promise.all([\"tasks\",\"jobs\"].map(type => {\n  return getResources<TaskList|JobList>(type)\n}))\n```\n上述代码引起的问题是，`tasks` 和 `jobs` 的类型会是 `TaskList|JobList` ，如果我们之后要访问他们的属性，避免不了 `as TaskList` ，`as JobList` 这种写法。优化做法是，使用 ts 的 conditional types，可以从输入类型推断出输出类型：\n```\nexport type ResType = \"tasks\" | \"jobs\" | \"queues\" ;\nexport type ResData<T extends ResType> = \n  T extends \"tasks\" ? TaskList: \n  T extends \"jobs\"  ? JobList : \n  T extends \"queues\" ? QueueList :\n  never;\n\ngetResources<T extends ResType>(type: T) {\n  return axios.get<ResData<T>>('http://.......')\n}\n```\n这样，在调用 `getResources` 就不用显式传入 `T` 。接下来，为了解决类型在 `Promise.all()` 用 `map` 可能推断不出来的问题，可以使用 tuple ：\n```\n// or just `getResources(\"tasks\")` if RV of getResources is already a promise\nconst taskPromise = Promise.resolve(getResources(\"tasks\"));\nconst jobPromise = Promise.resolve(getResources(\"jobs\"));\nconst [tasks, jobs] = await Promise.all([taskPromise,jobPromise])\n```\n一顿操作之后，我们就可以准确得到 `tasks` 和 `jobs` 的类型了。😎 \n扩展阅读：[Promise.resolve()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve) 、 [Promise.all()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)\n\n#### 2020/01/16\n今日踩坑记录。考虑以下代码：\n```\nconst [state, setState] = useState<string[]>([]);\n\nuseEffect(() => {\n  const loadData = async () => {\n    const lists = [\"list1\", \"list2\", \"list3\"];\n    for(const list of lists) {\n      const {data} = await thisIsPromise(list);\n      setState([...state, ...data])\n    }\n  };\n  // call async function \n  loadData(); \n},[])\n```\n运行上面的代码，`state` 并不会返回所有 `list` 的集合。原因是 `setState` 是异步更新的，每次循环调用 `setState([...state, ...data])` 时， `state` 都是初始值，也就是空数组。如果我们想要得到上一个 `state` 的值，只能使用下面这种写法：\n```\nconst [state, setState] = useState<string[]>([]);\n\nuseEffect(() => {\n  const loadData = async () => {\n    const lists = [\"list1\", \"list2\", \"list3\"];\n    for(const list of lists) {\n      const {data} = await thisIsPromise(list);\n      // HERE!\n      setState(prev => [...prev,...data])\n    }\n  };\n  // call async function \n  loadData(); \n},[])\n```\nReact 文档 [这部分](https://reactjs.org/docs/hooks-reference.html#functional-updates) 也特别说明了这一点:\n> If the new state is computed using the previous state, you can pass a function to setState. The function will receive the previous value, and return an updated value.\n\n#### 2020/01/15\n一、[一步一步解码 PNG 图片](https://vivaxyblog.github.io/2019/12/07/decode-a-png-image-with-javascript-cn.html)\n可以当成一份扩展阅读，讲了怎么从一张二进制 PNG 图片转成包含像素数据的 ImageData 。\n之前在工作中，主要是利用 `canvas` 得到 `imageData` ：\n```\nexport function getImageData(url: string): Promise<ImageData> {\n  const img = document.createElement(\"img\");\n  return new Promise((resolve, reject) => {\n    img.onload = () => {\n      try {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = img.naturalWidth;\n        canvas.height = img.naturalHeight;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0);\n        resolve(ctx.getImageData(0, 0, canvas.width, canvas.height));\n      } catch (err) {\n        reject(err);\n      }\n    };\n    img.onerror = err => {\n      reject(err);\n    };\n    img.crossOrigin = \"Anonymous\";\n    img.src = url;\n  });\n}\n```\n`imageData` 是不能直接存进后台数据库的，我们需要进行 PNG 编码转换为二进制数据，用到的是 [UPNG.js](https://github.com/photopea/UPNG.js/) 这个库：\n```\nimport UPNG from \"upng-js\";\nconst buffer: ArrayBuffer = UPNG.encode(\n  [imageData.buffer as ArrayBuffer],\n  image.width,\n  image.height,\n  0\n);\n```\n\n#### 2020/01/13\n一、[3 things you didn’t know about the forEach loop in JS](https://medium.com/front-end-weekly/3-things-you-didnt-know-about-the-foreach-loop-in-js-ff02cec465b1)\n总结一下，就是在 `forEach` 中，使用 `return` 、 `break` 、 `continute` 都是无效的。 `return` 不会退出函数，`break` 和 `continute` 不允许在 `forEach` 中使用。如果需要能退出循环，使用简单的 `for` loop 即可。MDN 上已经写明：\n> There is no way to stop or break a forEach() loop other than by throwing an exception. If you need such behavior, the forEach() method is the wrong tool.\n\n二、[under_scores, camelCase and PascalCase - The three naming conventions every programmer should be aware of](https://dev.to/prahladyeri/underscores-camelcasing-and-pascalcasing-the-three-naming-conventions-every-programmer-should-be-aware-of-3aed)\n简单介绍了编程中三种命名规则，可以学一下正确的名词表达：\n![image.png](https://i.loli.net/2020/01/13/kAnN3GvZBiWDPRu.png)\n`camelCase` 大家都不陌生，就是最常见的首字母小写驼峰样式；`under_scores` 就是以下划线隔开多个小写字母，JS 中这些命名方式比较少用；`PascalCase` 就是首字母大写驼峰样式。此外，函数、变量、类、命名空间这些可以统称为 `tokens` 。\n\n#### 2020/01/12\n一、[Why ['1', '7', '11'].map(parseInt) returns [1, NaN, 3] in Javascript](https://medium.com/dailyjs/parseint-mystery-7c4368ef7b21)\n一篇非常有趣的文章，开篇一张图：\n![image.png](https://i.loli.net/2020/01/12/grShLvH28RDXtYM.png)\n出现这种结果的原因，在于 `map` 函数默认会传入三个参数：currentValue、currentIndex 以及 full array 。而对于 `parseInt` 而言，第二个参数表示基数，用此来解析数组中的每个字符串，取值是 2 ~ 36 的整数。'1' 以 0 为基数进行解析，0 的布尔值为 `false`，等于没有传入第二个参数，因此会以默认基数 10 进行解析，输出 1 ；'7' 以 1 为基数 进行解析，会输出 `NaN` ；'11' 以 2 为基数解析，会输出 3。\n\n二、[The Power of the Observer Pattern in JavaScript](https://medium.com/better-programming/the-observer-pattern-in-javascript-4f4e0b908d5e)\n介绍了 Observer Patten，并用 JS 写了一份简单实现。本质就是维护一个观察者列表，每次有变化时遍历通知。\n\n#### 2020/01/09\n一、[How to handle errors in Promise.all](https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all/30378082)\n简单来说就是：\n```\nawait Promise.all(vals.map(val => \n  promise(val)\n  .catch(err => {\n    // handle here\n    return err\n  })\n))\n```\n\n二、[New ES2018 Features](https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/)\n\n#### 2020/01/05\n今天需要对某个数值进行类型校验，避免出现 `NaN`，本来是用 `!typeof value === 'number'`，后来发现：\n```\ntypeof NaN === 'number'\n```\n关于为什么是这种输出，可以看 medium 上这篇文章：[NaN and typeof](https://javascriptrefined.io/nan-and-typeof-36cd6e2a4e43)。\n如果需要判断某个数是否为 `NaN`，可用 `isNaN(value)` 判断。\n\n#### 2020/01/04\n今天在处理正则表达式时遇到这样的疑惑：\n```\nconst str = '\\abc';\nconst reg = /\\\\abc/;\nreg.test(str); // false\n```\n我们都知道反斜杠 `\\` 是转义的作用，如果要输出斜杠，那么必须使用 `\\\\` ；在上面的代码中，`reg` 匹配是是 `\\abc` ，为什么输出结果会是 `false` 呢？\n经过查阅，发现在字符串中，'\\' 也有转义的作用。如果反斜杠出现在字符的前面，那么他们就是一个整体，比如说 '\\n' 表示换行，字符串 '\\abc' 也涉及转义操作，由于 a 不是有效的转义符，所以就直接转成 'abc' 。下面的代码可以验证这个说法：\n```\nconst str = \"\\abc\";\nconsole.info(str.length); // 3\n\"\\abc\" === \"abc\" //true\n```\n因此，上面的代码应该改成：\n```\nconst str = '\\\\abc';\nconst reg = /\\\\abc/;\nreg.test(str); // true\n```\n\n#### 2020/01/02\n放大预览图片的某个部分：思路是计算 bbox 的 scale 数值，使之能填充满整个 container ；再计算原始图片的偏移量，使之只显示 bbox 部分。    \n```\nfunction Preview(props: {\n  imgSrc: string;\n  imgSize: { width: number; height: number };\n  box: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n}) {\n  const [containerSize] = useState({ width: 350, height: 400 });\n\n  const scale = Math.min(\n    containerSize.width / props.box.width,\n    containerSize.height / props.box.height\n  );\n  const boxCenter = {\n    x: props.box.x + props.box.width / 2,\n    y: props.box.y + props.box.height / 2\n  };\n  const containerCenter = {\n    x: containerSize.width / 2,\n    y: containerSize.height / 2\n  };\n  const tr = {\n    x: containerCenter.x - boxCenter.x * scale,\n    y: containerCenter.y - boxCenter.y * scale\n  };\n\n  return (\n    <div style={{ position: \"relative\", ...containerSize, overflow: \"hidden\" }}>\n      <img\n        src={props.imgSrc}\n        style={{\n          ...props.imgSize,\n          objectFit: \"contain\",\n          position: \"absolute\",\n          left: 0,\n          top: 0,\n          transform: `translate(${tr.x}px, ${tr.y}px) scale(${scale})`,\n          transformOrigin: \"top left\",\n          transition: \"all 0.3s\"\n        }}\n      />\n    </div>\n  );\n}\n```","source":"_posts/FrontEnd-Daily-Learning-2020-01.md","raw":"---\ntitle: 'FrontEnd Daily Learning [2020.01]'\ncatalog: true\ndate: 2020-01-02 09:57:13\nsubtitle:\nheader-img:\ntags: FE\n---\n#### About\n\n📅 2020 年 1 月的零散学习记录。\n\n新年快乐！希望新的一年能坚持记笔记！\n\n#### 2020/01/29\n今日阅读：[Here’s Why Mapping a Constructed Array in JavaScript Doesn’t Work](https://itnext.io/heres-why-mapping-a-constructed-array-doesn-t-work-in-javascript-f1195138615a)\n当我们想要生成一个 0 ~ 99 的数组时，除了最基础的遍历赋值，还可以利用 [Array()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Array) 方法。\n但使用 `Array.map()` ，并不会正确赋值：\n```\nconst arr = Array(100).map((_, i) => i);\nconsole.log(arr[0] === undefined);  // true\n```\n造成这个问题的原因是，在 JS 中 数组其实是一个对象，索引是 `key` ，数组元素是 `value` ，如：\n```\n['a', 'b', 'c']\n=> \n{\n  0: 'a',\n  1: 'b',\n  2: 'c',\n  length: 3\n}\n```\n当使用 `Array()` 构造函数时，只会生成一个“真空”对象：\n```\n{\n  //no index keys!\n  length: 100\n}\n```\n由于对象上并不存在 `key` ，`map` 函数并不会进行遍历，`reduce` 、`filter` 、`forEach` 等迭代函数也有同样的表现。解决办法是使用展开操作符：\n```\nconst arr = [...Array(100)].map((_, i) => i);\nconsole.log(arr[0]); // 0\n```\n\n#### 2020/01/28\n今日阅读：[How to Deep Copy Objects and Arrays in JavaScript](https://medium.com/javascript-in-plain-english/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089)\n如果数组/对象中都是 `primitive value` ，要实现深复制，常用的有下面三种方法：\n1. spread operator ...\n```\nconst array = ['😉','😊','😇']\n\nconst copyWithEquals = array // Changes to array will change copyWithEquals\nconsole.log(copyWithEquals === array) // true (The assignment operator did not make a copy)\n\nconst copyWithSpread = [...array] // Changes to array will not change copyWithSpread\nconsole.log(copyWithSpread === array) // false (The spread operator made a shallow copy)\n\narray[0] = '😡' // Whoops, a bug\n\nconsole.log(...array) // 😡 😊 😇\nconsole.log(...copyWithEquals) // 😡 😊 😇\nconsole.log(...copyWithSpread) // 😉 😊 😇\n```\n2. .slice()\n```\nconst array = ['😉','😊','😇']\n\nconst copyWithEquals = array // Changes to array will change copyWithEquals\nconsole.log(copyWithEquals === array) // true (The assignment operator did not make a copy)\n\nconst copyWithSlice = array.slice() // Changes to array will not change copyWithSlice\nconsole.log(copyWithSlice === array) // false (Using .slice() made a shallow copy of the array)\n\narray[0] = '😡' // Whoops, a bug\n\nconsole.log(...array) // 😡 😊 😇\nconsole.log(...copyWithEquals) // 😡 😊 😇\nconsole.log(...copyWithSlice) // 😉 😊 😇\n```\n3. .assign()\n```\nconst array = ['😉','😊','😇']\n\nconst copyWithEquals = array // Changes to array will change copyWithEquals\nconst copyWithAssign = [] // Changes to array will not change copyWithAssign\nObject.assign(copyWithAssign, array) // Object.assign(target, source)\n\narray[0] = '😡' // Whoops, a bug\n\nconsole.log(...array) // 😡 😊 😇\nconsole.log(...copyWithEquals) // 😡 😊 😇\nconsole.log(...copyWithAssign) // 😉 😊 😇\n```\n\n如果数组中的元素也是数组/对象，上述方法只能实现第一层次但深复制，没法对元素也进行深复制。作者提供了5种方法：\n1. [lodash](https://lodash.com/)\n`lodash` 提供了 `_.clone()` 以及 `_.cloneDeep()` 两个方法，第一个方法实现的是第一层面的深复制，第二个方法可以实现完全的深复制。\n2. [Ramda](https://ramdajs.com/)\n提供了 `R.clone()` 方法实现完全的深复制，相当于 `lodash.cloneDeep()` 。\n3. custom function\n可以自己实现一个深复制函数，基本思想是判断输入是否为数组/对象，如果是则继续逐层遍历赋值，否则返回原始值。还需考虑值为 `null` 的特殊情况，因为 `typeof null = \"object\"`\n```\nconst deepCopyFunction = inObject => {\n  let outObject, value, key;\n\n  if(typeof inObject !== \"object\" || inObject === null) {\n    return inObject;\n  };\n\n  outObject = Array.isArray(inObject) ? [] : {};\n\n  for(key in inObject) {\n    value = inObject[key];\n\n    outObject[key] = (typeof value === \"object\" && value !== null) ? deepCopyFunction(value) : value\n  };\n\n  return outObject;\n}\n```\n4. `JSON.parse(JSON.stringify(object))`\n该方法对元素有一定的要求，详见 stackoverflow 上[这个回答](https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/122704#122704)。总结而言，如果元素只是普通的数组对象，可以使用这个方法。\n5. [rfdc](https://www.npmjs.com/package/rfdc)\n作者想要推广的一个库，优点是速度很快。\n\n#### 2020/01/17\n[TypeScript: Conditional Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types)\n考虑以下场景：我们有一个获取资源的接口，根据资源类型返回不同的数据类型的数据，代码大致如下：  \n```\ngetResources<T>(type: \"tasks\"|\"jobs\"|\"queues\") {\n  return axios.get<T>('http://.......')\n}\n\n// use\nconst tasks = await getResources<TaskList>(\"tasks\")\nconst jobs = await getResources<JobList>(\"jobs\")\n```\n如果我们想要并行发送请求，可以使用 `Promise.all()` ：\n```\nconst [tasks, jobs] = await Promise.all([\"tasks\",\"jobs\"].map(type => {\n  return getResources<TaskList|JobList>(type)\n}))\n```\n上述代码引起的问题是，`tasks` 和 `jobs` 的类型会是 `TaskList|JobList` ，如果我们之后要访问他们的属性，避免不了 `as TaskList` ，`as JobList` 这种写法。优化做法是，使用 ts 的 conditional types，可以从输入类型推断出输出类型：\n```\nexport type ResType = \"tasks\" | \"jobs\" | \"queues\" ;\nexport type ResData<T extends ResType> = \n  T extends \"tasks\" ? TaskList: \n  T extends \"jobs\"  ? JobList : \n  T extends \"queues\" ? QueueList :\n  never;\n\ngetResources<T extends ResType>(type: T) {\n  return axios.get<ResData<T>>('http://.......')\n}\n```\n这样，在调用 `getResources` 就不用显式传入 `T` 。接下来，为了解决类型在 `Promise.all()` 用 `map` 可能推断不出来的问题，可以使用 tuple ：\n```\n// or just `getResources(\"tasks\")` if RV of getResources is already a promise\nconst taskPromise = Promise.resolve(getResources(\"tasks\"));\nconst jobPromise = Promise.resolve(getResources(\"jobs\"));\nconst [tasks, jobs] = await Promise.all([taskPromise,jobPromise])\n```\n一顿操作之后，我们就可以准确得到 `tasks` 和 `jobs` 的类型了。😎 \n扩展阅读：[Promise.resolve()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve) 、 [Promise.all()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)\n\n#### 2020/01/16\n今日踩坑记录。考虑以下代码：\n```\nconst [state, setState] = useState<string[]>([]);\n\nuseEffect(() => {\n  const loadData = async () => {\n    const lists = [\"list1\", \"list2\", \"list3\"];\n    for(const list of lists) {\n      const {data} = await thisIsPromise(list);\n      setState([...state, ...data])\n    }\n  };\n  // call async function \n  loadData(); \n},[])\n```\n运行上面的代码，`state` 并不会返回所有 `list` 的集合。原因是 `setState` 是异步更新的，每次循环调用 `setState([...state, ...data])` 时， `state` 都是初始值，也就是空数组。如果我们想要得到上一个 `state` 的值，只能使用下面这种写法：\n```\nconst [state, setState] = useState<string[]>([]);\n\nuseEffect(() => {\n  const loadData = async () => {\n    const lists = [\"list1\", \"list2\", \"list3\"];\n    for(const list of lists) {\n      const {data} = await thisIsPromise(list);\n      // HERE!\n      setState(prev => [...prev,...data])\n    }\n  };\n  // call async function \n  loadData(); \n},[])\n```\nReact 文档 [这部分](https://reactjs.org/docs/hooks-reference.html#functional-updates) 也特别说明了这一点:\n> If the new state is computed using the previous state, you can pass a function to setState. The function will receive the previous value, and return an updated value.\n\n#### 2020/01/15\n一、[一步一步解码 PNG 图片](https://vivaxyblog.github.io/2019/12/07/decode-a-png-image-with-javascript-cn.html)\n可以当成一份扩展阅读，讲了怎么从一张二进制 PNG 图片转成包含像素数据的 ImageData 。\n之前在工作中，主要是利用 `canvas` 得到 `imageData` ：\n```\nexport function getImageData(url: string): Promise<ImageData> {\n  const img = document.createElement(\"img\");\n  return new Promise((resolve, reject) => {\n    img.onload = () => {\n      try {\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = img.naturalWidth;\n        canvas.height = img.naturalHeight;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0);\n        resolve(ctx.getImageData(0, 0, canvas.width, canvas.height));\n      } catch (err) {\n        reject(err);\n      }\n    };\n    img.onerror = err => {\n      reject(err);\n    };\n    img.crossOrigin = \"Anonymous\";\n    img.src = url;\n  });\n}\n```\n`imageData` 是不能直接存进后台数据库的，我们需要进行 PNG 编码转换为二进制数据，用到的是 [UPNG.js](https://github.com/photopea/UPNG.js/) 这个库：\n```\nimport UPNG from \"upng-js\";\nconst buffer: ArrayBuffer = UPNG.encode(\n  [imageData.buffer as ArrayBuffer],\n  image.width,\n  image.height,\n  0\n);\n```\n\n#### 2020/01/13\n一、[3 things you didn’t know about the forEach loop in JS](https://medium.com/front-end-weekly/3-things-you-didnt-know-about-the-foreach-loop-in-js-ff02cec465b1)\n总结一下，就是在 `forEach` 中，使用 `return` 、 `break` 、 `continute` 都是无效的。 `return` 不会退出函数，`break` 和 `continute` 不允许在 `forEach` 中使用。如果需要能退出循环，使用简单的 `for` loop 即可。MDN 上已经写明：\n> There is no way to stop or break a forEach() loop other than by throwing an exception. If you need such behavior, the forEach() method is the wrong tool.\n\n二、[under_scores, camelCase and PascalCase - The three naming conventions every programmer should be aware of](https://dev.to/prahladyeri/underscores-camelcasing-and-pascalcasing-the-three-naming-conventions-every-programmer-should-be-aware-of-3aed)\n简单介绍了编程中三种命名规则，可以学一下正确的名词表达：\n![image.png](https://i.loli.net/2020/01/13/kAnN3GvZBiWDPRu.png)\n`camelCase` 大家都不陌生，就是最常见的首字母小写驼峰样式；`under_scores` 就是以下划线隔开多个小写字母，JS 中这些命名方式比较少用；`PascalCase` 就是首字母大写驼峰样式。此外，函数、变量、类、命名空间这些可以统称为 `tokens` 。\n\n#### 2020/01/12\n一、[Why ['1', '7', '11'].map(parseInt) returns [1, NaN, 3] in Javascript](https://medium.com/dailyjs/parseint-mystery-7c4368ef7b21)\n一篇非常有趣的文章，开篇一张图：\n![image.png](https://i.loli.net/2020/01/12/grShLvH28RDXtYM.png)\n出现这种结果的原因，在于 `map` 函数默认会传入三个参数：currentValue、currentIndex 以及 full array 。而对于 `parseInt` 而言，第二个参数表示基数，用此来解析数组中的每个字符串，取值是 2 ~ 36 的整数。'1' 以 0 为基数进行解析，0 的布尔值为 `false`，等于没有传入第二个参数，因此会以默认基数 10 进行解析，输出 1 ；'7' 以 1 为基数 进行解析，会输出 `NaN` ；'11' 以 2 为基数解析，会输出 3。\n\n二、[The Power of the Observer Pattern in JavaScript](https://medium.com/better-programming/the-observer-pattern-in-javascript-4f4e0b908d5e)\n介绍了 Observer Patten，并用 JS 写了一份简单实现。本质就是维护一个观察者列表，每次有变化时遍历通知。\n\n#### 2020/01/09\n一、[How to handle errors in Promise.all](https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all/30378082)\n简单来说就是：\n```\nawait Promise.all(vals.map(val => \n  promise(val)\n  .catch(err => {\n    // handle here\n    return err\n  })\n))\n```\n\n二、[New ES2018 Features](https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/)\n\n#### 2020/01/05\n今天需要对某个数值进行类型校验，避免出现 `NaN`，本来是用 `!typeof value === 'number'`，后来发现：\n```\ntypeof NaN === 'number'\n```\n关于为什么是这种输出，可以看 medium 上这篇文章：[NaN and typeof](https://javascriptrefined.io/nan-and-typeof-36cd6e2a4e43)。\n如果需要判断某个数是否为 `NaN`，可用 `isNaN(value)` 判断。\n\n#### 2020/01/04\n今天在处理正则表达式时遇到这样的疑惑：\n```\nconst str = '\\abc';\nconst reg = /\\\\abc/;\nreg.test(str); // false\n```\n我们都知道反斜杠 `\\` 是转义的作用，如果要输出斜杠，那么必须使用 `\\\\` ；在上面的代码中，`reg` 匹配是是 `\\abc` ，为什么输出结果会是 `false` 呢？\n经过查阅，发现在字符串中，'\\' 也有转义的作用。如果反斜杠出现在字符的前面，那么他们就是一个整体，比如说 '\\n' 表示换行，字符串 '\\abc' 也涉及转义操作，由于 a 不是有效的转义符，所以就直接转成 'abc' 。下面的代码可以验证这个说法：\n```\nconst str = \"\\abc\";\nconsole.info(str.length); // 3\n\"\\abc\" === \"abc\" //true\n```\n因此，上面的代码应该改成：\n```\nconst str = '\\\\abc';\nconst reg = /\\\\abc/;\nreg.test(str); // true\n```\n\n#### 2020/01/02\n放大预览图片的某个部分：思路是计算 bbox 的 scale 数值，使之能填充满整个 container ；再计算原始图片的偏移量，使之只显示 bbox 部分。    \n```\nfunction Preview(props: {\n  imgSrc: string;\n  imgSize: { width: number; height: number };\n  box: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n}) {\n  const [containerSize] = useState({ width: 350, height: 400 });\n\n  const scale = Math.min(\n    containerSize.width / props.box.width,\n    containerSize.height / props.box.height\n  );\n  const boxCenter = {\n    x: props.box.x + props.box.width / 2,\n    y: props.box.y + props.box.height / 2\n  };\n  const containerCenter = {\n    x: containerSize.width / 2,\n    y: containerSize.height / 2\n  };\n  const tr = {\n    x: containerCenter.x - boxCenter.x * scale,\n    y: containerCenter.y - boxCenter.y * scale\n  };\n\n  return (\n    <div style={{ position: \"relative\", ...containerSize, overflow: \"hidden\" }}>\n      <img\n        src={props.imgSrc}\n        style={{\n          ...props.imgSize,\n          objectFit: \"contain\",\n          position: \"absolute\",\n          left: 0,\n          top: 0,\n          transform: `translate(${tr.x}px, ${tr.y}px) scale(${scale})`,\n          transformOrigin: \"top left\",\n          transition: \"all 0.3s\"\n        }}\n      />\n    </div>\n  );\n}\n```","slug":"FrontEnd-Daily-Learning-2020-01","published":1,"updated":"2020-03-04T02:51:22.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7ef1vgo0001qsue1imt4il3","content":"<h4 id=\"about\">About</h4>\n<p>📅 2020 年 1 月的零散学习记录。</p>\n<p>新年快乐！希望新的一年能坚持记笔记！</p>\n<h4 id=\"20200129\">2020/01/29</h4>\n<p>今日阅读：<a href=\"https://itnext.io/heres-why-mapping-a-constructed-array-doesn-t-work-in-javascript-f1195138615a\" target=\"_blank\" rel=\"noopener\">Here’s Why Mapping a Constructed Array in JavaScript Doesn’t Work</a><br>\n当我们想要生成一个 0 ~ 99 的数组时，除了最基础的遍历赋值，还可以利用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Array\" target=\"_blank\" rel=\"noopener\">Array()</a> 方法。<br>\n但使用 <code>Array.map()</code> ，并不会正确赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = Array(100).map((_, i) =&gt; i);</span><br><span class=\"line\">console.log(arr[0] === undefined);  // true</span><br></pre></td></tr></table></figure>\n<p>造成这个问题的原因是，在 JS 中 数组其实是一个对象，索引是 <code>key</code> ，数组元素是 <code>value</code> ，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class=\"line\">=&gt; </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  0: &apos;a&apos;,</span><br><span class=\"line\">  1: &apos;b&apos;,</span><br><span class=\"line\">  2: &apos;c&apos;,</span><br><span class=\"line\">  length: 3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当使用 <code>Array()</code> 构造函数时，只会生成一个“真空”对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  //no index keys!</span><br><span class=\"line\">  length: 100</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于对象上并不存在 <code>key</code> ，<code>map</code> 函数并不会进行遍历，<code>reduce</code> 、<code>filter</code> 、<code>forEach</code> 等迭代函数也有同样的表现。解决办法是使用展开操作符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [...Array(100)].map((_, i) =&gt; i);</span><br><span class=\"line\">console.log(arr[0]); // 0</span><br></pre></td></tr></table></figure>\n<h4 id=\"20200128\">2020/01/28</h4>\n<p>今日阅读：<a href=\"https://medium.com/javascript-in-plain-english/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089\" target=\"_blank\" rel=\"noopener\">How to Deep Copy Objects and Arrays in JavaScript</a><br>\n如果数组/对象中都是 <code>primitive value</code> ，要实现深复制，常用的有下面三种方法：</p>\n<ol>\n<li>spread operator …</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const array = [&apos;😉&apos;,&apos;😊&apos;,&apos;😇&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">const copyWithEquals = array // Changes to array will change copyWithEquals</span><br><span class=\"line\">console.log(copyWithEquals === array) // true (The assignment operator did not make a copy)</span><br><span class=\"line\"></span><br><span class=\"line\">const copyWithSpread = [...array] // Changes to array will not change copyWithSpread</span><br><span class=\"line\">console.log(copyWithSpread === array) // false (The spread operator made a shallow copy)</span><br><span class=\"line\"></span><br><span class=\"line\">array[0] = &apos;😡&apos; // Whoops, a bug</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(...array) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithEquals) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithSpread) // 😉 😊 😇</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>.slice()</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const array = [&apos;😉&apos;,&apos;😊&apos;,&apos;😇&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">const copyWithEquals = array // Changes to array will change copyWithEquals</span><br><span class=\"line\">console.log(copyWithEquals === array) // true (The assignment operator did not make a copy)</span><br><span class=\"line\"></span><br><span class=\"line\">const copyWithSlice = array.slice() // Changes to array will not change copyWithSlice</span><br><span class=\"line\">console.log(copyWithSlice === array) // false (Using .slice() made a shallow copy of the array)</span><br><span class=\"line\"></span><br><span class=\"line\">array[0] = &apos;😡&apos; // Whoops, a bug</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(...array) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithEquals) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithSlice) // 😉 😊 😇</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>.assign()</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const array = [&apos;😉&apos;,&apos;😊&apos;,&apos;😇&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">const copyWithEquals = array // Changes to array will change copyWithEquals</span><br><span class=\"line\">const copyWithAssign = [] // Changes to array will not change copyWithAssign</span><br><span class=\"line\">Object.assign(copyWithAssign, array) // Object.assign(target, source)</span><br><span class=\"line\"></span><br><span class=\"line\">array[0] = &apos;😡&apos; // Whoops, a bug</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(...array) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithEquals) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithAssign) // 😉 😊 😇</span><br></pre></td></tr></table></figure>\n<p>如果数组中的元素也是数组/对象，上述方法只能实现第一层次但深复制，没法对元素也进行深复制。作者提供了5种方法：</p>\n<ol>\n<li><a href=\"https://lodash.com/\" target=\"_blank\" rel=\"noopener\">lodash</a><br>\n<code>lodash</code> 提供了 <code>_.clone()</code> 以及 <code>_.cloneDeep()</code> 两个方法，第一个方法实现的是第一层面的深复制，第二个方法可以实现完全的深复制。</li>\n<li><a href=\"https://ramdajs.com/\" target=\"_blank\" rel=\"noopener\">Ramda</a><br>\n提供了 <code>R.clone()</code> 方法实现完全的深复制，相当于 <code>lodash.cloneDeep()</code> 。</li>\n<li>custom function<br>\n可以自己实现一个深复制函数，基本思想是判断输入是否为数组/对象，如果是则继续逐层遍历赋值，否则返回原始值。还需考虑值为 <code>null</code> 的特殊情况，因为 <code>typeof null = &quot;object&quot;</code></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const deepCopyFunction = inObject =&gt; &#123;</span><br><span class=\"line\">  let outObject, value, key;</span><br><span class=\"line\"></span><br><span class=\"line\">  if(typeof inObject !== &quot;object&quot; || inObject === null) &#123;</span><br><span class=\"line\">    return inObject;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  outObject = Array.isArray(inObject) ? [] : &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  for(key in inObject) &#123;</span><br><span class=\"line\">    value = inObject[key];</span><br><span class=\"line\"></span><br><span class=\"line\">    outObject[key] = (typeof value === &quot;object&quot; &amp;&amp; value !== null) ? deepCopyFunction(value) : value</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return outObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><code>JSON.parse(JSON.stringify(object))</code><br>\n该方法对元素有一定的要求，详见 stackoverflow 上<a href=\"https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/122704#122704\" target=\"_blank\" rel=\"noopener\">这个回答</a>。总结而言，如果元素只是普通的数组对象，可以使用这个方法。</li>\n<li><a href=\"https://www.npmjs.com/package/rfdc\" target=\"_blank\" rel=\"noopener\">rfdc</a><br>\n作者想要推广的一个库，优点是速度很快。</li>\n</ol>\n<h4 id=\"20200117\">2020/01/17</h4>\n<p><a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types\" target=\"_blank\" rel=\"noopener\">TypeScript: Conditional Types</a><br>\n考虑以下场景：我们有一个获取资源的接口，根据资源类型返回不同的数据类型的数据，代码大致如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getResources&lt;T&gt;(type: &quot;tasks&quot;|&quot;jobs&quot;|&quot;queues&quot;) &#123;</span><br><span class=\"line\">  return axios.get&lt;T&gt;(&apos;http://.......&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// use</span><br><span class=\"line\">const tasks = await getResources&lt;TaskList&gt;(&quot;tasks&quot;)</span><br><span class=\"line\">const jobs = await getResources&lt;JobList&gt;(&quot;jobs&quot;)</span><br></pre></td></tr></table></figure>\n<p>如果我们想要并行发送请求，可以使用 <code>Promise.all()</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const [tasks, jobs] = await Promise.all([&quot;tasks&quot;,&quot;jobs&quot;].map(type =&gt; &#123;</span><br><span class=\"line\">  return getResources&lt;TaskList|JobList&gt;(type)</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>上述代码引起的问题是，<code>tasks</code> 和 <code>jobs</code> 的类型会是 <code>TaskList|JobList</code> ，如果我们之后要访问他们的属性，避免不了 <code>as TaskList</code> ，<code>as JobList</code> 这种写法。优化做法是，使用 ts 的 conditional types，可以从输入类型推断出输出类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export type ResType = &quot;tasks&quot; | &quot;jobs&quot; | &quot;queues&quot; ;</span><br><span class=\"line\">export type ResData&lt;T extends ResType&gt; = </span><br><span class=\"line\">  T extends &quot;tasks&quot; ? TaskList: </span><br><span class=\"line\">  T extends &quot;jobs&quot;  ? JobList : </span><br><span class=\"line\">  T extends &quot;queues&quot; ? QueueList :</span><br><span class=\"line\">  never;</span><br><span class=\"line\"></span><br><span class=\"line\">getResources&lt;T extends ResType&gt;(type: T) &#123;</span><br><span class=\"line\">  return axios.get&lt;ResData&lt;T&gt;&gt;(&apos;http://.......&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，在调用 <code>getResources</code> 就不用显式传入 <code>T</code> 。接下来，为了解决类型在 <code>Promise.all()</code> 用 <code>map</code> 可能推断不出来的问题，可以使用 tuple ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// or just `getResources(&quot;tasks&quot;)` if RV of getResources is already a promise</span><br><span class=\"line\">const taskPromise = Promise.resolve(getResources(&quot;tasks&quot;));</span><br><span class=\"line\">const jobPromise = Promise.resolve(getResources(&quot;jobs&quot;));</span><br><span class=\"line\">const [tasks, jobs] = await Promise.all([taskPromise,jobPromise])</span><br></pre></td></tr></table></figure>\n<p>一顿操作之后，我们就可以准确得到 <code>tasks</code> 和 <code>jobs</code> 的类型了。😎<br>\n扩展阅读：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\" target=\"_blank\" rel=\"noopener\">Promise.resolve()</a> 、 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\" target=\"_blank\" rel=\"noopener\">Promise.all()</a></p>\n<h4 id=\"20200116\">2020/01/16</h4>\n<p>今日踩坑记录。考虑以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const [state, setState] = useState&lt;string[]&gt;([]);</span><br><span class=\"line\"></span><br><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  const loadData = async () =&gt; &#123;</span><br><span class=\"line\">    const lists = [&quot;list1&quot;, &quot;list2&quot;, &quot;list3&quot;];</span><br><span class=\"line\">    for(const list of lists) &#123;</span><br><span class=\"line\">      const &#123;data&#125; = await thisIsPromise(list);</span><br><span class=\"line\">      setState([...state, ...data])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  // call async function </span><br><span class=\"line\">  loadData(); </span><br><span class=\"line\">&#125;,[])</span><br></pre></td></tr></table></figure>\n<p>运行上面的代码，<code>state</code> 并不会返回所有 <code>list</code> 的集合。原因是 <code>setState</code> 是异步更新的，每次循环调用 <code>setState([...state, ...data])</code> 时， <code>state</code> 都是初始值，也就是空数组。如果我们想要得到上一个 <code>state</code> 的值，只能使用下面这种写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const [state, setState] = useState&lt;string[]&gt;([]);</span><br><span class=\"line\"></span><br><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  const loadData = async () =&gt; &#123;</span><br><span class=\"line\">    const lists = [&quot;list1&quot;, &quot;list2&quot;, &quot;list3&quot;];</span><br><span class=\"line\">    for(const list of lists) &#123;</span><br><span class=\"line\">      const &#123;data&#125; = await thisIsPromise(list);</span><br><span class=\"line\">      // HERE!</span><br><span class=\"line\">      setState(prev =&gt; [...prev,...data])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  // call async function </span><br><span class=\"line\">  loadData(); </span><br><span class=\"line\">&#125;,[])</span><br></pre></td></tr></table></figure>\n<p>React 文档 <a href=\"https://reactjs.org/docs/hooks-reference.html#functional-updates\" target=\"_blank\" rel=\"noopener\">这部分</a> 也特别说明了这一点:</p>\n<blockquote>\n<p>If the new state is computed using the previous state, you can pass a function to setState. The function will receive the previous value, and return an updated value.</p>\n</blockquote>\n<h4 id=\"20200115\">2020/01/15</h4>\n<p>一、<a href=\"https://vivaxyblog.github.io/2019/12/07/decode-a-png-image-with-javascript-cn.html\" target=\"_blank\" rel=\"noopener\">一步一步解码 PNG 图片</a><br>\n可以当成一份扩展阅读，讲了怎么从一张二进制 PNG 图片转成包含像素数据的 ImageData 。<br>\n之前在工作中，主要是利用 <code>canvas</code> 得到 <code>imageData</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function getImageData(url: string): Promise&lt;ImageData&gt; &#123;</span><br><span class=\"line\">  const img = document.createElement(&quot;img&quot;);</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    img.onload = () =&gt; &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        const canvas = document.createElement(&quot;canvas&quot;);</span><br><span class=\"line\">        canvas.width = img.naturalWidth;</span><br><span class=\"line\">        canvas.height = img.naturalHeight;</span><br><span class=\"line\">        const ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class=\"line\">        ctx.drawImage(img, 0, 0);</span><br><span class=\"line\">        resolve(ctx.getImageData(0, 0, canvas.width, canvas.height));</span><br><span class=\"line\">      &#125; catch (err) &#123;</span><br><span class=\"line\">        reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.onerror = err =&gt; &#123;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.crossOrigin = &quot;Anonymous&quot;;</span><br><span class=\"line\">    img.src = url;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>imageData</code> 是不能直接存进后台数据库的，我们需要进行 PNG 编码转换为二进制数据，用到的是 <a href=\"https://github.com/photopea/UPNG.js/\" target=\"_blank\" rel=\"noopener\">UPNG.js</a> 这个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UPNG from &quot;upng-js&quot;;</span><br><span class=\"line\">const buffer: ArrayBuffer = UPNG.encode(</span><br><span class=\"line\">  [imageData.buffer as ArrayBuffer],</span><br><span class=\"line\">  image.width,</span><br><span class=\"line\">  image.height,</span><br><span class=\"line\">  0</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4 id=\"20200113\">2020/01/13</h4>\n<p>一、<a href=\"https://medium.com/front-end-weekly/3-things-you-didnt-know-about-the-foreach-loop-in-js-ff02cec465b1\" target=\"_blank\" rel=\"noopener\">3 things you didn’t know about the forEach loop in JS</a><br>\n总结一下，就是在 <code>forEach</code> 中，使用 <code>return</code> 、 <code>break</code> 、 <code>continute</code> 都是无效的。 <code>return</code> 不会退出函数，<code>break</code> 和 <code>continute</code> 不允许在 <code>forEach</code> 中使用。如果需要能退出循环，使用简单的 <code>for</code> loop 即可。MDN 上已经写明：</p>\n<blockquote>\n<p>There is no way to stop or break a forEach() loop other than by throwing an exception. If you need such behavior, the forEach() method is the wrong tool.</p>\n</blockquote>\n<p>二、<a href=\"https://dev.to/prahladyeri/underscores-camelcasing-and-pascalcasing-the-three-naming-conventions-every-programmer-should-be-aware-of-3aed\" target=\"_blank\" rel=\"noopener\">under_scores, camelCase and PascalCase - The three naming conventions every programmer should be aware of</a><br>\n简单介绍了编程中三种命名规则，可以学一下正确的名词表达：<br>\n<img src=\"https://i.loli.net/2020/01/13/kAnN3GvZBiWDPRu.png\" alt=\"image.png\"><br>\n<code>camelCase</code> 大家都不陌生，就是最常见的首字母小写驼峰样式；<code>under_scores</code> 就是以下划线隔开多个小写字母，JS 中这些命名方式比较少用；<code>PascalCase</code> 就是首字母大写驼峰样式。此外，函数、变量、类、命名空间这些可以统称为 <code>tokens</code> 。</p>\n<h4 id=\"20200112\">2020/01/12</h4>\n<p>一、<a href=\"https://medium.com/dailyjs/parseint-mystery-7c4368ef7b21\" target=\"_blank\" rel=\"noopener\">Why [‘1’, ‘7’, ‘11’].map(parseInt) returns [1, NaN, 3] in Javascript</a><br>\n一篇非常有趣的文章，开篇一张图：<br>\n<img src=\"https://i.loli.net/2020/01/12/grShLvH28RDXtYM.png\" alt=\"image.png\"><br>\n出现这种结果的原因，在于 <code>map</code> 函数默认会传入三个参数：currentValue、currentIndex 以及 full array 。而对于 <code>parseInt</code> 而言，第二个参数表示基数，用此来解析数组中的每个字符串，取值是 2 ~ 36 的整数。‘1’ 以 0 为基数进行解析，0 的布尔值为 <code>false</code>，等于没有传入第二个参数，因此会以默认基数 10 进行解析，输出 1 ；‘7’ 以 1 为基数 进行解析，会输出 <code>NaN</code> ；‘11’ 以 2 为基数解析，会输出 3。</p>\n<p>二、<a href=\"https://medium.com/better-programming/the-observer-pattern-in-javascript-4f4e0b908d5e\" target=\"_blank\" rel=\"noopener\">The Power of the Observer Pattern in JavaScript</a><br>\n介绍了 Observer Patten，并用 JS 写了一份简单实现。本质就是维护一个观察者列表，每次有变化时遍历通知。</p>\n<h4 id=\"20200109\">2020/01/09</h4>\n<p>一、<a href=\"https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all/30378082\" target=\"_blank\" rel=\"noopener\">How to handle errors in Promise.all</a><br>\n简单来说就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">await Promise.all(vals.map(val =&gt; </span><br><span class=\"line\">  promise(val)</span><br><span class=\"line\">  .catch(err =&gt; &#123;</span><br><span class=\"line\">    // handle here</span><br><span class=\"line\">    return err</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">))</span><br></pre></td></tr></table></figure>\n<p>二、<a href=\"https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/\" target=\"_blank\" rel=\"noopener\">New ES2018 Features</a></p>\n<h4 id=\"20200105\">2020/01/05</h4>\n<p>今天需要对某个数值进行类型校验，避免出现 <code>NaN</code>，本来是用 <code>!typeof value === 'number'</code>，后来发现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof NaN === &apos;number&apos;</span><br></pre></td></tr></table></figure>\n<p>关于为什么是这种输出，可以看 medium 上这篇文章：<a href=\"https://javascriptrefined.io/nan-and-typeof-36cd6e2a4e43\" target=\"_blank\" rel=\"noopener\">NaN and typeof</a>。<br>\n如果需要判断某个数是否为 <code>NaN</code>，可用 <code>isNaN(value)</code> 判断。</p>\n<h4 id=\"20200104\">2020/01/04</h4>\n<p>今天在处理正则表达式时遇到这样的疑惑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;\\abc&apos;;</span><br><span class=\"line\">const reg = /\\\\abc/;</span><br><span class=\"line\">reg.test(str); // false</span><br></pre></td></tr></table></figure>\n<p>我们都知道反斜杠 <code>\\</code> 是转义的作用，如果要输出斜杠，那么必须使用 <code>\\\\</code> ；在上面的代码中，<code>reg</code> 匹配是是 <code>\\abc</code> ，为什么输出结果会是 <code>false</code> 呢？<br>\n经过查阅，发现在字符串中，’’ 也有转义的作用。如果反斜杠出现在字符的前面，那么他们就是一个整体，比如说 ‘\\n’ 表示换行，字符串 ‘\\abc’ 也涉及转义操作，由于 a 不是有效的转义符，所以就直接转成 ‘abc’ 。下面的代码可以验证这个说法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &quot;\\abc&quot;;</span><br><span class=\"line\">console.info(str.length); // 3</span><br><span class=\"line\">&quot;\\abc&quot; === &quot;abc&quot; //true</span><br></pre></td></tr></table></figure>\n<p>因此，上面的代码应该改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;\\\\abc&apos;;</span><br><span class=\"line\">const reg = /\\\\abc/;</span><br><span class=\"line\">reg.test(str); // true</span><br></pre></td></tr></table></figure>\n<h4 id=\"20200102\">2020/01/02</h4>\n<p>放大预览图片的某个部分：思路是计算 bbox 的 scale 数值，使之能填充满整个 container ；再计算原始图片的偏移量，使之只显示 bbox 部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Preview(props: &#123;</span><br><span class=\"line\">  imgSrc: string;</span><br><span class=\"line\">  imgSize: &#123; width: number; height: number &#125;;</span><br><span class=\"line\">  box: &#123;</span><br><span class=\"line\">    x: number;</span><br><span class=\"line\">    y: number;</span><br><span class=\"line\">    width: number;</span><br><span class=\"line\">    height: number;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  const [containerSize] = useState(&#123; width: 350, height: 400 &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  const scale = Math.min(</span><br><span class=\"line\">    containerSize.width / props.box.width,</span><br><span class=\"line\">    containerSize.height / props.box.height</span><br><span class=\"line\">  );</span><br><span class=\"line\">  const boxCenter = &#123;</span><br><span class=\"line\">    x: props.box.x + props.box.width / 2,</span><br><span class=\"line\">    y: props.box.y + props.box.height / 2</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  const containerCenter = &#123;</span><br><span class=\"line\">    x: containerSize.width / 2,</span><br><span class=\"line\">    y: containerSize.height / 2</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  const tr = &#123;</span><br><span class=\"line\">    x: containerCenter.x - boxCenter.x * scale,</span><br><span class=\"line\">    y: containerCenter.y - boxCenter.y * scale</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div style=&#123;&#123; position: &quot;relative&quot;, ...containerSize, overflow: &quot;hidden&quot; &#125;&#125;&gt;</span><br><span class=\"line\">      &lt;img</span><br><span class=\"line\">        src=&#123;props.imgSrc&#125;</span><br><span class=\"line\">        style=&#123;&#123;</span><br><span class=\"line\">          ...props.imgSize,</span><br><span class=\"line\">          objectFit: &quot;contain&quot;,</span><br><span class=\"line\">          position: &quot;absolute&quot;,</span><br><span class=\"line\">          left: 0,</span><br><span class=\"line\">          top: 0,</span><br><span class=\"line\">          transform: `translate($&#123;tr.x&#125;px, $&#123;tr.y&#125;px) scale($&#123;scale&#125;)`,</span><br><span class=\"line\">          transformOrigin: &quot;top left&quot;,</span><br><span class=\"line\">          transition: &quot;all 0.3s&quot;</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4>About</h4>\n<p>📅 2020 年 1 月的零散学习记录。</p>\n<p>新年快乐！希望新的一年能坚持记笔记！</p>\n<h4>2020/01/29</h4>\n<p>今日阅读：<a href=\"https://itnext.io/heres-why-mapping-a-constructed-array-doesn-t-work-in-javascript-f1195138615a\" target=\"_blank\" rel=\"noopener\">Here’s Why Mapping a Constructed Array in JavaScript Doesn’t Work</a><br>\n当我们想要生成一个 0 ~ 99 的数组时，除了最基础的遍历赋值，还可以利用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Array\" target=\"_blank\" rel=\"noopener\">Array()</a> 方法。<br>\n但使用 <code>Array.map()</code> ，并不会正确赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = Array(100).map((_, i) =&gt; i);</span><br><span class=\"line\">console.log(arr[0] === undefined);  // true</span><br></pre></td></tr></table></figure>\n<p>造成这个问题的原因是，在 JS 中 数组其实是一个对象，索引是 <code>key</code> ，数组元素是 <code>value</code> ，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class=\"line\">=&gt; </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  0: &apos;a&apos;,</span><br><span class=\"line\">  1: &apos;b&apos;,</span><br><span class=\"line\">  2: &apos;c&apos;,</span><br><span class=\"line\">  length: 3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当使用 <code>Array()</code> 构造函数时，只会生成一个“真空”对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  //no index keys!</span><br><span class=\"line\">  length: 100</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于对象上并不存在 <code>key</code> ，<code>map</code> 函数并不会进行遍历，<code>reduce</code> 、<code>filter</code> 、<code>forEach</code> 等迭代函数也有同样的表现。解决办法是使用展开操作符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [...Array(100)].map((_, i) =&gt; i);</span><br><span class=\"line\">console.log(arr[0]); // 0</span><br></pre></td></tr></table></figure>\n<h4>2020/01/28</h4>\n<p>今日阅读：<a href=\"https://medium.com/javascript-in-plain-english/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089\" target=\"_blank\" rel=\"noopener\">How to Deep Copy Objects and Arrays in JavaScript</a><br>\n如果数组/对象中都是 <code>primitive value</code> ，要实现深复制，常用的有下面三种方法：</p>\n<ol>\n<li>spread operator …</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const array = [&apos;😉&apos;,&apos;😊&apos;,&apos;😇&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">const copyWithEquals = array // Changes to array will change copyWithEquals</span><br><span class=\"line\">console.log(copyWithEquals === array) // true (The assignment operator did not make a copy)</span><br><span class=\"line\"></span><br><span class=\"line\">const copyWithSpread = [...array] // Changes to array will not change copyWithSpread</span><br><span class=\"line\">console.log(copyWithSpread === array) // false (The spread operator made a shallow copy)</span><br><span class=\"line\"></span><br><span class=\"line\">array[0] = &apos;😡&apos; // Whoops, a bug</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(...array) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithEquals) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithSpread) // 😉 😊 😇</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>.slice()</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const array = [&apos;😉&apos;,&apos;😊&apos;,&apos;😇&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">const copyWithEquals = array // Changes to array will change copyWithEquals</span><br><span class=\"line\">console.log(copyWithEquals === array) // true (The assignment operator did not make a copy)</span><br><span class=\"line\"></span><br><span class=\"line\">const copyWithSlice = array.slice() // Changes to array will not change copyWithSlice</span><br><span class=\"line\">console.log(copyWithSlice === array) // false (Using .slice() made a shallow copy of the array)</span><br><span class=\"line\"></span><br><span class=\"line\">array[0] = &apos;😡&apos; // Whoops, a bug</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(...array) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithEquals) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithSlice) // 😉 😊 😇</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>.assign()</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const array = [&apos;😉&apos;,&apos;😊&apos;,&apos;😇&apos;]</span><br><span class=\"line\"></span><br><span class=\"line\">const copyWithEquals = array // Changes to array will change copyWithEquals</span><br><span class=\"line\">const copyWithAssign = [] // Changes to array will not change copyWithAssign</span><br><span class=\"line\">Object.assign(copyWithAssign, array) // Object.assign(target, source)</span><br><span class=\"line\"></span><br><span class=\"line\">array[0] = &apos;😡&apos; // Whoops, a bug</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(...array) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithEquals) // 😡 😊 😇</span><br><span class=\"line\">console.log(...copyWithAssign) // 😉 😊 😇</span><br></pre></td></tr></table></figure>\n<p>如果数组中的元素也是数组/对象，上述方法只能实现第一层次但深复制，没法对元素也进行深复制。作者提供了5种方法：</p>\n<ol>\n<li><a href=\"https://lodash.com/\" target=\"_blank\" rel=\"noopener\">lodash</a><br>\n<code>lodash</code> 提供了 <code>_.clone()</code> 以及 <code>_.cloneDeep()</code> 两个方法，第一个方法实现的是第一层面的深复制，第二个方法可以实现完全的深复制。</li>\n<li><a href=\"https://ramdajs.com/\" target=\"_blank\" rel=\"noopener\">Ramda</a><br>\n提供了 <code>R.clone()</code> 方法实现完全的深复制，相当于 <code>lodash.cloneDeep()</code> 。</li>\n<li>custom function<br>\n可以自己实现一个深复制函数，基本思想是判断输入是否为数组/对象，如果是则继续逐层遍历赋值，否则返回原始值。还需考虑值为 <code>null</code> 的特殊情况，因为 <code>typeof null = &quot;object&quot;</code></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const deepCopyFunction = inObject =&gt; &#123;</span><br><span class=\"line\">  let outObject, value, key;</span><br><span class=\"line\"></span><br><span class=\"line\">  if(typeof inObject !== &quot;object&quot; || inObject === null) &#123;</span><br><span class=\"line\">    return inObject;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  outObject = Array.isArray(inObject) ? [] : &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  for(key in inObject) &#123;</span><br><span class=\"line\">    value = inObject[key];</span><br><span class=\"line\"></span><br><span class=\"line\">    outObject[key] = (typeof value === &quot;object&quot; &amp;&amp; value !== null) ? deepCopyFunction(value) : value</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return outObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><code>JSON.parse(JSON.stringify(object))</code><br>\n该方法对元素有一定的要求，详见 stackoverflow 上<a href=\"https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/122704#122704\" target=\"_blank\" rel=\"noopener\">这个回答</a>。总结而言，如果元素只是普通的数组对象，可以使用这个方法。</li>\n<li><a href=\"https://www.npmjs.com/package/rfdc\" target=\"_blank\" rel=\"noopener\">rfdc</a><br>\n作者想要推广的一个库，优点是速度很快。</li>\n</ol>\n<h4>2020/01/17</h4>\n<p><a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types\" target=\"_blank\" rel=\"noopener\">TypeScript: Conditional Types</a><br>\n考虑以下场景：我们有一个获取资源的接口，根据资源类型返回不同的数据类型的数据，代码大致如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getResources&lt;T&gt;(type: &quot;tasks&quot;|&quot;jobs&quot;|&quot;queues&quot;) &#123;</span><br><span class=\"line\">  return axios.get&lt;T&gt;(&apos;http://.......&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// use</span><br><span class=\"line\">const tasks = await getResources&lt;TaskList&gt;(&quot;tasks&quot;)</span><br><span class=\"line\">const jobs = await getResources&lt;JobList&gt;(&quot;jobs&quot;)</span><br></pre></td></tr></table></figure>\n<p>如果我们想要并行发送请求，可以使用 <code>Promise.all()</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const [tasks, jobs] = await Promise.all([&quot;tasks&quot;,&quot;jobs&quot;].map(type =&gt; &#123;</span><br><span class=\"line\">  return getResources&lt;TaskList|JobList&gt;(type)</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n<p>上述代码引起的问题是，<code>tasks</code> 和 <code>jobs</code> 的类型会是 <code>TaskList|JobList</code> ，如果我们之后要访问他们的属性，避免不了 <code>as TaskList</code> ，<code>as JobList</code> 这种写法。优化做法是，使用 ts 的 conditional types，可以从输入类型推断出输出类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export type ResType = &quot;tasks&quot; | &quot;jobs&quot; | &quot;queues&quot; ;</span><br><span class=\"line\">export type ResData&lt;T extends ResType&gt; = </span><br><span class=\"line\">  T extends &quot;tasks&quot; ? TaskList: </span><br><span class=\"line\">  T extends &quot;jobs&quot;  ? JobList : </span><br><span class=\"line\">  T extends &quot;queues&quot; ? QueueList :</span><br><span class=\"line\">  never;</span><br><span class=\"line\"></span><br><span class=\"line\">getResources&lt;T extends ResType&gt;(type: T) &#123;</span><br><span class=\"line\">  return axios.get&lt;ResData&lt;T&gt;&gt;(&apos;http://.......&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，在调用 <code>getResources</code> 就不用显式传入 <code>T</code> 。接下来，为了解决类型在 <code>Promise.all()</code> 用 <code>map</code> 可能推断不出来的问题，可以使用 tuple ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// or just `getResources(&quot;tasks&quot;)` if RV of getResources is already a promise</span><br><span class=\"line\">const taskPromise = Promise.resolve(getResources(&quot;tasks&quot;));</span><br><span class=\"line\">const jobPromise = Promise.resolve(getResources(&quot;jobs&quot;));</span><br><span class=\"line\">const [tasks, jobs] = await Promise.all([taskPromise,jobPromise])</span><br></pre></td></tr></table></figure>\n<p>一顿操作之后，我们就可以准确得到 <code>tasks</code> 和 <code>jobs</code> 的类型了。😎<br>\n扩展阅读：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\" target=\"_blank\" rel=\"noopener\">Promise.resolve()</a> 、 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\" target=\"_blank\" rel=\"noopener\">Promise.all()</a></p>\n<h4>2020/01/16</h4>\n<p>今日踩坑记录。考虑以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const [state, setState] = useState&lt;string[]&gt;([]);</span><br><span class=\"line\"></span><br><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  const loadData = async () =&gt; &#123;</span><br><span class=\"line\">    const lists = [&quot;list1&quot;, &quot;list2&quot;, &quot;list3&quot;];</span><br><span class=\"line\">    for(const list of lists) &#123;</span><br><span class=\"line\">      const &#123;data&#125; = await thisIsPromise(list);</span><br><span class=\"line\">      setState([...state, ...data])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  // call async function </span><br><span class=\"line\">  loadData(); </span><br><span class=\"line\">&#125;,[])</span><br></pre></td></tr></table></figure>\n<p>运行上面的代码，<code>state</code> 并不会返回所有 <code>list</code> 的集合。原因是 <code>setState</code> 是异步更新的，每次循环调用 <code>setState([...state, ...data])</code> 时， <code>state</code> 都是初始值，也就是空数组。如果我们想要得到上一个 <code>state</code> 的值，只能使用下面这种写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const [state, setState] = useState&lt;string[]&gt;([]);</span><br><span class=\"line\"></span><br><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  const loadData = async () =&gt; &#123;</span><br><span class=\"line\">    const lists = [&quot;list1&quot;, &quot;list2&quot;, &quot;list3&quot;];</span><br><span class=\"line\">    for(const list of lists) &#123;</span><br><span class=\"line\">      const &#123;data&#125; = await thisIsPromise(list);</span><br><span class=\"line\">      // HERE!</span><br><span class=\"line\">      setState(prev =&gt; [...prev,...data])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  // call async function </span><br><span class=\"line\">  loadData(); </span><br><span class=\"line\">&#125;,[])</span><br></pre></td></tr></table></figure>\n<p>React 文档 <a href=\"https://reactjs.org/docs/hooks-reference.html#functional-updates\" target=\"_blank\" rel=\"noopener\">这部分</a> 也特别说明了这一点:</p>\n<blockquote>\n<p>If the new state is computed using the previous state, you can pass a function to setState. The function will receive the previous value, and return an updated value.</p>\n</blockquote>\n<h4>2020/01/15</h4>\n<p>一、<a href=\"https://vivaxyblog.github.io/2019/12/07/decode-a-png-image-with-javascript-cn.html\" target=\"_blank\" rel=\"noopener\">一步一步解码 PNG 图片</a><br>\n可以当成一份扩展阅读，讲了怎么从一张二进制 PNG 图片转成包含像素数据的 ImageData 。<br>\n之前在工作中，主要是利用 <code>canvas</code> 得到 <code>imageData</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function getImageData(url: string): Promise&lt;ImageData&gt; &#123;</span><br><span class=\"line\">  const img = document.createElement(&quot;img&quot;);</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    img.onload = () =&gt; &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        const canvas = document.createElement(&quot;canvas&quot;);</span><br><span class=\"line\">        canvas.width = img.naturalWidth;</span><br><span class=\"line\">        canvas.height = img.naturalHeight;</span><br><span class=\"line\">        const ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class=\"line\">        ctx.drawImage(img, 0, 0);</span><br><span class=\"line\">        resolve(ctx.getImageData(0, 0, canvas.width, canvas.height));</span><br><span class=\"line\">      &#125; catch (err) &#123;</span><br><span class=\"line\">        reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.onerror = err =&gt; &#123;</span><br><span class=\"line\">      reject(err);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.crossOrigin = &quot;Anonymous&quot;;</span><br><span class=\"line\">    img.src = url;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>imageData</code> 是不能直接存进后台数据库的，我们需要进行 PNG 编码转换为二进制数据，用到的是 <a href=\"https://github.com/photopea/UPNG.js/\" target=\"_blank\" rel=\"noopener\">UPNG.js</a> 这个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UPNG from &quot;upng-js&quot;;</span><br><span class=\"line\">const buffer: ArrayBuffer = UPNG.encode(</span><br><span class=\"line\">  [imageData.buffer as ArrayBuffer],</span><br><span class=\"line\">  image.width,</span><br><span class=\"line\">  image.height,</span><br><span class=\"line\">  0</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h4>2020/01/13</h4>\n<p>一、<a href=\"https://medium.com/front-end-weekly/3-things-you-didnt-know-about-the-foreach-loop-in-js-ff02cec465b1\" target=\"_blank\" rel=\"noopener\">3 things you didn’t know about the forEach loop in JS</a><br>\n总结一下，就是在 <code>forEach</code> 中，使用 <code>return</code> 、 <code>break</code> 、 <code>continute</code> 都是无效的。 <code>return</code> 不会退出函数，<code>break</code> 和 <code>continute</code> 不允许在 <code>forEach</code> 中使用。如果需要能退出循环，使用简单的 <code>for</code> loop 即可。MDN 上已经写明：</p>\n<blockquote>\n<p>There is no way to stop or break a forEach() loop other than by throwing an exception. If you need such behavior, the forEach() method is the wrong tool.</p>\n</blockquote>\n<p>二、<a href=\"https://dev.to/prahladyeri/underscores-camelcasing-and-pascalcasing-the-three-naming-conventions-every-programmer-should-be-aware-of-3aed\" target=\"_blank\" rel=\"noopener\">under_scores, camelCase and PascalCase - The three naming conventions every programmer should be aware of</a><br>\n简单介绍了编程中三种命名规则，可以学一下正确的名词表达：<br>\n<img src=\"https://i.loli.net/2020/01/13/kAnN3GvZBiWDPRu.png\" alt=\"image.png\"><br>\n<code>camelCase</code> 大家都不陌生，就是最常见的首字母小写驼峰样式；<code>under_scores</code> 就是以下划线隔开多个小写字母，JS 中这些命名方式比较少用；<code>PascalCase</code> 就是首字母大写驼峰样式。此外，函数、变量、类、命名空间这些可以统称为 <code>tokens</code> 。</p>\n<h4>2020/01/12</h4>\n<p>一、<a href=\"https://medium.com/dailyjs/parseint-mystery-7c4368ef7b21\" target=\"_blank\" rel=\"noopener\">Why [‘1’, ‘7’, ‘11’].map(parseInt) returns [1, NaN, 3] in Javascript</a><br>\n一篇非常有趣的文章，开篇一张图：<br>\n<img src=\"https://i.loli.net/2020/01/12/grShLvH28RDXtYM.png\" alt=\"image.png\"><br>\n出现这种结果的原因，在于 <code>map</code> 函数默认会传入三个参数：currentValue、currentIndex 以及 full array 。而对于 <code>parseInt</code> 而言，第二个参数表示基数，用此来解析数组中的每个字符串，取值是 2 ~ 36 的整数。‘1’ 以 0 为基数进行解析，0 的布尔值为 <code>false</code>，等于没有传入第二个参数，因此会以默认基数 10 进行解析，输出 1 ；‘7’ 以 1 为基数 进行解析，会输出 <code>NaN</code> ；‘11’ 以 2 为基数解析，会输出 3。</p>\n<p>二、<a href=\"https://medium.com/better-programming/the-observer-pattern-in-javascript-4f4e0b908d5e\" target=\"_blank\" rel=\"noopener\">The Power of the Observer Pattern in JavaScript</a><br>\n介绍了 Observer Patten，并用 JS 写了一份简单实现。本质就是维护一个观察者列表，每次有变化时遍历通知。</p>\n<h4>2020/01/09</h4>\n<p>一、<a href=\"https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all/30378082\" target=\"_blank\" rel=\"noopener\">How to handle errors in Promise.all</a><br>\n简单来说就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">await Promise.all(vals.map(val =&gt; </span><br><span class=\"line\">  promise(val)</span><br><span class=\"line\">  .catch(err =&gt; &#123;</span><br><span class=\"line\">    // handle here</span><br><span class=\"line\">    return err</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">))</span><br></pre></td></tr></table></figure>\n<p>二、<a href=\"https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/\" target=\"_blank\" rel=\"noopener\">New ES2018 Features</a></p>\n<h4>2020/01/05</h4>\n<p>今天需要对某个数值进行类型校验，避免出现 <code>NaN</code>，本来是用 <code>!typeof value === 'number'</code>，后来发现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof NaN === &apos;number&apos;</span><br></pre></td></tr></table></figure>\n<p>关于为什么是这种输出，可以看 medium 上这篇文章：<a href=\"https://javascriptrefined.io/nan-and-typeof-36cd6e2a4e43\" target=\"_blank\" rel=\"noopener\">NaN and typeof</a>。<br>\n如果需要判断某个数是否为 <code>NaN</code>，可用 <code>isNaN(value)</code> 判断。</p>\n<h4>2020/01/04</h4>\n<p>今天在处理正则表达式时遇到这样的疑惑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;\\abc&apos;;</span><br><span class=\"line\">const reg = /\\\\abc/;</span><br><span class=\"line\">reg.test(str); // false</span><br></pre></td></tr></table></figure>\n<p>我们都知道反斜杠 <code>\\</code> 是转义的作用，如果要输出斜杠，那么必须使用 <code>\\\\</code> ；在上面的代码中，<code>reg</code> 匹配是是 <code>\\abc</code> ，为什么输出结果会是 <code>false</code> 呢？<br>\n经过查阅，发现在字符串中，’’ 也有转义的作用。如果反斜杠出现在字符的前面，那么他们就是一个整体，比如说 ‘\\n’ 表示换行，字符串 ‘\\abc’ 也涉及转义操作，由于 a 不是有效的转义符，所以就直接转成 ‘abc’ 。下面的代码可以验证这个说法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &quot;\\abc&quot;;</span><br><span class=\"line\">console.info(str.length); // 3</span><br><span class=\"line\">&quot;\\abc&quot; === &quot;abc&quot; //true</span><br></pre></td></tr></table></figure>\n<p>因此，上面的代码应该改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;\\\\abc&apos;;</span><br><span class=\"line\">const reg = /\\\\abc/;</span><br><span class=\"line\">reg.test(str); // true</span><br></pre></td></tr></table></figure>\n<h4>2020/01/02</h4>\n<p>放大预览图片的某个部分：思路是计算 bbox 的 scale 数值，使之能填充满整个 container ；再计算原始图片的偏移量，使之只显示 bbox 部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Preview(props: &#123;</span><br><span class=\"line\">  imgSrc: string;</span><br><span class=\"line\">  imgSize: &#123; width: number; height: number &#125;;</span><br><span class=\"line\">  box: &#123;</span><br><span class=\"line\">    x: number;</span><br><span class=\"line\">    y: number;</span><br><span class=\"line\">    width: number;</span><br><span class=\"line\">    height: number;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  const [containerSize] = useState(&#123; width: 350, height: 400 &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  const scale = Math.min(</span><br><span class=\"line\">    containerSize.width / props.box.width,</span><br><span class=\"line\">    containerSize.height / props.box.height</span><br><span class=\"line\">  );</span><br><span class=\"line\">  const boxCenter = &#123;</span><br><span class=\"line\">    x: props.box.x + props.box.width / 2,</span><br><span class=\"line\">    y: props.box.y + props.box.height / 2</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  const containerCenter = &#123;</span><br><span class=\"line\">    x: containerSize.width / 2,</span><br><span class=\"line\">    y: containerSize.height / 2</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  const tr = &#123;</span><br><span class=\"line\">    x: containerCenter.x - boxCenter.x * scale,</span><br><span class=\"line\">    y: containerCenter.y - boxCenter.y * scale</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div style=&#123;&#123; position: &quot;relative&quot;, ...containerSize, overflow: &quot;hidden&quot; &#125;&#125;&gt;</span><br><span class=\"line\">      &lt;img</span><br><span class=\"line\">        src=&#123;props.imgSrc&#125;</span><br><span class=\"line\">        style=&#123;&#123;</span><br><span class=\"line\">          ...props.imgSize,</span><br><span class=\"line\">          objectFit: &quot;contain&quot;,</span><br><span class=\"line\">          position: &quot;absolute&quot;,</span><br><span class=\"line\">          left: 0,</span><br><span class=\"line\">          top: 0,</span><br><span class=\"line\">          transform: `translate($&#123;tr.x&#125;px, $&#123;tr.y&#125;px) scale($&#123;scale&#125;)`,</span><br><span class=\"line\">          transformOrigin: &quot;top left&quot;,</span><br><span class=\"line\">          transition: &quot;all 0.3s&quot;</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"FrontEnd Daily Learning [2020.02]","catalog":true,"date":"2020-02-21T02:29:52.000Z","subtitle":null,"header-img":null,"_content":"\n#### About\n\n📅 2020 年 2 月的零散学习记录。\n\n动笔时发现已经是2月21号了，惭愧啊惭愧。\n\n#### 2020/02/27\n今天在处理函数式组件时遇到了一个问题，将某个函数作为回调函数传到子组件，在回调函数中打印 state ，只能取到初始值，没有打印出最新结果。排查了很久，后来发现在子组件中，该函数用于注册事件监听函数，因此事件监听绑定的函数，是第一次渲染时传进去的，后续并不会更新，永远只能获取到初始值。\n不考虑父子组件，用最简单的例子复现这个问题：\n```\nconst App:React.FC = () => {\n  const [state,setState] = useState(0);\n\n  useEffect(() => {\n    window.addEventListener(\"wheel\", handleWheelChange);\n    return () => {\n      window.removeEventListener(\"wheel\", handleWheelChange);\n    }\n  },[]);\n\n  const handleWheelChange = () => {\n    // always print 0\n    console.log(state)\n  };\n  \n  return <></>\n} \n```\n如果要解决这个问题，可以使用 ref ，取值时通过 `ref.current` 取：\n```\nconst App:React.FC = () => {\n  const [state,setState] = useState(0);\n  // create ref\n  const stateRef = useRef(state);\n\n  // update ref.current when state changes\n  useEffect(() => {\n    ref.current = state;\n  },[state])\n\n  useEffect(() => {\n    window.addEventListener(\"wheel\", handleWheelChange);\n    return () => {\n      window.removeEventListener(\"wheel\", handleWheelChange);\n    }\n  },[]);\n\n  const handleWheelChange = () => {\n    // access newest state correctly\n    console.log(ref.current)\n  };\n  \n  return <></>\n} \n```\n上述代码只是一种思路的表达，在实际项目中，直接使用 `useRef` 初始化变量就好了，没有必要先 `useState` ，再对 state `useRef` 。但有时使用了 `useReducer` ，如果只需要用到其中某个变量，就可以用上述代码中提到的方法。\n第二种方法是通过调用 `setState` ，传入函数来取到最新的 state ，如：\n```\n...\nconst handleWheelChange = () => {\n    setState(prev => {\n      // prev is the newest state, do anything you need\n      // remenber to return value\n      return prev;\n    })\n  };\n...\n```\n\n#### 2020/02/24\n今日阅读：[How to use throttle or debounce with React Hook?](https://stackoverflow.com/questions/54666401/how-to-use-throttle-or-debounce-with-react-hook)\n在使用函数式组件时，如果我们需要引入 lodash 的 `throttle` 或 `debounce` ，很容易写出如下错误代码：\n```\nconst ExComp:React.FC = () => {\n  ....\n  // call it somewhere\n  const throttle = lodash.throttle((value) => {\n    // do something\n  },2000)\n  ...\n  return <></>\n}\n```\n上述代码中，在函数式组件中引入了一个 throttle 函数（底层实现是 `setTimeout`），然而对于函数式组件而言，每一次 rerender 都会重新初始化变量，所以 throttle 并不会生效。解决这个问题可以使用 `useRef` 或是 `useCallback` 。如：\n```\nconst App = () => {\n  const [value, setValue] = useState(0)；\n\n  const throttled = useRef(\n    throttle((newValue) => console.log(newValue), 1000)\n  )\n  useEffect(() => throttled.current(value), [value])\n\n  // or\n  // const throttled = useCallback(\n  //  throttle((newValue) => console.log(newValue), 1000),\n  //  []\n  // );\n  // useEffect(() => throttled(value), [value])\n\n  return (\n    <button onClick={() => setValue(value + 1)}>{value}</button>\n  )\n```\n调用时直接使用 `throttled.current()` （或 `throttled()` ）即可。注意如果在 throttle 函数中需要用到函数外的 state 值，只能取到初始值（闭包），这种时候只能将所需参数作为 params 传进去。或是将 throttle 函数移到组件外。\n\n#### 2020/02/21\n在使用 react hooks 时，如果需要在组件中实例一个类（如 `new stroe()`）；为了让该变量变成一个 state ，而不是每次重新渲染时都会重新初始化，我们会使用 `useState` ：\n```\nimport { useState } from \"react\"\n\nconst XXX:React.FC = () => {\n  const [store] = useState(new Store());\n\n  return <></>;\n}\n```\n引入惰性初始 state ，传入 function ，关于惰性初始 state 可以参考文档 [Lazy initial state](https://reactjs.org/docs/hooks-reference.html#lazy-initial-state) 部分，更详细的解释可以参考 StackOverflow 上这个 [回答](https://stackoverflow.com/a/58539958) ，具体而言，传入 function 时只会在第一次渲染时调用；如果不引入惰性初始 state ，虽然 initialState 只会在第一次渲染时使用，但传入 `useState` 的函数还是会进行初始化和调用。\n```\nimport { useState } from \"react\"\n\nconst XXX:React.FC = () => {\n  const [store] = useState(() => new Store());\n\n  return <></>;\n}\n```\n这样带来的问题是，如果 store 中的成员更新了，并不会触发重新渲染。为了解决这个问题，我们可以直接引入 Mobx ，参考 mobx-react-lite 中 [Lazy initialization](https://github.com/mobxjs/mobx-react-lite#lazy-initialization) 这一节：\n```\nimport { observer } from \"mobx-react-lite\"\nimport { observable } from \"mobx\"\nimport { useState } from \"react\"\n\nconst XXX:React.FC = observer(() => {\n  const [store] = useState(() => observable(new Store()));\n\n  return <></>;\n})\n```","source":"_posts/FrontEnd-Daily-Learning-2020-02.md","raw":"---\ntitle: FrontEnd Daily Learning [2020.02]\ncatalog: true\ndate: 2020-02-21 10:29:52\nsubtitle:\nheader-img:\ntags: FE\n---\n\n#### About\n\n📅 2020 年 2 月的零散学习记录。\n\n动笔时发现已经是2月21号了，惭愧啊惭愧。\n\n#### 2020/02/27\n今天在处理函数式组件时遇到了一个问题，将某个函数作为回调函数传到子组件，在回调函数中打印 state ，只能取到初始值，没有打印出最新结果。排查了很久，后来发现在子组件中，该函数用于注册事件监听函数，因此事件监听绑定的函数，是第一次渲染时传进去的，后续并不会更新，永远只能获取到初始值。\n不考虑父子组件，用最简单的例子复现这个问题：\n```\nconst App:React.FC = () => {\n  const [state,setState] = useState(0);\n\n  useEffect(() => {\n    window.addEventListener(\"wheel\", handleWheelChange);\n    return () => {\n      window.removeEventListener(\"wheel\", handleWheelChange);\n    }\n  },[]);\n\n  const handleWheelChange = () => {\n    // always print 0\n    console.log(state)\n  };\n  \n  return <></>\n} \n```\n如果要解决这个问题，可以使用 ref ，取值时通过 `ref.current` 取：\n```\nconst App:React.FC = () => {\n  const [state,setState] = useState(0);\n  // create ref\n  const stateRef = useRef(state);\n\n  // update ref.current when state changes\n  useEffect(() => {\n    ref.current = state;\n  },[state])\n\n  useEffect(() => {\n    window.addEventListener(\"wheel\", handleWheelChange);\n    return () => {\n      window.removeEventListener(\"wheel\", handleWheelChange);\n    }\n  },[]);\n\n  const handleWheelChange = () => {\n    // access newest state correctly\n    console.log(ref.current)\n  };\n  \n  return <></>\n} \n```\n上述代码只是一种思路的表达，在实际项目中，直接使用 `useRef` 初始化变量就好了，没有必要先 `useState` ，再对 state `useRef` 。但有时使用了 `useReducer` ，如果只需要用到其中某个变量，就可以用上述代码中提到的方法。\n第二种方法是通过调用 `setState` ，传入函数来取到最新的 state ，如：\n```\n...\nconst handleWheelChange = () => {\n    setState(prev => {\n      // prev is the newest state, do anything you need\n      // remenber to return value\n      return prev;\n    })\n  };\n...\n```\n\n#### 2020/02/24\n今日阅读：[How to use throttle or debounce with React Hook?](https://stackoverflow.com/questions/54666401/how-to-use-throttle-or-debounce-with-react-hook)\n在使用函数式组件时，如果我们需要引入 lodash 的 `throttle` 或 `debounce` ，很容易写出如下错误代码：\n```\nconst ExComp:React.FC = () => {\n  ....\n  // call it somewhere\n  const throttle = lodash.throttle((value) => {\n    // do something\n  },2000)\n  ...\n  return <></>\n}\n```\n上述代码中，在函数式组件中引入了一个 throttle 函数（底层实现是 `setTimeout`），然而对于函数式组件而言，每一次 rerender 都会重新初始化变量，所以 throttle 并不会生效。解决这个问题可以使用 `useRef` 或是 `useCallback` 。如：\n```\nconst App = () => {\n  const [value, setValue] = useState(0)；\n\n  const throttled = useRef(\n    throttle((newValue) => console.log(newValue), 1000)\n  )\n  useEffect(() => throttled.current(value), [value])\n\n  // or\n  // const throttled = useCallback(\n  //  throttle((newValue) => console.log(newValue), 1000),\n  //  []\n  // );\n  // useEffect(() => throttled(value), [value])\n\n  return (\n    <button onClick={() => setValue(value + 1)}>{value}</button>\n  )\n```\n调用时直接使用 `throttled.current()` （或 `throttled()` ）即可。注意如果在 throttle 函数中需要用到函数外的 state 值，只能取到初始值（闭包），这种时候只能将所需参数作为 params 传进去。或是将 throttle 函数移到组件外。\n\n#### 2020/02/21\n在使用 react hooks 时，如果需要在组件中实例一个类（如 `new stroe()`）；为了让该变量变成一个 state ，而不是每次重新渲染时都会重新初始化，我们会使用 `useState` ：\n```\nimport { useState } from \"react\"\n\nconst XXX:React.FC = () => {\n  const [store] = useState(new Store());\n\n  return <></>;\n}\n```\n引入惰性初始 state ，传入 function ，关于惰性初始 state 可以参考文档 [Lazy initial state](https://reactjs.org/docs/hooks-reference.html#lazy-initial-state) 部分，更详细的解释可以参考 StackOverflow 上这个 [回答](https://stackoverflow.com/a/58539958) ，具体而言，传入 function 时只会在第一次渲染时调用；如果不引入惰性初始 state ，虽然 initialState 只会在第一次渲染时使用，但传入 `useState` 的函数还是会进行初始化和调用。\n```\nimport { useState } from \"react\"\n\nconst XXX:React.FC = () => {\n  const [store] = useState(() => new Store());\n\n  return <></>;\n}\n```\n这样带来的问题是，如果 store 中的成员更新了，并不会触发重新渲染。为了解决这个问题，我们可以直接引入 Mobx ，参考 mobx-react-lite 中 [Lazy initialization](https://github.com/mobxjs/mobx-react-lite#lazy-initialization) 这一节：\n```\nimport { observer } from \"mobx-react-lite\"\nimport { observable } from \"mobx\"\nimport { useState } from \"react\"\n\nconst XXX:React.FC = observer(() => {\n  const [store] = useState(() => observable(new Store()));\n\n  return <></>;\n})\n```","slug":"FrontEnd-Daily-Learning-2020-02","published":1,"updated":"2020-03-04T02:51:22.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7ef1vgy0003qsueq3hxi5vd","content":"<h4 id=\"about\">About</h4>\n<p>📅 2020 年 2 月的零散学习记录。</p>\n<p>动笔时发现已经是2月21号了，惭愧啊惭愧。</p>\n<h4 id=\"20200227\">2020/02/27</h4>\n<p>今天在处理函数式组件时遇到了一个问题，将某个函数作为回调函数传到子组件，在回调函数中打印 state ，只能取到初始值，没有打印出最新结果。排查了很久，后来发现在子组件中，该函数用于注册事件监听函数，因此事件监听绑定的函数，是第一次渲染时传进去的，后续并不会更新，永远只能获取到初始值。<br>\n不考虑父子组件，用最简单的例子复现这个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App:React.FC = () =&gt; &#123;</span><br><span class=\"line\">  const [state,setState] = useState(0);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    window.addEventListener(&quot;wheel&quot;, handleWheelChange);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      window.removeEventListener(&quot;wheel&quot;, handleWheelChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,[]);</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleWheelChange = () =&gt; &#123;</span><br><span class=\"line\">    // always print 0</span><br><span class=\"line\">    console.log(state)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要解决这个问题，可以使用 ref ，取值时通过 <code>ref.current</code> 取：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App:React.FC = () =&gt; &#123;</span><br><span class=\"line\">  const [state,setState] = useState(0);</span><br><span class=\"line\">  // create ref</span><br><span class=\"line\">  const stateRef = useRef(state);</span><br><span class=\"line\"></span><br><span class=\"line\">  // update ref.current when state changes</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ref.current = state;</span><br><span class=\"line\">  &#125;,[state])</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    window.addEventListener(&quot;wheel&quot;, handleWheelChange);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      window.removeEventListener(&quot;wheel&quot;, handleWheelChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,[]);</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleWheelChange = () =&gt; &#123;</span><br><span class=\"line\">    // access newest state correctly</span><br><span class=\"line\">    console.log(ref.current)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码只是一种思路的表达，在实际项目中，直接使用 <code>useRef</code> 初始化变量就好了，没有必要先 <code>useState</code> ，再对 state <code>useRef</code> 。但有时使用了 <code>useReducer</code> ，如果只需要用到其中某个变量，就可以用上述代码中提到的方法。<br>\n第二种方法是通过调用 <code>setState</code> ，传入函数来取到最新的 state ，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">const handleWheelChange = () =&gt; &#123;</span><br><span class=\"line\">    setState(prev =&gt; &#123;</span><br><span class=\"line\">      // prev is the newest state, do anything you need</span><br><span class=\"line\">      // remenber to return value</span><br><span class=\"line\">      return prev;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h4 id=\"20200224\">2020/02/24</h4>\n<p>今日阅读：<a href=\"https://stackoverflow.com/questions/54666401/how-to-use-throttle-or-debounce-with-react-hook\" target=\"_blank\" rel=\"noopener\">How to use throttle or debounce with React Hook?</a><br>\n在使用函数式组件时，如果我们需要引入 lodash 的 <code>throttle</code> 或 <code>debounce</code> ，很容易写出如下错误代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ExComp:React.FC = () =&gt; &#123;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">  // call it somewhere</span><br><span class=\"line\">  const throttle = lodash.throttle((value) =&gt; &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">  &#125;,2000)</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，在函数式组件中引入了一个 throttle 函数（底层实现是 <code>setTimeout</code>），然而对于函数式组件而言，每一次 rerender 都会重新初始化变量，所以 throttle 并不会生效。解决这个问题可以使用 <code>useRef</code> 或是 <code>useCallback</code> 。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App = () =&gt; &#123;</span><br><span class=\"line\">  const [value, setValue] = useState(0)；</span><br><span class=\"line\"></span><br><span class=\"line\">  const throttled = useRef(</span><br><span class=\"line\">    throttle((newValue) =&gt; console.log(newValue), 1000)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  useEffect(() =&gt; throttled.current(value), [value])</span><br><span class=\"line\"></span><br><span class=\"line\">  // or</span><br><span class=\"line\">  // const throttled = useCallback(</span><br><span class=\"line\">  //  throttle((newValue) =&gt; console.log(newValue), 1000),</span><br><span class=\"line\">  //  []</span><br><span class=\"line\">  // );</span><br><span class=\"line\">  // useEffect(() =&gt; throttled(value), [value])</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;button onClick=&#123;() =&gt; setValue(value + 1)&#125;&gt;&#123;value&#125;&lt;/button&gt;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>调用时直接使用 <code>throttled.current()</code> （或 <code>throttled()</code> ）即可。注意如果在 throttle 函数中需要用到函数外的 state 值，只能取到初始值（闭包），这种时候只能将所需参数作为 params 传进去。或是将 throttle 函数移到组件外。</p>\n<h4 id=\"20200221\">2020/02/21</h4>\n<p>在使用 react hooks 时，如果需要在组件中实例一个类（如 <code>new stroe()</code>）；为了让该变量变成一个 state ，而不是每次重新渲染时都会重新初始化，我们会使用 <code>useState</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useState &#125; from &quot;react&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const XXX:React.FC = () =&gt; &#123;</span><br><span class=\"line\">  const [store] = useState(new Store());</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>引入惰性初始 state ，传入 function ，关于惰性初始 state 可以参考文档 <a href=\"https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\" target=\"_blank\" rel=\"noopener\">Lazy initial state</a> 部分，更详细的解释可以参考 StackOverflow 上这个 <a href=\"https://stackoverflow.com/a/58539958\" target=\"_blank\" rel=\"noopener\">回答</a> ，具体而言，传入 function 时只会在第一次渲染时调用；如果不引入惰性初始 state ，虽然 initialState 只会在第一次渲染时使用，但传入 <code>useState</code> 的函数还是会进行初始化和调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useState &#125; from &quot;react&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const XXX:React.FC = () =&gt; &#123;</span><br><span class=\"line\">  const [store] = useState(() =&gt; new Store());</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样带来的问题是，如果 store 中的成员更新了，并不会触发重新渲染。为了解决这个问题，我们可以直接引入 Mobx ，参考 mobx-react-lite 中 <a href=\"https://github.com/mobxjs/mobx-react-lite#lazy-initialization\" target=\"_blank\" rel=\"noopener\">Lazy initialization</a> 这一节：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; observer &#125; from &quot;mobx-react-lite&quot;</span><br><span class=\"line\">import &#123; observable &#125; from &quot;mobx&quot;</span><br><span class=\"line\">import &#123; useState &#125; from &quot;react&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const XXX:React.FC = observer(() =&gt; &#123;</span><br><span class=\"line\">  const [store] = useState(() =&gt; observable(new Store()));</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4>About</h4>\n<p>📅 2020 年 2 月的零散学习记录。</p>\n<p>动笔时发现已经是2月21号了，惭愧啊惭愧。</p>\n<h4>2020/02/27</h4>\n<p>今天在处理函数式组件时遇到了一个问题，将某个函数作为回调函数传到子组件，在回调函数中打印 state ，只能取到初始值，没有打印出最新结果。排查了很久，后来发现在子组件中，该函数用于注册事件监听函数，因此事件监听绑定的函数，是第一次渲染时传进去的，后续并不会更新，永远只能获取到初始值。<br>\n不考虑父子组件，用最简单的例子复现这个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App:React.FC = () =&gt; &#123;</span><br><span class=\"line\">  const [state,setState] = useState(0);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    window.addEventListener(&quot;wheel&quot;, handleWheelChange);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      window.removeEventListener(&quot;wheel&quot;, handleWheelChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,[]);</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleWheelChange = () =&gt; &#123;</span><br><span class=\"line\">    // always print 0</span><br><span class=\"line\">    console.log(state)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要解决这个问题，可以使用 ref ，取值时通过 <code>ref.current</code> 取：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App:React.FC = () =&gt; &#123;</span><br><span class=\"line\">  const [state,setState] = useState(0);</span><br><span class=\"line\">  // create ref</span><br><span class=\"line\">  const stateRef = useRef(state);</span><br><span class=\"line\"></span><br><span class=\"line\">  // update ref.current when state changes</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ref.current = state;</span><br><span class=\"line\">  &#125;,[state])</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    window.addEventListener(&quot;wheel&quot;, handleWheelChange);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      window.removeEventListener(&quot;wheel&quot;, handleWheelChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,[]);</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleWheelChange = () =&gt; &#123;</span><br><span class=\"line\">    // access newest state correctly</span><br><span class=\"line\">    console.log(ref.current)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码只是一种思路的表达，在实际项目中，直接使用 <code>useRef</code> 初始化变量就好了，没有必要先 <code>useState</code> ，再对 state <code>useRef</code> 。但有时使用了 <code>useReducer</code> ，如果只需要用到其中某个变量，就可以用上述代码中提到的方法。<br>\n第二种方法是通过调用 <code>setState</code> ，传入函数来取到最新的 state ，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">const handleWheelChange = () =&gt; &#123;</span><br><span class=\"line\">    setState(prev =&gt; &#123;</span><br><span class=\"line\">      // prev is the newest state, do anything you need</span><br><span class=\"line\">      // remenber to return value</span><br><span class=\"line\">      return prev;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h4>2020/02/24</h4>\n<p>今日阅读：<a href=\"https://stackoverflow.com/questions/54666401/how-to-use-throttle-or-debounce-with-react-hook\" target=\"_blank\" rel=\"noopener\">How to use throttle or debounce with React Hook?</a><br>\n在使用函数式组件时，如果我们需要引入 lodash 的 <code>throttle</code> 或 <code>debounce</code> ，很容易写出如下错误代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ExComp:React.FC = () =&gt; &#123;</span><br><span class=\"line\">  ....</span><br><span class=\"line\">  // call it somewhere</span><br><span class=\"line\">  const throttle = lodash.throttle((value) =&gt; &#123;</span><br><span class=\"line\">    // do something</span><br><span class=\"line\">  &#125;,2000)</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中，在函数式组件中引入了一个 throttle 函数（底层实现是 <code>setTimeout</code>），然而对于函数式组件而言，每一次 rerender 都会重新初始化变量，所以 throttle 并不会生效。解决这个问题可以使用 <code>useRef</code> 或是 <code>useCallback</code> 。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const App = () =&gt; &#123;</span><br><span class=\"line\">  const [value, setValue] = useState(0)；</span><br><span class=\"line\"></span><br><span class=\"line\">  const throttled = useRef(</span><br><span class=\"line\">    throttle((newValue) =&gt; console.log(newValue), 1000)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  useEffect(() =&gt; throttled.current(value), [value])</span><br><span class=\"line\"></span><br><span class=\"line\">  // or</span><br><span class=\"line\">  // const throttled = useCallback(</span><br><span class=\"line\">  //  throttle((newValue) =&gt; console.log(newValue), 1000),</span><br><span class=\"line\">  //  []</span><br><span class=\"line\">  // );</span><br><span class=\"line\">  // useEffect(() =&gt; throttled(value), [value])</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;button onClick=&#123;() =&gt; setValue(value + 1)&#125;&gt;&#123;value&#125;&lt;/button&gt;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure>\n<p>调用时直接使用 <code>throttled.current()</code> （或 <code>throttled()</code> ）即可。注意如果在 throttle 函数中需要用到函数外的 state 值，只能取到初始值（闭包），这种时候只能将所需参数作为 params 传进去。或是将 throttle 函数移到组件外。</p>\n<h4>2020/02/21</h4>\n<p>在使用 react hooks 时，如果需要在组件中实例一个类（如 <code>new stroe()</code>）；为了让该变量变成一个 state ，而不是每次重新渲染时都会重新初始化，我们会使用 <code>useState</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useState &#125; from &quot;react&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const XXX:React.FC = () =&gt; &#123;</span><br><span class=\"line\">  const [store] = useState(new Store());</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>引入惰性初始 state ，传入 function ，关于惰性初始 state 可以参考文档 <a href=\"https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\" target=\"_blank\" rel=\"noopener\">Lazy initial state</a> 部分，更详细的解释可以参考 StackOverflow 上这个 <a href=\"https://stackoverflow.com/a/58539958\" target=\"_blank\" rel=\"noopener\">回答</a> ，具体而言，传入 function 时只会在第一次渲染时调用；如果不引入惰性初始 state ，虽然 initialState 只会在第一次渲染时使用，但传入 <code>useState</code> 的函数还是会进行初始化和调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; useState &#125; from &quot;react&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const XXX:React.FC = () =&gt; &#123;</span><br><span class=\"line\">  const [store] = useState(() =&gt; new Store());</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样带来的问题是，如果 store 中的成员更新了，并不会触发重新渲染。为了解决这个问题，我们可以直接引入 Mobx ，参考 mobx-react-lite 中 <a href=\"https://github.com/mobxjs/mobx-react-lite#lazy-initialization\" target=\"_blank\" rel=\"noopener\">Lazy initialization</a> 这一节：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; observer &#125; from &quot;mobx-react-lite&quot;</span><br><span class=\"line\">import &#123; observable &#125; from &quot;mobx&quot;</span><br><span class=\"line\">import &#123; useState &#125; from &quot;react&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const XXX:React.FC = observer(() =&gt; &#123;</span><br><span class=\"line\">  const [store] = useState(() =&gt; observable(new Store()));</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;&gt;&lt;/&gt;;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"FrontEnd Daily Learning [2019.07-2019.08]","catalog":true,"date":"2019-07-11T11:44:53.000Z","subtitle":null,"header-img":null,"_content":"#### 前言\n📝 recap and cheat sheet ，记录每天学到的知识/想法。\n🔊 每日一问：今天你比昨天更博学了吗？\n\n\n#### 2019/8/25\n今日踩坑记录：\n展开语法（spread syntax）只能取到 enumerable properties。例如：\n```\nconst imageData = new ImageData(200, 100);\n// ImageData { width: 200, height: 100, data: Uint8ClampedArray[80000] }\nconst result = {...imageData}\n// result 只会包含 data ，不能取到 width 和 height\n```\n\n\n#### 2019/8/24\n避免组件重新挂载，可以使用事件的形式：\n```\nclass BussinessProvider {\n  sp$ = new Subject<{url: string, slic: string}>();\n}\n\nclass Canvas {\n  componentDidMount() {\n     this.props.sp$.pipe(takeUntil(this.unmount$)).subscribe(ev => {\n        if (ev.url === this.url) {\n           this.handleSuperPixelChange(ev.slic)\n        }\n     })\n  }\n}\n```\n\n\n#### 2019/8/24\n一、Promise\n```\nnew Promise((resolve,reject) => {\n  // do something...\n})\n\npromise.then(onFulfilled[, onRejected]);\npromise.then(value => {\n  // fulfillment\n}, reason => {\n  // rejection\n});\n\npromise.catch(onRejected);\npromise.catch(function(reason) {\n   // rejection\n});\n```\n简单来说，`reject(value)` 可以被 `promise.then` 第二个函数参数捕获，也可以被 `promise.catch` 捕获。如果两者同时存在，会被 `promise.then` 第二个函数参数捕获，`promise.catch` 无输出。\n\n下载图片的典型例子：\n```\nfunction loadImage(url) {\n  return new Promise((resolve, reject) => {\n    let img = new Image();\n    // img.onload = () => resolve(img)\n    img.addEventListener('load', e => resolve(img));\n    // img.onerror = () => reject(XXX)\n    img.addEventListener('error', () => {\n      reject(new Error(`Failed to load image's URL: ${url}`));\n    });\n    img.src = url;\n  });\n}\n\nloadImage('http://thecatapi.com/api/images/get?format=src&type=jpg&size=small')\n  .then(img => document.getElementById('image-holder').appendChild(img))\n  .catch(error => console.error(error));\n```\n\n二、await\n`[rv] = await expression`:\n>TL;DR returns the fulfilled value of the promise, \nThe await expression causes async function execution to pause until a Promise is settled, that is fulfilled or rejected, and to resume execution of the async function after fulfillment. When resumed, the value of the await expression is that of the fulfilled Promise.\nIf the Promise is rejected, the await expression throws the rejected value.\nIf the value of the expression following the await operator is not a Promise, it's converted to a resolved Promise.\n\n\n#### 2019/8/23\n`String.prototype.localeCompare()`\n> return a number, indicating whether the reference string comes before, after or is the same as the compareString in sort order. Returns one of three values:\n-1: if the reference string is sorted before the compareString\n 0: if the two strings are equal\n 1: if the reference string is sorted after the compareString\n\n`Array.prototype.sort()`\n>  sorts the elements of an array in place and returns the sorted array. \n\n```\nitems.sort((a,b) => a.localeCompare(b))\n```\n\n\n#### 2019/8/21\n今日阅读：\n[What is the difference between “npm install” and “npm ci”?](https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci)\n[Everything You Wanted To Know About package-lock.json But Were Too Afraid To Ask](https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8)\n\n\n#### 2019/8/20\n模仿 react hook `useState` 的第二个参数：\n&emsp;&emsp;因为在 jest 测试中某个函数的参数是 `useState` 的第二个参数，写了一个替代，不过不确定是否有错。😳\n```\n// for example\nconst [str,setStr] = useState<string[]>([]);\n\n// fake setStr\nlet str:string[] = [];\nconst setStr = (val: string[] | ((prev:string[]) => string[])) => {\n  if (typeof val === \"object\") {\n    str = val;\n  } else if (typeof val === \"function\") {\n    str = val(str)\n  }\n}\n```\n\n#### 2019/8/19\n今日阅读：[What is rel=noopener noreferrer link](https://searchenginelaws.com/seo/what-is-rel-noopener-noreferrer-tag/)\n&emsp;&emsp;使用 `a` 标签，且属性 `target=\"_blank\"` 时，需要加上 `rel=\"noopener noreferrer\"` 。可以防止新窗口利用 `window.opener` 的特性窃取原窗口信息。具体而言，如果 window A 打开了 window B，那么 B.opener 会返回 A。如果加上 `rel=\"noopener\"` ，会返回 null 。\n\n\n#### 2019/8/12\n一、download files using axios\n```\nimport axios from \"axios\"\n\naxios.get(url,{\n  responseType: 'blob', // important\n  headers: {\n    'Authorization': AuthStr \n  }\n}).then(resp => {\n  const {data} = resp;\n  const file = new File([data],\"data.txt\");\n  const objectURL = URL.createObjectURL(file);\n  const a = document.createElement(\"a\");\n  a.href = objectURL;\n  a.download = \"data.txt\";\n  a.click();\n  URL.revokeObjectURL(objectURL);\n})\n```\n&emsp;&emsp;如果是单次点击下载多个文件，Chrome 只会弹出一个弹窗下载最后一个文件。这个时候可以加上 `setTimeout` ，触发多次下载，或是加上 `a.target = \"_blank\"` ，打开多个新窗口。\n二、curl\n查看命令：\n`curl --help`\n-H 指定Header：\n`curl -H \"Authorization: XXXXXXXX\" URL`\n`curl POST -d data -H \"Authorization: XXXXXXXX\" URL`\n\n\n#### 2019/8/9\n一、[useRef vs useState: Should we re-render or not?](https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/)\n![FE_20190808](FE_20190809.png)\n二、Hooks 监听键盘事件\nkeyCode: https://keycode.info/\n```\nfunction useKeyPress(targetKey) {\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  function downHandler({ key }) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  }\n\n  const upHandler = ({ key }) => {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  };\n\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, []);\n\n  return keyPressed;\n}\n```\n\n\n#### 2019/8/8\n&emsp;&emsp;工程中经常会看到 CI/CD 的概念。CI 指的是持续集成，侧重于简化发布准备工作的实践，比如自动测试；CD 指的是持续交付，意味着不仅让测试自动化，让发布流程也自动化了。更多概念对比可以参考：[Continuous integration VS continuous delivery VS continuous deployment](https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment)\n&emsp;&emsp;下面这个图很清晰地描述了三者的不同：\n![FE_20190808](FE_20190808.png)\n&emsp;&emsp;在 gitlab 上的实践可以参考：[基于 GitLab CI/CD 的自动化构建、发布实践](https://mp.weixin.qq.com/s/z2f1i2FgrVGofQR6nKTd1A)\n\n#### 2019/8/7\nTypescript: [Discriminated Unions](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions) \n&emsp;&emsp;当我们某个参数可能有多个类型，而这些类型中又有公共的属性时，就可以使用这种形式约束。\n```\n// Each interface has a kind property with a different string literal type. \n// The kind property is called the discriminant or tag. \ninterface Square {\n    kind: \"square\";\n    size: number;\n}\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\n// put the interfaces into a union\ntype Shape = Square | Rectangle | Circle;\n\n// use the discriminated union\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n        default: return assertNever(s); // error here if there are missing cases\n    }\n}\n\n// Exhaustiveness checking \nfunction assertNever(x: never): never {\n    throw new Error(\"Unexpected object: \" + x);\n}\n```\n\n\n#### 2019/8/6\nStack Overflow: [useState set method not reflecting change immediately.](https://stackoverflow.com/questions/54069253/usestate-set-method-not-reflecting-change-immediately)\n&emsp;&emsp;今天在实践中发现，`setState` 后马上打印，并不会取到更新后的值。查阅资料后发现这个函数是一个异步的函数，不会立即更新，但会触发重新渲染。如下：\n![FE_20190806](FE_20190806.png)\n\n\n#### 2019/8/1\n一、[Fetch API](https://javascript.info/fetch-api)\n&emsp;&emsp;用 fetch 来请求网络资源，可以配置不同的参数来解决缓存、跨域等问题，如下示例代码：\n```\n// 不缓存请求结果 \n// https://stackoverflow.com/questions/29246444/fetch-how-do-you-make-a-non-cached-request\nconst headers = new Headers();\nheaders.append(\"pragma\", \"no-cache\");\nheaders.append(\"cache-control\", \"no-store\");\n\n// 完全忽略 http-cache ，每次都从服务器请求数据\n// https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\nconst cache: RequestCache = \"no-store\";\n\n// 请求模式，若有的请求会因为 cors 而失败，可以设置为 \"no-cors\"\n// https://developer.mozilla.org/en-US/docs/Web/API/Request/mode\nconst mode: RequestMode = needCors ? \"cors\" : \"no-cors\";\n\nawait fetch(url. {headers, cache, mode})\n  .then(res => res.blob())\n  .then(blob => {\n    // doSomething with blob\n    const url = URL.createObjectURL(blob)\n    let a = document.createElement('a')\n    a.download = 'example.zip'\n    a.href = url\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n  })\n  .catch(err => {\n    console.log(err)\n  })\n  .finally(() => {\n    // doSomething\n  })\n```\n&emsp;&emsp;关于 `res.blob()` ，可以参考知乎上[谈一谈 Fetch API 中的 “res.blob()”](https://zhuanlan.zhihu.com/p/32909043)；也可以参考 [fetch documentation](https://github.github.io/fetch/) ，这一篇比较详细，也提供了较多其他的例子。\n关于浏览器缓存问题，Medium 上这篇 [A Web Developer’s Guide to Browser Caching](https://medium.com/@codebyamir/a-web-developers-guide-to-browser-caching-cc41f3b73e7c) 写得不错。如果存在代理服务器，即使我们设置了 `mode: 'no-store'` ，代理服务器也会缓存。为了避免这个情况，我们可以在每次发送请求时构造新的 URL ，加上时间戳 `?t=Date.now()` 。🐮🍺\n二、Jest\n&emsp;&emsp;我们在使用 jest 测试时，有时候需要引入一些外部文件/外部变量，如从 `config.json` 文件中引入某个变量。为了在测试文件中可以访问到该变量，我们可以在 `jest.config.js` 中配置全局变量：\n```\nmodule.exports = {\n  globals: {\n    API_BASE: \"\",\n    DATA_API: \"\",\n    TRACK_API: \"\"\n  },\n  setupFiles: [\"./jestSetup.ts\"]\n}\n```\n&emsp;&emsp;由于 `globals` 只支持 JSON 格式的变量，如果我们需要定义全局函数，则可以使用 `setupFiles`。\n```\n// jestSetup.ts\n(global as any).fn= () => {};\n(global as any).variable = \"XXX\";\n```\n\n\n#### 2019/7/31\n1）`position: fixed` 和 flex 布局是不能同时起作用的。绝对布局脱离文档流，不会参与到 flex layout 中。如果想实现左侧菜单栏，右侧内容，两者不同时滚动（菜单栏 fixed），但菜单栏的大小可以改变（flex 父布局）。可以让父容器是 flex 布局，左侧菜单栏和右侧内容区域都是 flex element ， 菜单栏内部再有一个 `position: fixed` 的 div 。\n2）如果想让 `position: fixed` 的元素相对父容器定位，可以给父容器增加 CSS 属性 `transform: translate(0,0)` 。参考：[MDN - position](https://developer.mozilla.org/en-US/docs/Web/CSS/position)\n> fixed: It is positioned relative to the initial containing block established by the viewport, except when one of its ancestors has a transform, perspective, or filter property set to something other than none. \n\n\n#### 2019/7/30\n`useEffect` 中的异步请求：\n```\n// 错误写法， return 必须是 cleanup function\nuseEffect(async () => {\n  const newVal = await asyncCall();\n  setVal(newVal);\n});\n\n// 正确写法\nuseEffect(() => {\n  asyncCall().then(resp => setVal(resp.data));\n});\n```\n好文共享：[How to fetch data with React Hooks?](https://www.robinwieruch.de/react-hooks-fetch-data/)，代码如下：\n```\nuseEffect(() => {\n  async function fetchMyAPI() {\n    let url = 'http://something/' + productId;\n    let config = {};\n    const response = await myFetch(url);\n    console.log(response);\n  }  \n\n  fetchMyAPI();\n}, [productId]);\n```\n如果要保证请求按顺序发出，可以采用如下写法：\n```\nuseEffect(() => {\n  let didCancel = false;\n\n  async function fetchMyAPI() {\n    let url = 'http://something/' + productId;\n    let config = {};\n    const response = await myFetch(url);\n    if (!didCancel) { // Ignore if we started fetching something else\n      console.log(response);\n    } \n  }  \n\n  fetchMyAPI();\n  return () => { didCancel = true; }; // Remember if we start fetching something else\n}, [productId]);\n```\n\n\n#### 2019/7/29\n一、[performance.now() vs Date.now()](https://stackoverflow.com/questions/30795525/performance-now-vs-date-now)\n&emsp;&emsp;在程序中打印执行时间时，使用 `performance.now(）` 更准确。\n```\nconst start = performance.now();\ndoSomething();\nconst end = performance.now();\nconsole.log(\"Call to doSomething took \" + (start - end) + \" milliseconds.\");\n```\n二、[Does javascript slice method return a shallow copy?](https://stackoverflow.com/questions/47738344/does-javascript-slice-method-return-a-shallow-copy)\n&emsp;&emsp;mdn 上对 `slice()` 方法的介绍：\n>The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included) where begin and end represent the index of items in that array. The original array will not be modified.\n\n&emsp;&emsp;注意这里的浅复制指的是对数组中值的浅复制，而不是对整个数组的浅复制。如果是一个字符串数组，则修改新数组时，原数组不会改变；如果是对象数组，修改新数组对象值时，原数组也会发生变化。\n```\nconst animals = [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}];\nconst newAnimals = animals.slice(2);\n\nnewAnimals[0].name = 'aaa';\nconsole.log(newAnimals); // [{name: 'aaa'}]\nconsole.log(animals);    // [{name: 'ant'}, {name: 'bison'}, {name: 'aaa'}]\n```\n&emsp;&emsp;注意如果是重新赋值，则等于重新分配空间，不会改变原数组。\n```\nconst animals = [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}];\nconst newAnimals = animals.slice(2);\n\nnewAnimals[0] = {name: 'aaa'};\nconsole.log(newAnimals); // [{name: 'aaa'}]\nconsole.log(animals);    // [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}]\n```\n\n#### 2019/7/26\n&emsp;&emsp;应用场景：我们需要请求并更新菜单栏中任务的状态，如果一个请求完成立马更新会导致 React 频繁刷新，需要缓冲批处理：\n```\nimport { runInAction } from \"mobx\";\n\nlet handlers: Array<() => void> = [];\nconst runHandlers = () => {\n  runInAction(() => {\n    handlers.forEach(f => f());\n    handlers = [];\n  });\n};\n\nfor (const task of tasks) {\n  const {data} = await requestFn();\n  \n  handlers.push(() => {\n    // deal with data, update state\n    ...\n  });\n\n  if(handlers.length > 30) {\n    runHandlers();\n  }\n}\n\nrunHandlers();\n```\n&emsp;&emsp;上述代码主要是利用了自定义的 `handlers` 来暂存状态更新函数，之后使用 mobx 提供的 `runInAction` 执行函数并更新状态，更新状态都需要使用 `action` 函数， `runInAction` 接受一个代码块并在一个(匿名)操作中执行，有利于动态创建和执行操作，`runInAction(f) = action(f)()`。此外，必要时还可加上 `lodash.memoize(func,[resolver])`，记录主函数请求结果。\n> For one-time-actions runInAction(name?, fn) can be used, which is sugar for action(name, fn)()\n\n\n#### 2019/7/18 \n一、编程模式：\n&emsp;&emsp; 首先先记住这几种编程模式的中文：Imperative Programming 是命令式编程，Declarative Programming 是声明式编程，Reactive Programming 是响应式编程。（流下了英文不好的泪水）\n1）先看命令式编程和声明式编程的区别，直接上代码：\n```\n// 命令式编程 imperative programming\nconst array = [0,1,2,3,4,5];\nconst output = [];\nfor (let i = 0; i < array.length; i++) {\n  const tmp = array[i] * 2;\n  output.push(tmp)\n};\nconsole.log(output) // => [0,2,4,6,8,10]\n```\n```\n// 声明式编程 declarative programming\nconst array = [0,1,2,3,4,5];\nconst output = array.map(item => item * 2);\nconsole.log(output) // => [0,2,3,6,8,10]\n```\n&emsp;&emsp;很明显可以看到，命令式编程的关注点在于 how ，我们需要一步步告诉机器接下来要做什么，告诉他怎么去遍历一个数组，怎么去运算得到最后的结果，怎么去输出；声明式编程的关注点在于 what ，我们只关注最后的结果，由机器自己去摸索过程，如直接调用 `map` 函数，只告诉程序我们需要一个2倍输出。\n2）接着看声明式编程和响应式编程的对比\n&emsp;&emsp;可以阅读：[Imperative vs Reactive](https://codepen.io/HunorMarton/post/imperative-vs-reactive)，解释很清晰，比喻也很形象，但我觉得文章里的 Imperative 应该改成 Declarative 比较准确。继续沿用上面的例子，修改一下声明式编程的例子：\n```\n// 声明式编程 declarative programming\nconst array = [1,2];\nconst output = array.map(item => item * 2);\noutput.forEach(item => console.log(item)) // => 2 4\narray.push(3);  // => no output \narray.push(4);  // => no output\n```\n响应式编程的例子：\n```\nimport { Subject } from `rxjs`;\nlet array = new Subject();\narray.next(1);\narray.next(2);\n\nconst output = array.map(item => item * 2);\noutput.forEach(item => console.log(item)); // => 2 4\n\narray.next(3); // => 6\narray.next(4); // => 8\n```\n&emsp;&emsp;首先要注意的是，这两种方式中的 `map` ， `forEach` 等函数并不是一样的，内部实现机制是不同的。我们可以发现区别：在声明式编程中，如果在最后向原数组添加值，并不会打印出来，因为这是在 `console.log` 语句执行后发生的。但在响应式编程里，任何变化都可以被反应出来，它引入了一个**异步数据流**（asynchronous data streams）的概念，可以随时创建、更改或组合这些数据流，所以打印事件是一个 continuous observation case。\n二、类库\n[react-virtualized](https://github.com/bvaughn/react-virtualized) 的轻量级版 [react-window](https://github.com/bvaughn/react-window)，用于高效渲染长列表。\n\n\n#### 2019/7/17 \n&emsp;&emsp;如果我们在项目中需要请求很多图片，想要实现请求出错时继续发送请求，成功时返回数据，可以使用 `Promise` ：\n```\nfunction fetchURL(url: string):Promise<Blob> {\n  return Axios.get(url, {responeType: \"blob\"})\n              .then( resp => Promise.resolve(resp.data) )\n              .catch( () => fetchURL(url) )\n}\n```\n之后可以使用 `rxjs` ：\n```\nimport { mergeMap, bufferTime, takeUntil } from \"rxjs/operators\";\n\n[url1,...,url10]\n  .pipe(\n    mergeMap( url => fetchURL(url).then( val => val )),\n    bufferTime(10000)\n  )\n  .subscribe({\n    next: resps => {\n      // do sth with resps:Blob[]\n    }\n  })\n```\n&emsp;&emsp;每次遇到 `rxjs` 都很头大，现在也没有发现一个比较完善清晰的教程，但它又真的很强大，后续要开专题好好学习记录这个东西。\n\n\n#### 2019/7/16\n一、今日阅读：[How to read an often-changing value from useCallback?](https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback)\n直接上官网代码：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  const textRef = useRef();\n\n  useEffect(() => {\n    textRef.current = text; // Write it to the ref\n  });\n\n  const handleSubmit = useCallback(() => {\n    const currentText = textRef.current; // Read it from the ref\n    alert(currentText);\n  }, [textRef]); // Don't recreate handleSubmit like [text] would do\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n&emsp;&emsp; 也就是说，当 `text` 的值经常发生变化时，即使 `handleSubmit` 用 `useCallback` 包裹了，还是会重新声明。解决办法是传入一个 `ref` 对象代替原始值。也可以写一个 custom hook ：\n1）官网的版本：\n```\nfunction useEventCallback(fn, dependencies) {\n  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n```\n实际使用：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  // Will be memoized even if `text` changes:\n  const handleSubmit = useEventCallback(() => {\n    alert(text);\n  }, [text]);\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n2）导师的版本：（他来了，他带着代码又来了）\n```\n/**\n * @param callback\n * @param oRefs\n */\nexport function useCallbackWithRefs<\n  Refs,\n  Callback extends (...args: any[]) => void\n>(callback: (refs: Refs) => Callback, oRefs: Refs) {\n  const refs = useRef(oRefs);\n  useEffect(\n    () => {\n      refs.current = oRefs;\n    },\n    [oRefs]\n  );\n\n  return useCallback(\n    (...args: any[]) => callback(refs.current)(...args),\n    []\n  ) as Callback;\n}\n```\n实际使用：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  \n  // 原先的 callback 也可以有参数\n  const handleSubmit = useCallbackWithRefs(\n    refs => (params: any) => {\n      // 要注意在函数内必须使用 `refs.xxx`，不能直接使用函数外部的任何变量 `xxx`\n      console.log(refs.text);\n  }, {text});\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n&emsp;&emsp;总的来说，官网的实现是将 `callback` 作为 `ref` 对象，并作为 `useCallback` 的依赖，不会频繁改变；如果在函数 `handleSubmit` 中要访问外部变量 `text` ，直接使用 `test` 即可。第二种实现方式是把经常变化的值作为 `ref` 对象，返回值 `useCallback` 第一个参数是 `refs => callback` ，依赖是空数组；这时如果要在函数 `handleSubmit` 中要访问外部变量 `text` ，必须使用 `refs.test` ，否则访问的只是 `test` 的初始值。\n&emsp;&emsp;React 博大精深，接下来要好好研读一下这个 [FAQ](https://reactjs.org/docs/hooks-faq.html)。\n二、今日网址\n&emsp;&emsp;一个 [emoji copy](https://www.emojicopy.com/) 网站，我们 👧 就是喜欢这些花里胡哨的东西。\n\n\n#### 2019/7/15\n&emsp;&emsp;今天在项目中使用 React Hooks 又踩坑了，看来自己对这部分还是没有理解透彻。在使用 `useCallback` 和 `useEffect` 时，要注意第二个参数，也就是传入的 `[deps]`。如果使用 `useCallback(fn,[deps])` ， `[deps]` 应该包含函数 `fn` 所涉及的所有变量；如果使用 `useEffect(fn,[deps])` ， 当 `deps` 的值变化时，就会执行 `fn`，因此`[deps]` 不一定要包含函数 `fn` 所涉及的所有变量，而是应该传入会引起该函数执行的那些参数。\n&emsp;&emsp;今日踩坑记录：为了优化子组件，作为 `props` 的函数都使用 `useCallback` 包裹了，并传入了空数组作为第二个参数，表示没有依赖。但是函数中的运算需要用到组件中一个变量，如果没有将该变量作为 `deps` ，这个变量就会一直保持初始值，值并不会改变，运行结果就会与预期不符。（真的太蠢了，缓缓躺倒）\n\n\n#### 2019/7/14\n周末当然是约会啦。😍\n\n\n#### 2019/7/13\n一、今日阅读：[How to compare oldValues and newValues on React Hooks useEffect?](https://stackoverflow.com/questions/53446020/how-to-compare-oldvalues-and-newvalues-on-react-hooks-useeffect)\n&emsp;&emsp; React class 组件提供了 `ComponentDidUpdate` 之类的方法来获取到当前 `props` 和前一个 `props` ，并进行比较，决定是否进行更新。函数式组件只有 `useEffect` 函数来模仿生命周期函数，当我们需要获取组件先前的 `props` 时，可以使用下面的 custom hook ：\n```\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n```\n&emsp;&emsp;之后在 `useEffect` 中使用上面的函数来模拟 `ComponentDidUpdate` ：\n```\nconst Component = (props) => {\n    const {receiveAmount, sendAmount } = props\n    const prevAmount = usePrevious({receiveAmount, sendAmount});\n    useEffect(() => {\n        if(prevAmount.receiveAmount !== receiveAmount) {\n\n         // process here\n        }\n        if(prevAmount.sendAmount !== sendAmount) {\n\n         // process here\n        }\n    }, [receiveAmount, sendAmount])\n}\n```\n&emsp;&emsp;有时候在 debug 时，我们想知道组件为什么会重新渲染，是那些 `props` 更新了，也可以使用上面的方法来获取 `prevProps`，并在函数组件最开始时写一个 `useEffect` 将参数都打印出来，使用 `===` 比较。 \n\n\n\n#### 2019/7/12\n一、今日技能\n&emsp;&emsp;项目中经常会涉及到 JSON 字符串的解析，解析出错就扑街了，一般是用 `try {...} catch {...}` 包裹。今天导师在 code review 时建议我使用如下函数，该函数也可以覆盖空字符串的检测：\n```\nfunction safeJsonParse<T>(str): { ok: true, value: T } | { ok: false } {\n  try {\n    return {\n      ok: true,\n      value: JSON.parse(str)\n    }\n  } catch {\n    return {\n      ok: false\n    }\n  }\n}\n```\n二、今日阅读：[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://imweb.io/topic/5b72d4ef15554e6d3409f817)。\n&emsp;&emsp;这一篇很好地梳理了进程、线程、浏览器**多进程**、浏览器内核**多线程**、JS单线程、JS运行机制的相关知识，很连贯，建议时不时回顾。简单记录几个知识点：\n1）进程是CPU资源分配的最小单位，线程是CPU调度的最小单位。（想当年考操作系统的时候还背得滚瓜烂熟）\n2）**浏览器是多进程的**，包括的主要进程有：\n- Browser进程（浏览器的主进程，只有一个）\n- 浏览器渲染进程（浏览器内核，Renderer进程，渲染进程，内部是多线程的）：默认每个Tab一个进程\n- 第三方插件进程\n- GPU进程：3D绘制\n\n3）重点是浏览器内核，它是多线程的，主要常驻线程有：\n- GUI渲染线程：渲染页面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制，repaint 和 reflow 等。\n- JS引擎线程：处理任务队列中的任务，与 GUI 渲染线程是互斥的。\n- 事件触发线程：控制事件循环，把事件添加到任务队列的末尾。\n- 定时触发线程：`setTimeout` 和 `setInterval`，同样也是计时完毕后添加到队列末尾。\n- 异步 http 请求线程\n\n4）Browser进程和浏览器内核之间是需要通信的\n5）时间循环机制 `Event Loop` ：JS分为同步任务和异步任务，同步任务都会在主线程上运行，形成一个执行栈；主线程之外，由事件触发线程管理一个**任务队列/事件队列**，异步任务的运行结果会被添加到任务队列中。一旦执行栈中所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到执行栈中开始执行。 \n6）进阶：macrotask / task 和 microtask/ job。ES6中的 `Promise` 就属于 microtask 微任务 ，而主代码块，事件队列中的时间如 `setTimeout` 和 `setInterval` 就属于 macrotask 宏任务。总结的运行机制就是：\n- 执行宏任务。（从执行栈中获取，如果没有就从事件队列中获取）\n- 执行过程中如果遇到微任务，就添加到微任务队列 Job Queues 中。（作者猜测这个队列由JS引擎线程维护，因为是在主线程下无缝执行的）\n- 宏任务执行完毕后，立即依次执行当前微任务队列中所有微任务。\n- 检查渲染，由 GUI 线程接管。\n- 渲染完毕后，由 JS 引擎线程接管，从时间队列中获取并执行下一个宏任务。\n\n7）在第六点中提到的是一个进阶的概念，对应一道题目，如果代码中依次有 `setTimeout` 和 `Promise` ，是会先打印出 `Promise` 的执行结果的。\n\n\n#### 2019/7/11\n&emsp;&emsp; React 16.8 提出了 `hook` 的概念，函数式组件也可以拥有自己的状态。现在的工作项目已经摒弃了 `class` ，改用函数式组件，正在慢慢摸索中。今天在腾讯[IMWeb前端博客](http://imweb.io/)中看到了两篇介绍 `React hook` 的文章，受益匪浅，简单记录一下。\n 一、[react hook——你可能不是“我”所认识的useEffect](https://imweb.io/topic/5cd845cadcd62f86299fcd76)\n&emsp;&emsp;这篇介绍了 `useEffect` 这个API，用它模拟了class组件的生命周期函数。`useEffect` 用于执行副作用，相当于 `ComponentDidMount` 和 `ComponentDidUpdate`。该API有两个参数和一个返回值。第一个参数是一个副作用函数，返回值是清除函数，相当于 `ComponentWillUnmount`，每一次 `render` 都会执行副作用和清除上一次副作用。**第二个参数是一个数组，传入的是副作用函数所需要的依赖，当任一依赖更新时，会重新生成一个新的副作用并执行；如果传入一个空数组，没有依赖，只会执行一次，相当于 `ComponentDidMount`；如果不传，就是没有说明自己有没有依赖（注意是不知道有没有，不是没有！），每次 `render` 时就执行，相当于 `ComponentDidUpdate` 。**\n&emsp;&emsp; 最后还讲了 `useEffect` 和 `useLayoutEffect` 的区别，简单来说前者是异步的，后者是同步的。还没好好深入这部分，TODO。\n二、[可能你的react函数组件从来没有优化过](https://imweb.io/topic/5d1e3657f7b5692b080f2651)\n&emsp;&emsp;优化问题真是我一个痛点。这篇文章很清楚地解释了 `Hooks` 一些可用于组件优化的API。强推！\n&emsp;&emsp; 特别地，文章介绍了当函数组件中传入的 `props` 值为函数时，由于每一次执行或重新执行，作用域里面一切都是重新开始，函数不是简单数据类型，不能画上等号，子组件都会重新渲染。针对这个问题文章提出了几种解决办法：\n1） 作为 `props` 的函数在函数组件外定义，函数组件用 `React.memo()` 包裹。\n &emsp;&emsp; `React.memo()` 类似于 `PureComponent` 和 `ComponentDidUpdate` ，如果函数组件的 `props` 值都一样，就会跳过该组件的执行，减少不必要的渲染，实现性能优化。\n2） 作为 `props` 的函数在函数组件内定义，使用`useCallBack` 或 `useMemo`包裹，函数组件用 `React.memo()` 包裹。\n&emsp;&emsp; `useCallback(() => {}, [deps])` 返回一个函数，当 `deps` 不变时（如传入空数组，表示没有依赖），都是同一个函数。`const a = useMemo(() => memorizeValue, [deps])`，当 `deps` 不变时，`a` 的值还是上次的 `memorizeValue`，省去了重新计算的过程。\n&emsp;&emsp; 注意当 `memorizeValue` 是一个函数时，`useCallback(fn, inputs) <=> useMemo(() => fn, inputs)`。\n\n\n#### 2019/7/10\n&emsp;&emsp;今天在项目中接触到了 `symbol`，鉴于之前一直没有注意这个数据类型，在今天补上。 `symbol` 是 ES6 新增的**基本**数据类型。它的使用如下：\n```\nconst s1 = Symbol();\nconst s2 = Symbol();\nconsole.log(s1 === s2); // false\n\nconst s3 = new Symbol() // TypeError: Symbol is not a constructor\nSymbol(\"foo\") === Symbol(\"foo\"); // false\n```\n`Symbol()` 返回的每个 `symbol` 值都是唯一的，可以接受一个字符串作为参数。它最常被用于对象属性的标识符，如：\n```\nconst obj = {}\nconst foo = Symbol(\"foo\")\nobj[foo] = \"foo\"\nobj.bar = \"bar\"\n\nconsole.log(obj); // { bar: \"bar\" , Symbol(foo): \"foo\"}\nconsole.log(foo in obj); // true\nconsole.log(obj[foo]); // foo\nconsole.log(Object.keys(obj)); // [\"bar\"]\nconsole.log(Object.getOwnPropertySymbols(obj)) // [Symbol(foo)]\n```\n也就是说， `Object.key()` 不会返回 `symbol` 值，同理，`Object.getOwnPropertyNames()`、`for..in`、`for...of` 也不会返回。`JSON.stringify()` 也会忽略：\n```\nJSON.stringify({[Symbol('foo')]: 'foo'});                 \n// '{}'\n```\n`Symbol` 还有两个方法。 `Symbol.for(key)` 是根据指定的 `key` 搜索现有的 `symbol` 并返回, 如果找不到，会使用 `key` 在全局的 `symbol` 注册表中创建一个新的 `symbol` 。`Symbol.keyFor(sym)` 是在全局注册表中检索，返回共享的 `symbol key` 。\n\n\n#### 2019/7/9\n一个不好的编程习惯：让函数在内部获取自己所需的依赖。例如：\n```\n// 一个可复用函数\nfunction doSomething(key: string) {\n    return (\n        <Button\n            loading = {key===\"str1\"? Compoment1 : Compoment2}\n        >\n            button\n        </Button>\n    )\n}\n```\n`lodaing` 所需的组件应该是作为函数参数传入的，不然如果我们新增了一个 `key`，很容易忽略了该地方的修改。这个观点类似于依赖反转。","source":"_posts/FrontEnd-Daily-Learning-2019-07-08.md","raw":"---\ntitle: FrontEnd Daily Learning [2019.07-2019.08]\ncatalog: true\ndate: 2019-07-11 19:44:53\nsubtitle:\nheader-img:\ntags: FE\n---\n#### 前言\n📝 recap and cheat sheet ，记录每天学到的知识/想法。\n🔊 每日一问：今天你比昨天更博学了吗？\n\n\n#### 2019/8/25\n今日踩坑记录：\n展开语法（spread syntax）只能取到 enumerable properties。例如：\n```\nconst imageData = new ImageData(200, 100);\n// ImageData { width: 200, height: 100, data: Uint8ClampedArray[80000] }\nconst result = {...imageData}\n// result 只会包含 data ，不能取到 width 和 height\n```\n\n\n#### 2019/8/24\n避免组件重新挂载，可以使用事件的形式：\n```\nclass BussinessProvider {\n  sp$ = new Subject<{url: string, slic: string}>();\n}\n\nclass Canvas {\n  componentDidMount() {\n     this.props.sp$.pipe(takeUntil(this.unmount$)).subscribe(ev => {\n        if (ev.url === this.url) {\n           this.handleSuperPixelChange(ev.slic)\n        }\n     })\n  }\n}\n```\n\n\n#### 2019/8/24\n一、Promise\n```\nnew Promise((resolve,reject) => {\n  // do something...\n})\n\npromise.then(onFulfilled[, onRejected]);\npromise.then(value => {\n  // fulfillment\n}, reason => {\n  // rejection\n});\n\npromise.catch(onRejected);\npromise.catch(function(reason) {\n   // rejection\n});\n```\n简单来说，`reject(value)` 可以被 `promise.then` 第二个函数参数捕获，也可以被 `promise.catch` 捕获。如果两者同时存在，会被 `promise.then` 第二个函数参数捕获，`promise.catch` 无输出。\n\n下载图片的典型例子：\n```\nfunction loadImage(url) {\n  return new Promise((resolve, reject) => {\n    let img = new Image();\n    // img.onload = () => resolve(img)\n    img.addEventListener('load', e => resolve(img));\n    // img.onerror = () => reject(XXX)\n    img.addEventListener('error', () => {\n      reject(new Error(`Failed to load image's URL: ${url}`));\n    });\n    img.src = url;\n  });\n}\n\nloadImage('http://thecatapi.com/api/images/get?format=src&type=jpg&size=small')\n  .then(img => document.getElementById('image-holder').appendChild(img))\n  .catch(error => console.error(error));\n```\n\n二、await\n`[rv] = await expression`:\n>TL;DR returns the fulfilled value of the promise, \nThe await expression causes async function execution to pause until a Promise is settled, that is fulfilled or rejected, and to resume execution of the async function after fulfillment. When resumed, the value of the await expression is that of the fulfilled Promise.\nIf the Promise is rejected, the await expression throws the rejected value.\nIf the value of the expression following the await operator is not a Promise, it's converted to a resolved Promise.\n\n\n#### 2019/8/23\n`String.prototype.localeCompare()`\n> return a number, indicating whether the reference string comes before, after or is the same as the compareString in sort order. Returns one of three values:\n-1: if the reference string is sorted before the compareString\n 0: if the two strings are equal\n 1: if the reference string is sorted after the compareString\n\n`Array.prototype.sort()`\n>  sorts the elements of an array in place and returns the sorted array. \n\n```\nitems.sort((a,b) => a.localeCompare(b))\n```\n\n\n#### 2019/8/21\n今日阅读：\n[What is the difference between “npm install” and “npm ci”?](https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci)\n[Everything You Wanted To Know About package-lock.json But Were Too Afraid To Ask](https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8)\n\n\n#### 2019/8/20\n模仿 react hook `useState` 的第二个参数：\n&emsp;&emsp;因为在 jest 测试中某个函数的参数是 `useState` 的第二个参数，写了一个替代，不过不确定是否有错。😳\n```\n// for example\nconst [str,setStr] = useState<string[]>([]);\n\n// fake setStr\nlet str:string[] = [];\nconst setStr = (val: string[] | ((prev:string[]) => string[])) => {\n  if (typeof val === \"object\") {\n    str = val;\n  } else if (typeof val === \"function\") {\n    str = val(str)\n  }\n}\n```\n\n#### 2019/8/19\n今日阅读：[What is rel=noopener noreferrer link](https://searchenginelaws.com/seo/what-is-rel-noopener-noreferrer-tag/)\n&emsp;&emsp;使用 `a` 标签，且属性 `target=\"_blank\"` 时，需要加上 `rel=\"noopener noreferrer\"` 。可以防止新窗口利用 `window.opener` 的特性窃取原窗口信息。具体而言，如果 window A 打开了 window B，那么 B.opener 会返回 A。如果加上 `rel=\"noopener\"` ，会返回 null 。\n\n\n#### 2019/8/12\n一、download files using axios\n```\nimport axios from \"axios\"\n\naxios.get(url,{\n  responseType: 'blob', // important\n  headers: {\n    'Authorization': AuthStr \n  }\n}).then(resp => {\n  const {data} = resp;\n  const file = new File([data],\"data.txt\");\n  const objectURL = URL.createObjectURL(file);\n  const a = document.createElement(\"a\");\n  a.href = objectURL;\n  a.download = \"data.txt\";\n  a.click();\n  URL.revokeObjectURL(objectURL);\n})\n```\n&emsp;&emsp;如果是单次点击下载多个文件，Chrome 只会弹出一个弹窗下载最后一个文件。这个时候可以加上 `setTimeout` ，触发多次下载，或是加上 `a.target = \"_blank\"` ，打开多个新窗口。\n二、curl\n查看命令：\n`curl --help`\n-H 指定Header：\n`curl -H \"Authorization: XXXXXXXX\" URL`\n`curl POST -d data -H \"Authorization: XXXXXXXX\" URL`\n\n\n#### 2019/8/9\n一、[useRef vs useState: Should we re-render or not?](https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/)\n![FE_20190808](FE_20190809.png)\n二、Hooks 监听键盘事件\nkeyCode: https://keycode.info/\n```\nfunction useKeyPress(targetKey) {\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  function downHandler({ key }) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  }\n\n  const upHandler = ({ key }) => {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  };\n\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, []);\n\n  return keyPressed;\n}\n```\n\n\n#### 2019/8/8\n&emsp;&emsp;工程中经常会看到 CI/CD 的概念。CI 指的是持续集成，侧重于简化发布准备工作的实践，比如自动测试；CD 指的是持续交付，意味着不仅让测试自动化，让发布流程也自动化了。更多概念对比可以参考：[Continuous integration VS continuous delivery VS continuous deployment](https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment)\n&emsp;&emsp;下面这个图很清晰地描述了三者的不同：\n![FE_20190808](FE_20190808.png)\n&emsp;&emsp;在 gitlab 上的实践可以参考：[基于 GitLab CI/CD 的自动化构建、发布实践](https://mp.weixin.qq.com/s/z2f1i2FgrVGofQR6nKTd1A)\n\n#### 2019/8/7\nTypescript: [Discriminated Unions](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions) \n&emsp;&emsp;当我们某个参数可能有多个类型，而这些类型中又有公共的属性时，就可以使用这种形式约束。\n```\n// Each interface has a kind property with a different string literal type. \n// The kind property is called the discriminant or tag. \ninterface Square {\n    kind: \"square\";\n    size: number;\n}\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\n// put the interfaces into a union\ntype Shape = Square | Rectangle | Circle;\n\n// use the discriminated union\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n        default: return assertNever(s); // error here if there are missing cases\n    }\n}\n\n// Exhaustiveness checking \nfunction assertNever(x: never): never {\n    throw new Error(\"Unexpected object: \" + x);\n}\n```\n\n\n#### 2019/8/6\nStack Overflow: [useState set method not reflecting change immediately.](https://stackoverflow.com/questions/54069253/usestate-set-method-not-reflecting-change-immediately)\n&emsp;&emsp;今天在实践中发现，`setState` 后马上打印，并不会取到更新后的值。查阅资料后发现这个函数是一个异步的函数，不会立即更新，但会触发重新渲染。如下：\n![FE_20190806](FE_20190806.png)\n\n\n#### 2019/8/1\n一、[Fetch API](https://javascript.info/fetch-api)\n&emsp;&emsp;用 fetch 来请求网络资源，可以配置不同的参数来解决缓存、跨域等问题，如下示例代码：\n```\n// 不缓存请求结果 \n// https://stackoverflow.com/questions/29246444/fetch-how-do-you-make-a-non-cached-request\nconst headers = new Headers();\nheaders.append(\"pragma\", \"no-cache\");\nheaders.append(\"cache-control\", \"no-store\");\n\n// 完全忽略 http-cache ，每次都从服务器请求数据\n// https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\nconst cache: RequestCache = \"no-store\";\n\n// 请求模式，若有的请求会因为 cors 而失败，可以设置为 \"no-cors\"\n// https://developer.mozilla.org/en-US/docs/Web/API/Request/mode\nconst mode: RequestMode = needCors ? \"cors\" : \"no-cors\";\n\nawait fetch(url. {headers, cache, mode})\n  .then(res => res.blob())\n  .then(blob => {\n    // doSomething with blob\n    const url = URL.createObjectURL(blob)\n    let a = document.createElement('a')\n    a.download = 'example.zip'\n    a.href = url\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n  })\n  .catch(err => {\n    console.log(err)\n  })\n  .finally(() => {\n    // doSomething\n  })\n```\n&emsp;&emsp;关于 `res.blob()` ，可以参考知乎上[谈一谈 Fetch API 中的 “res.blob()”](https://zhuanlan.zhihu.com/p/32909043)；也可以参考 [fetch documentation](https://github.github.io/fetch/) ，这一篇比较详细，也提供了较多其他的例子。\n关于浏览器缓存问题，Medium 上这篇 [A Web Developer’s Guide to Browser Caching](https://medium.com/@codebyamir/a-web-developers-guide-to-browser-caching-cc41f3b73e7c) 写得不错。如果存在代理服务器，即使我们设置了 `mode: 'no-store'` ，代理服务器也会缓存。为了避免这个情况，我们可以在每次发送请求时构造新的 URL ，加上时间戳 `?t=Date.now()` 。🐮🍺\n二、Jest\n&emsp;&emsp;我们在使用 jest 测试时，有时候需要引入一些外部文件/外部变量，如从 `config.json` 文件中引入某个变量。为了在测试文件中可以访问到该变量，我们可以在 `jest.config.js` 中配置全局变量：\n```\nmodule.exports = {\n  globals: {\n    API_BASE: \"\",\n    DATA_API: \"\",\n    TRACK_API: \"\"\n  },\n  setupFiles: [\"./jestSetup.ts\"]\n}\n```\n&emsp;&emsp;由于 `globals` 只支持 JSON 格式的变量，如果我们需要定义全局函数，则可以使用 `setupFiles`。\n```\n// jestSetup.ts\n(global as any).fn= () => {};\n(global as any).variable = \"XXX\";\n```\n\n\n#### 2019/7/31\n1）`position: fixed` 和 flex 布局是不能同时起作用的。绝对布局脱离文档流，不会参与到 flex layout 中。如果想实现左侧菜单栏，右侧内容，两者不同时滚动（菜单栏 fixed），但菜单栏的大小可以改变（flex 父布局）。可以让父容器是 flex 布局，左侧菜单栏和右侧内容区域都是 flex element ， 菜单栏内部再有一个 `position: fixed` 的 div 。\n2）如果想让 `position: fixed` 的元素相对父容器定位，可以给父容器增加 CSS 属性 `transform: translate(0,0)` 。参考：[MDN - position](https://developer.mozilla.org/en-US/docs/Web/CSS/position)\n> fixed: It is positioned relative to the initial containing block established by the viewport, except when one of its ancestors has a transform, perspective, or filter property set to something other than none. \n\n\n#### 2019/7/30\n`useEffect` 中的异步请求：\n```\n// 错误写法， return 必须是 cleanup function\nuseEffect(async () => {\n  const newVal = await asyncCall();\n  setVal(newVal);\n});\n\n// 正确写法\nuseEffect(() => {\n  asyncCall().then(resp => setVal(resp.data));\n});\n```\n好文共享：[How to fetch data with React Hooks?](https://www.robinwieruch.de/react-hooks-fetch-data/)，代码如下：\n```\nuseEffect(() => {\n  async function fetchMyAPI() {\n    let url = 'http://something/' + productId;\n    let config = {};\n    const response = await myFetch(url);\n    console.log(response);\n  }  \n\n  fetchMyAPI();\n}, [productId]);\n```\n如果要保证请求按顺序发出，可以采用如下写法：\n```\nuseEffect(() => {\n  let didCancel = false;\n\n  async function fetchMyAPI() {\n    let url = 'http://something/' + productId;\n    let config = {};\n    const response = await myFetch(url);\n    if (!didCancel) { // Ignore if we started fetching something else\n      console.log(response);\n    } \n  }  \n\n  fetchMyAPI();\n  return () => { didCancel = true; }; // Remember if we start fetching something else\n}, [productId]);\n```\n\n\n#### 2019/7/29\n一、[performance.now() vs Date.now()](https://stackoverflow.com/questions/30795525/performance-now-vs-date-now)\n&emsp;&emsp;在程序中打印执行时间时，使用 `performance.now(）` 更准确。\n```\nconst start = performance.now();\ndoSomething();\nconst end = performance.now();\nconsole.log(\"Call to doSomething took \" + (start - end) + \" milliseconds.\");\n```\n二、[Does javascript slice method return a shallow copy?](https://stackoverflow.com/questions/47738344/does-javascript-slice-method-return-a-shallow-copy)\n&emsp;&emsp;mdn 上对 `slice()` 方法的介绍：\n>The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included) where begin and end represent the index of items in that array. The original array will not be modified.\n\n&emsp;&emsp;注意这里的浅复制指的是对数组中值的浅复制，而不是对整个数组的浅复制。如果是一个字符串数组，则修改新数组时，原数组不会改变；如果是对象数组，修改新数组对象值时，原数组也会发生变化。\n```\nconst animals = [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}];\nconst newAnimals = animals.slice(2);\n\nnewAnimals[0].name = 'aaa';\nconsole.log(newAnimals); // [{name: 'aaa'}]\nconsole.log(animals);    // [{name: 'ant'}, {name: 'bison'}, {name: 'aaa'}]\n```\n&emsp;&emsp;注意如果是重新赋值，则等于重新分配空间，不会改变原数组。\n```\nconst animals = [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}];\nconst newAnimals = animals.slice(2);\n\nnewAnimals[0] = {name: 'aaa'};\nconsole.log(newAnimals); // [{name: 'aaa'}]\nconsole.log(animals);    // [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}]\n```\n\n#### 2019/7/26\n&emsp;&emsp;应用场景：我们需要请求并更新菜单栏中任务的状态，如果一个请求完成立马更新会导致 React 频繁刷新，需要缓冲批处理：\n```\nimport { runInAction } from \"mobx\";\n\nlet handlers: Array<() => void> = [];\nconst runHandlers = () => {\n  runInAction(() => {\n    handlers.forEach(f => f());\n    handlers = [];\n  });\n};\n\nfor (const task of tasks) {\n  const {data} = await requestFn();\n  \n  handlers.push(() => {\n    // deal with data, update state\n    ...\n  });\n\n  if(handlers.length > 30) {\n    runHandlers();\n  }\n}\n\nrunHandlers();\n```\n&emsp;&emsp;上述代码主要是利用了自定义的 `handlers` 来暂存状态更新函数，之后使用 mobx 提供的 `runInAction` 执行函数并更新状态，更新状态都需要使用 `action` 函数， `runInAction` 接受一个代码块并在一个(匿名)操作中执行，有利于动态创建和执行操作，`runInAction(f) = action(f)()`。此外，必要时还可加上 `lodash.memoize(func,[resolver])`，记录主函数请求结果。\n> For one-time-actions runInAction(name?, fn) can be used, which is sugar for action(name, fn)()\n\n\n#### 2019/7/18 \n一、编程模式：\n&emsp;&emsp; 首先先记住这几种编程模式的中文：Imperative Programming 是命令式编程，Declarative Programming 是声明式编程，Reactive Programming 是响应式编程。（流下了英文不好的泪水）\n1）先看命令式编程和声明式编程的区别，直接上代码：\n```\n// 命令式编程 imperative programming\nconst array = [0,1,2,3,4,5];\nconst output = [];\nfor (let i = 0; i < array.length; i++) {\n  const tmp = array[i] * 2;\n  output.push(tmp)\n};\nconsole.log(output) // => [0,2,4,6,8,10]\n```\n```\n// 声明式编程 declarative programming\nconst array = [0,1,2,3,4,5];\nconst output = array.map(item => item * 2);\nconsole.log(output) // => [0,2,3,6,8,10]\n```\n&emsp;&emsp;很明显可以看到，命令式编程的关注点在于 how ，我们需要一步步告诉机器接下来要做什么，告诉他怎么去遍历一个数组，怎么去运算得到最后的结果，怎么去输出；声明式编程的关注点在于 what ，我们只关注最后的结果，由机器自己去摸索过程，如直接调用 `map` 函数，只告诉程序我们需要一个2倍输出。\n2）接着看声明式编程和响应式编程的对比\n&emsp;&emsp;可以阅读：[Imperative vs Reactive](https://codepen.io/HunorMarton/post/imperative-vs-reactive)，解释很清晰，比喻也很形象，但我觉得文章里的 Imperative 应该改成 Declarative 比较准确。继续沿用上面的例子，修改一下声明式编程的例子：\n```\n// 声明式编程 declarative programming\nconst array = [1,2];\nconst output = array.map(item => item * 2);\noutput.forEach(item => console.log(item)) // => 2 4\narray.push(3);  // => no output \narray.push(4);  // => no output\n```\n响应式编程的例子：\n```\nimport { Subject } from `rxjs`;\nlet array = new Subject();\narray.next(1);\narray.next(2);\n\nconst output = array.map(item => item * 2);\noutput.forEach(item => console.log(item)); // => 2 4\n\narray.next(3); // => 6\narray.next(4); // => 8\n```\n&emsp;&emsp;首先要注意的是，这两种方式中的 `map` ， `forEach` 等函数并不是一样的，内部实现机制是不同的。我们可以发现区别：在声明式编程中，如果在最后向原数组添加值，并不会打印出来，因为这是在 `console.log` 语句执行后发生的。但在响应式编程里，任何变化都可以被反应出来，它引入了一个**异步数据流**（asynchronous data streams）的概念，可以随时创建、更改或组合这些数据流，所以打印事件是一个 continuous observation case。\n二、类库\n[react-virtualized](https://github.com/bvaughn/react-virtualized) 的轻量级版 [react-window](https://github.com/bvaughn/react-window)，用于高效渲染长列表。\n\n\n#### 2019/7/17 \n&emsp;&emsp;如果我们在项目中需要请求很多图片，想要实现请求出错时继续发送请求，成功时返回数据，可以使用 `Promise` ：\n```\nfunction fetchURL(url: string):Promise<Blob> {\n  return Axios.get(url, {responeType: \"blob\"})\n              .then( resp => Promise.resolve(resp.data) )\n              .catch( () => fetchURL(url) )\n}\n```\n之后可以使用 `rxjs` ：\n```\nimport { mergeMap, bufferTime, takeUntil } from \"rxjs/operators\";\n\n[url1,...,url10]\n  .pipe(\n    mergeMap( url => fetchURL(url).then( val => val )),\n    bufferTime(10000)\n  )\n  .subscribe({\n    next: resps => {\n      // do sth with resps:Blob[]\n    }\n  })\n```\n&emsp;&emsp;每次遇到 `rxjs` 都很头大，现在也没有发现一个比较完善清晰的教程，但它又真的很强大，后续要开专题好好学习记录这个东西。\n\n\n#### 2019/7/16\n一、今日阅读：[How to read an often-changing value from useCallback?](https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback)\n直接上官网代码：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  const textRef = useRef();\n\n  useEffect(() => {\n    textRef.current = text; // Write it to the ref\n  });\n\n  const handleSubmit = useCallback(() => {\n    const currentText = textRef.current; // Read it from the ref\n    alert(currentText);\n  }, [textRef]); // Don't recreate handleSubmit like [text] would do\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n&emsp;&emsp; 也就是说，当 `text` 的值经常发生变化时，即使 `handleSubmit` 用 `useCallback` 包裹了，还是会重新声明。解决办法是传入一个 `ref` 对象代替原始值。也可以写一个 custom hook ：\n1）官网的版本：\n```\nfunction useEventCallback(fn, dependencies) {\n  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n```\n实际使用：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  // Will be memoized even if `text` changes:\n  const handleSubmit = useEventCallback(() => {\n    alert(text);\n  }, [text]);\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n2）导师的版本：（他来了，他带着代码又来了）\n```\n/**\n * @param callback\n * @param oRefs\n */\nexport function useCallbackWithRefs<\n  Refs,\n  Callback extends (...args: any[]) => void\n>(callback: (refs: Refs) => Callback, oRefs: Refs) {\n  const refs = useRef(oRefs);\n  useEffect(\n    () => {\n      refs.current = oRefs;\n    },\n    [oRefs]\n  );\n\n  return useCallback(\n    (...args: any[]) => callback(refs.current)(...args),\n    []\n  ) as Callback;\n}\n```\n实际使用：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  \n  // 原先的 callback 也可以有参数\n  const handleSubmit = useCallbackWithRefs(\n    refs => (params: any) => {\n      // 要注意在函数内必须使用 `refs.xxx`，不能直接使用函数外部的任何变量 `xxx`\n      console.log(refs.text);\n  }, {text});\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n&emsp;&emsp;总的来说，官网的实现是将 `callback` 作为 `ref` 对象，并作为 `useCallback` 的依赖，不会频繁改变；如果在函数 `handleSubmit` 中要访问外部变量 `text` ，直接使用 `test` 即可。第二种实现方式是把经常变化的值作为 `ref` 对象，返回值 `useCallback` 第一个参数是 `refs => callback` ，依赖是空数组；这时如果要在函数 `handleSubmit` 中要访问外部变量 `text` ，必须使用 `refs.test` ，否则访问的只是 `test` 的初始值。\n&emsp;&emsp;React 博大精深，接下来要好好研读一下这个 [FAQ](https://reactjs.org/docs/hooks-faq.html)。\n二、今日网址\n&emsp;&emsp;一个 [emoji copy](https://www.emojicopy.com/) 网站，我们 👧 就是喜欢这些花里胡哨的东西。\n\n\n#### 2019/7/15\n&emsp;&emsp;今天在项目中使用 React Hooks 又踩坑了，看来自己对这部分还是没有理解透彻。在使用 `useCallback` 和 `useEffect` 时，要注意第二个参数，也就是传入的 `[deps]`。如果使用 `useCallback(fn,[deps])` ， `[deps]` 应该包含函数 `fn` 所涉及的所有变量；如果使用 `useEffect(fn,[deps])` ， 当 `deps` 的值变化时，就会执行 `fn`，因此`[deps]` 不一定要包含函数 `fn` 所涉及的所有变量，而是应该传入会引起该函数执行的那些参数。\n&emsp;&emsp;今日踩坑记录：为了优化子组件，作为 `props` 的函数都使用 `useCallback` 包裹了，并传入了空数组作为第二个参数，表示没有依赖。但是函数中的运算需要用到组件中一个变量，如果没有将该变量作为 `deps` ，这个变量就会一直保持初始值，值并不会改变，运行结果就会与预期不符。（真的太蠢了，缓缓躺倒）\n\n\n#### 2019/7/14\n周末当然是约会啦。😍\n\n\n#### 2019/7/13\n一、今日阅读：[How to compare oldValues and newValues on React Hooks useEffect?](https://stackoverflow.com/questions/53446020/how-to-compare-oldvalues-and-newvalues-on-react-hooks-useeffect)\n&emsp;&emsp; React class 组件提供了 `ComponentDidUpdate` 之类的方法来获取到当前 `props` 和前一个 `props` ，并进行比较，决定是否进行更新。函数式组件只有 `useEffect` 函数来模仿生命周期函数，当我们需要获取组件先前的 `props` 时，可以使用下面的 custom hook ：\n```\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n```\n&emsp;&emsp;之后在 `useEffect` 中使用上面的函数来模拟 `ComponentDidUpdate` ：\n```\nconst Component = (props) => {\n    const {receiveAmount, sendAmount } = props\n    const prevAmount = usePrevious({receiveAmount, sendAmount});\n    useEffect(() => {\n        if(prevAmount.receiveAmount !== receiveAmount) {\n\n         // process here\n        }\n        if(prevAmount.sendAmount !== sendAmount) {\n\n         // process here\n        }\n    }, [receiveAmount, sendAmount])\n}\n```\n&emsp;&emsp;有时候在 debug 时，我们想知道组件为什么会重新渲染，是那些 `props` 更新了，也可以使用上面的方法来获取 `prevProps`，并在函数组件最开始时写一个 `useEffect` 将参数都打印出来，使用 `===` 比较。 \n\n\n\n#### 2019/7/12\n一、今日技能\n&emsp;&emsp;项目中经常会涉及到 JSON 字符串的解析，解析出错就扑街了，一般是用 `try {...} catch {...}` 包裹。今天导师在 code review 时建议我使用如下函数，该函数也可以覆盖空字符串的检测：\n```\nfunction safeJsonParse<T>(str): { ok: true, value: T } | { ok: false } {\n  try {\n    return {\n      ok: true,\n      value: JSON.parse(str)\n    }\n  } catch {\n    return {\n      ok: false\n    }\n  }\n}\n```\n二、今日阅读：[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://imweb.io/topic/5b72d4ef15554e6d3409f817)。\n&emsp;&emsp;这一篇很好地梳理了进程、线程、浏览器**多进程**、浏览器内核**多线程**、JS单线程、JS运行机制的相关知识，很连贯，建议时不时回顾。简单记录几个知识点：\n1）进程是CPU资源分配的最小单位，线程是CPU调度的最小单位。（想当年考操作系统的时候还背得滚瓜烂熟）\n2）**浏览器是多进程的**，包括的主要进程有：\n- Browser进程（浏览器的主进程，只有一个）\n- 浏览器渲染进程（浏览器内核，Renderer进程，渲染进程，内部是多线程的）：默认每个Tab一个进程\n- 第三方插件进程\n- GPU进程：3D绘制\n\n3）重点是浏览器内核，它是多线程的，主要常驻线程有：\n- GUI渲染线程：渲染页面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制，repaint 和 reflow 等。\n- JS引擎线程：处理任务队列中的任务，与 GUI 渲染线程是互斥的。\n- 事件触发线程：控制事件循环，把事件添加到任务队列的末尾。\n- 定时触发线程：`setTimeout` 和 `setInterval`，同样也是计时完毕后添加到队列末尾。\n- 异步 http 请求线程\n\n4）Browser进程和浏览器内核之间是需要通信的\n5）时间循环机制 `Event Loop` ：JS分为同步任务和异步任务，同步任务都会在主线程上运行，形成一个执行栈；主线程之外，由事件触发线程管理一个**任务队列/事件队列**，异步任务的运行结果会被添加到任务队列中。一旦执行栈中所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到执行栈中开始执行。 \n6）进阶：macrotask / task 和 microtask/ job。ES6中的 `Promise` 就属于 microtask 微任务 ，而主代码块，事件队列中的时间如 `setTimeout` 和 `setInterval` 就属于 macrotask 宏任务。总结的运行机制就是：\n- 执行宏任务。（从执行栈中获取，如果没有就从事件队列中获取）\n- 执行过程中如果遇到微任务，就添加到微任务队列 Job Queues 中。（作者猜测这个队列由JS引擎线程维护，因为是在主线程下无缝执行的）\n- 宏任务执行完毕后，立即依次执行当前微任务队列中所有微任务。\n- 检查渲染，由 GUI 线程接管。\n- 渲染完毕后，由 JS 引擎线程接管，从时间队列中获取并执行下一个宏任务。\n\n7）在第六点中提到的是一个进阶的概念，对应一道题目，如果代码中依次有 `setTimeout` 和 `Promise` ，是会先打印出 `Promise` 的执行结果的。\n\n\n#### 2019/7/11\n&emsp;&emsp; React 16.8 提出了 `hook` 的概念，函数式组件也可以拥有自己的状态。现在的工作项目已经摒弃了 `class` ，改用函数式组件，正在慢慢摸索中。今天在腾讯[IMWeb前端博客](http://imweb.io/)中看到了两篇介绍 `React hook` 的文章，受益匪浅，简单记录一下。\n 一、[react hook——你可能不是“我”所认识的useEffect](https://imweb.io/topic/5cd845cadcd62f86299fcd76)\n&emsp;&emsp;这篇介绍了 `useEffect` 这个API，用它模拟了class组件的生命周期函数。`useEffect` 用于执行副作用，相当于 `ComponentDidMount` 和 `ComponentDidUpdate`。该API有两个参数和一个返回值。第一个参数是一个副作用函数，返回值是清除函数，相当于 `ComponentWillUnmount`，每一次 `render` 都会执行副作用和清除上一次副作用。**第二个参数是一个数组，传入的是副作用函数所需要的依赖，当任一依赖更新时，会重新生成一个新的副作用并执行；如果传入一个空数组，没有依赖，只会执行一次，相当于 `ComponentDidMount`；如果不传，就是没有说明自己有没有依赖（注意是不知道有没有，不是没有！），每次 `render` 时就执行，相当于 `ComponentDidUpdate` 。**\n&emsp;&emsp; 最后还讲了 `useEffect` 和 `useLayoutEffect` 的区别，简单来说前者是异步的，后者是同步的。还没好好深入这部分，TODO。\n二、[可能你的react函数组件从来没有优化过](https://imweb.io/topic/5d1e3657f7b5692b080f2651)\n&emsp;&emsp;优化问题真是我一个痛点。这篇文章很清楚地解释了 `Hooks` 一些可用于组件优化的API。强推！\n&emsp;&emsp; 特别地，文章介绍了当函数组件中传入的 `props` 值为函数时，由于每一次执行或重新执行，作用域里面一切都是重新开始，函数不是简单数据类型，不能画上等号，子组件都会重新渲染。针对这个问题文章提出了几种解决办法：\n1） 作为 `props` 的函数在函数组件外定义，函数组件用 `React.memo()` 包裹。\n &emsp;&emsp; `React.memo()` 类似于 `PureComponent` 和 `ComponentDidUpdate` ，如果函数组件的 `props` 值都一样，就会跳过该组件的执行，减少不必要的渲染，实现性能优化。\n2） 作为 `props` 的函数在函数组件内定义，使用`useCallBack` 或 `useMemo`包裹，函数组件用 `React.memo()` 包裹。\n&emsp;&emsp; `useCallback(() => {}, [deps])` 返回一个函数，当 `deps` 不变时（如传入空数组，表示没有依赖），都是同一个函数。`const a = useMemo(() => memorizeValue, [deps])`，当 `deps` 不变时，`a` 的值还是上次的 `memorizeValue`，省去了重新计算的过程。\n&emsp;&emsp; 注意当 `memorizeValue` 是一个函数时，`useCallback(fn, inputs) <=> useMemo(() => fn, inputs)`。\n\n\n#### 2019/7/10\n&emsp;&emsp;今天在项目中接触到了 `symbol`，鉴于之前一直没有注意这个数据类型，在今天补上。 `symbol` 是 ES6 新增的**基本**数据类型。它的使用如下：\n```\nconst s1 = Symbol();\nconst s2 = Symbol();\nconsole.log(s1 === s2); // false\n\nconst s3 = new Symbol() // TypeError: Symbol is not a constructor\nSymbol(\"foo\") === Symbol(\"foo\"); // false\n```\n`Symbol()` 返回的每个 `symbol` 值都是唯一的，可以接受一个字符串作为参数。它最常被用于对象属性的标识符，如：\n```\nconst obj = {}\nconst foo = Symbol(\"foo\")\nobj[foo] = \"foo\"\nobj.bar = \"bar\"\n\nconsole.log(obj); // { bar: \"bar\" , Symbol(foo): \"foo\"}\nconsole.log(foo in obj); // true\nconsole.log(obj[foo]); // foo\nconsole.log(Object.keys(obj)); // [\"bar\"]\nconsole.log(Object.getOwnPropertySymbols(obj)) // [Symbol(foo)]\n```\n也就是说， `Object.key()` 不会返回 `symbol` 值，同理，`Object.getOwnPropertyNames()`、`for..in`、`for...of` 也不会返回。`JSON.stringify()` 也会忽略：\n```\nJSON.stringify({[Symbol('foo')]: 'foo'});                 \n// '{}'\n```\n`Symbol` 还有两个方法。 `Symbol.for(key)` 是根据指定的 `key` 搜索现有的 `symbol` 并返回, 如果找不到，会使用 `key` 在全局的 `symbol` 注册表中创建一个新的 `symbol` 。`Symbol.keyFor(sym)` 是在全局注册表中检索，返回共享的 `symbol key` 。\n\n\n#### 2019/7/9\n一个不好的编程习惯：让函数在内部获取自己所需的依赖。例如：\n```\n// 一个可复用函数\nfunction doSomething(key: string) {\n    return (\n        <Button\n            loading = {key===\"str1\"? Compoment1 : Compoment2}\n        >\n            button\n        </Button>\n    )\n}\n```\n`lodaing` 所需的组件应该是作为函数参数传入的，不然如果我们新增了一个 `key`，很容易忽略了该地方的修改。这个观点类似于依赖反转。","slug":"FrontEnd-Daily-Learning-2019-07-08","published":1,"updated":"2020-03-04T02:57:52.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7ef1vha0006qsue6h208ah6","content":"<h4 id=\"前言\">前言</h4>\n<p>📝 recap and cheat sheet ，记录每天学到的知识/想法。<br>\n🔊 每日一问：今天你比昨天更博学了吗？</p>\n<h4 id=\"2019825\">2019/8/25</h4>\n<p>今日踩坑记录：<br>\n展开语法（spread syntax）只能取到 enumerable properties。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const imageData = new ImageData(200, 100);</span><br><span class=\"line\">// ImageData &#123; width: 200, height: 100, data: Uint8ClampedArray[80000] &#125;</span><br><span class=\"line\">const result = &#123;...imageData&#125;</span><br><span class=\"line\">// result 只会包含 data ，不能取到 width 和 height</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019824\">2019/8/24</h4>\n<p>避免组件重新挂载，可以使用事件的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BussinessProvider &#123;</span><br><span class=\"line\">  sp$ = new Subject&lt;&#123;url: string, slic: string&#125;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Canvas &#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">     this.props.sp$.pipe(takeUntil(this.unmount$)).subscribe(ev =&gt; &#123;</span><br><span class=\"line\">        if (ev.url === this.url) &#123;</span><br><span class=\"line\">           this.handleSuperPixelChange(ev.slic)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019824\">2019/8/24</h4>\n<p>一、Promise</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">  // do something...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(onFulfilled[, onRejected]);</span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">  // fulfillment</span><br><span class=\"line\">&#125;, reason =&gt; &#123;</span><br><span class=\"line\">  // rejection</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.catch(onRejected);</span><br><span class=\"line\">promise.catch(function(reason) &#123;</span><br><span class=\"line\">   // rejection</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简单来说，<code>reject(value)</code> 可以被 <code>promise.then</code> 第二个函数参数捕获，也可以被 <code>promise.catch</code> 捕获。如果两者同时存在，会被 <code>promise.then</code> 第二个函数参数捕获，<code>promise.catch</code> 无输出。</p>\n<p>下载图片的典型例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function loadImage(url) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    let img = new Image();</span><br><span class=\"line\">    // img.onload = () =&gt; resolve(img)</span><br><span class=\"line\">    img.addEventListener(&apos;load&apos;, e =&gt; resolve(img));</span><br><span class=\"line\">    // img.onerror = () =&gt; reject(XXX)</span><br><span class=\"line\">    img.addEventListener(&apos;error&apos;, () =&gt; &#123;</span><br><span class=\"line\">      reject(new Error(`Failed to load image&apos;s URL: $&#123;url&#125;`));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    img.src = url;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">loadImage(&apos;http://thecatapi.com/api/images/get?format=src&amp;type=jpg&amp;size=small&apos;)</span><br><span class=\"line\">  .then(img =&gt; document.getElementById(&apos;image-holder&apos;).appendChild(img))</span><br><span class=\"line\">  .catch(error =&gt; console.error(error));</span><br></pre></td></tr></table></figure>\n<p>二、await<br>\n<code>[rv] = await expression</code>:</p>\n<blockquote>\n<p>TL;DR returns the fulfilled value of the promise,<br>\nThe await expression causes async function execution to pause until a Promise is settled, that is fulfilled or rejected, and to resume execution of the async function after fulfillment. When resumed, the value of the await expression is that of the fulfilled Promise.<br>\nIf the Promise is rejected, the await expression throws the rejected value.<br>\nIf the value of the expression following the await operator is not a Promise, it’s converted to a resolved Promise.</p>\n</blockquote>\n<h4 id=\"2019823\">2019/8/23</h4>\n<p><code>String.prototype.localeCompare()</code></p>\n<blockquote>\n<p>return a number, indicating whether the reference string comes before, after or is the same as the compareString in sort order. Returns one of three values:<br>\n-1: if the reference string is sorted before the compareString<br>\n0: if the two strings are equal<br>\n1: if the reference string is sorted after the compareString</p>\n</blockquote>\n<p><code>Array.prototype.sort()</code></p>\n<blockquote>\n<p>sorts the elements of an array in place and returns the sorted array.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">items.sort((a,b) =&gt; a.localeCompare(b))</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019821\">2019/8/21</h4>\n<p>今日阅读：<br>\n<a href=\"https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci\" target=\"_blank\" rel=\"noopener\">What is the difference between “npm install” and “npm ci”?</a><br>\n<a href=\"https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8\" target=\"_blank\" rel=\"noopener\">Everything You Wanted To Know About package-lock.json But Were Too Afraid To Ask</a></p>\n<h4 id=\"2019820\">2019/8/20</h4>\n<p>模仿 react hook <code>useState</code> 的第二个参数：<br>\n  因为在 jest 测试中某个函数的参数是 <code>useState</code> 的第二个参数，写了一个替代，不过不确定是否有错。😳</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// for example</span><br><span class=\"line\">const [str,setStr] = useState&lt;string[]&gt;([]);</span><br><span class=\"line\"></span><br><span class=\"line\">// fake setStr</span><br><span class=\"line\">let str:string[] = [];</span><br><span class=\"line\">const setStr = (val: string[] | ((prev:string[]) =&gt; string[])) =&gt; &#123;</span><br><span class=\"line\">  if (typeof val === &quot;object&quot;) &#123;</span><br><span class=\"line\">    str = val;</span><br><span class=\"line\">  &#125; else if (typeof val === &quot;function&quot;) &#123;</span><br><span class=\"line\">    str = val(str)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019819\">2019/8/19</h4>\n<p>今日阅读：<a href=\"https://searchenginelaws.com/seo/what-is-rel-noopener-noreferrer-tag/\" target=\"_blank\" rel=\"noopener\">What is rel=noopener noreferrer link</a><br>\n  使用 <code>a</code> 标签，且属性 <code>target=&quot;_blank&quot;</code> 时，需要加上 <code>rel=&quot;noopener noreferrer&quot;</code> 。可以防止新窗口利用 <code>window.opener</code> 的特性窃取原窗口信息。具体而言，如果 window A 打开了 window B，那么 B.opener 会返回 A。如果加上 <code>rel=&quot;noopener&quot;</code> ，会返回 null 。</p>\n<h4 id=\"2019812\">2019/8/12</h4>\n<p>一、download files using axios</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &quot;axios&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.get(url,&#123;</span><br><span class=\"line\">  responseType: &apos;blob&apos;, // important</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &apos;Authorization&apos;: AuthStr </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(resp =&gt; &#123;</span><br><span class=\"line\">  const &#123;data&#125; = resp;</span><br><span class=\"line\">  const file = new File([data],&quot;data.txt&quot;);</span><br><span class=\"line\">  const objectURL = URL.createObjectURL(file);</span><br><span class=\"line\">  const a = document.createElement(&quot;a&quot;);</span><br><span class=\"line\">  a.href = objectURL;</span><br><span class=\"line\">  a.download = &quot;data.txt&quot;;</span><br><span class=\"line\">  a.click();</span><br><span class=\"line\">  URL.revokeObjectURL(objectURL);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>  如果是单次点击下载多个文件，Chrome 只会弹出一个弹窗下载最后一个文件。这个时候可以加上 <code>setTimeout</code> ，触发多次下载，或是加上 <code>a.target = &quot;_blank&quot;</code> ，打开多个新窗口。<br>\n二、curl<br>\n查看命令：<br>\n<code>curl --help</code><br>\n-H 指定Header：<br>\n<code>curl -H &quot;Authorization: XXXXXXXX&quot; URL</code><br>\n<code>curl POST -d data -H &quot;Authorization: XXXXXXXX&quot; URL</code></p>\n<h4 id=\"201989\">2019/8/9</h4>\n<p>一、<a href=\"https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/\" target=\"_blank\" rel=\"noopener\">useRef vs useState: Should we re-render or not?</a><br>\n<img src=\"FE_20190809.png\" alt=\"FE_20190808\"><br>\n二、Hooks 监听键盘事件<br>\nkeyCode: <a href=\"https://keycode.info/\" target=\"_blank\" rel=\"noopener\">https://keycode.info/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function useKeyPress(targetKey) &#123;</span><br><span class=\"line\">  const [keyPressed, setKeyPressed] = useState(false);</span><br><span class=\"line\"></span><br><span class=\"line\">  function downHandler(&#123; key &#125;) &#123;</span><br><span class=\"line\">    if (key === targetKey) &#123;</span><br><span class=\"line\">      setKeyPressed(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const upHandler = (&#123; key &#125;) =&gt; &#123;</span><br><span class=\"line\">    if (key === targetKey) &#123;</span><br><span class=\"line\">      setKeyPressed(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    window.addEventListener(&apos;keydown&apos;, downHandler);</span><br><span class=\"line\">    window.addEventListener(&apos;keyup&apos;, upHandler);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      window.removeEventListener(&apos;keydown&apos;, downHandler);</span><br><span class=\"line\">      window.removeEventListener(&apos;keyup&apos;, upHandler);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  return keyPressed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"201988\">2019/8/8</h4>\n<p>  工程中经常会看到 CI/CD 的概念。CI 指的是持续集成，侧重于简化发布准备工作的实践，比如自动测试；CD 指的是持续交付，意味着不仅让测试自动化，让发布流程也自动化了。更多概念对比可以参考：<a href=\"https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment\" target=\"_blank\" rel=\"noopener\">Continuous integration VS continuous delivery VS continuous deployment</a><br>\n  下面这个图很清晰地描述了三者的不同：<br>\n<img src=\"FE_20190808.png\" alt=\"FE_20190808\"><br>\n  在 gitlab 上的实践可以参考：<a href=\"https://mp.weixin.qq.com/s/z2f1i2FgrVGofQR6nKTd1A\" target=\"_blank\" rel=\"noopener\">基于 GitLab CI/CD 的自动化构建、发布实践</a></p>\n<h4 id=\"201987\">2019/8/7</h4>\n<p>Typescript: <a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions\" target=\"_blank\" rel=\"noopener\">Discriminated Unions</a><br>\n  当我们某个参数可能有多个类型，而这些类型中又有公共的属性时，就可以使用这种形式约束。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Each interface has a kind property with a different string literal type. </span><br><span class=\"line\">// The kind property is called the discriminant or tag. </span><br><span class=\"line\">interface Square &#123;</span><br><span class=\"line\">    kind: &quot;square&quot;;</span><br><span class=\"line\">    size: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Rectangle &#123;</span><br><span class=\"line\">    kind: &quot;rectangle&quot;;</span><br><span class=\"line\">    width: number;</span><br><span class=\"line\">    height: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Circle &#123;</span><br><span class=\"line\">    kind: &quot;circle&quot;;</span><br><span class=\"line\">    radius: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// put the interfaces into a union</span><br><span class=\"line\">type Shape = Square | Rectangle | Circle;</span><br><span class=\"line\"></span><br><span class=\"line\">// use the discriminated union</span><br><span class=\"line\">function area(s: Shape) &#123;</span><br><span class=\"line\">    switch (s.kind) &#123;</span><br><span class=\"line\">        case &quot;square&quot;: return s.size * s.size;</span><br><span class=\"line\">        case &quot;rectangle&quot;: return s.height * s.width;</span><br><span class=\"line\">        case &quot;circle&quot;: return Math.PI * s.radius ** 2;</span><br><span class=\"line\">        default: return assertNever(s); // error here if there are missing cases</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Exhaustiveness checking </span><br><span class=\"line\">function assertNever(x: never): never &#123;</span><br><span class=\"line\">    throw new Error(&quot;Unexpected object: &quot; + x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"201986\">2019/8/6</h4>\n<p>Stack Overflow: <a href=\"https://stackoverflow.com/questions/54069253/usestate-set-method-not-reflecting-change-immediately\" target=\"_blank\" rel=\"noopener\">useState set method not reflecting change immediately.</a><br>\n  今天在实践中发现，<code>setState</code> 后马上打印，并不会取到更新后的值。查阅资料后发现这个函数是一个异步的函数，不会立即更新，但会触发重新渲染。如下：<br>\n<img src=\"FE_20190806.png\" alt=\"FE_20190806\"></p>\n<h4 id=\"201981\">2019/8/1</h4>\n<p>一、<a href=\"https://javascript.info/fetch-api\" target=\"_blank\" rel=\"noopener\">Fetch API</a><br>\n  用 fetch 来请求网络资源，可以配置不同的参数来解决缓存、跨域等问题，如下示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 不缓存请求结果 </span><br><span class=\"line\">// https://stackoverflow.com/questions/29246444/fetch-how-do-you-make-a-non-cached-request</span><br><span class=\"line\">const headers = new Headers();</span><br><span class=\"line\">headers.append(&quot;pragma&quot;, &quot;no-cache&quot;);</span><br><span class=\"line\">headers.append(&quot;cache-control&quot;, &quot;no-store&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 完全忽略 http-cache ，每次都从服务器请求数据</span><br><span class=\"line\">// https://developer.mozilla.org/en-US/docs/Web/API/Request/cache</span><br><span class=\"line\">const cache: RequestCache = &quot;no-store&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 请求模式，若有的请求会因为 cors 而失败，可以设置为 &quot;no-cors&quot;</span><br><span class=\"line\">// https://developer.mozilla.org/en-US/docs/Web/API/Request/mode</span><br><span class=\"line\">const mode: RequestMode = needCors ? &quot;cors&quot; : &quot;no-cors&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">await fetch(url. &#123;headers, cache, mode&#125;)</span><br><span class=\"line\">  .then(res =&gt; res.blob())</span><br><span class=\"line\">  .then(blob =&gt; &#123;</span><br><span class=\"line\">    // doSomething with blob</span><br><span class=\"line\">    const url = URL.createObjectURL(blob)</span><br><span class=\"line\">    let a = document.createElement(&apos;a&apos;)</span><br><span class=\"line\">    a.download = &apos;example.zip&apos;</span><br><span class=\"line\">    a.href = url</span><br><span class=\"line\">    document.body.appendChild(a)</span><br><span class=\"line\">    a.click()</span><br><span class=\"line\">    document.body.removeChild(a)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(err =&gt; &#123;</span><br><span class=\"line\">    console.log(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .finally(() =&gt; &#123;</span><br><span class=\"line\">    // doSomething</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>  关于 <code>res.blob()</code> ，可以参考知乎上<a href=\"https://zhuanlan.zhihu.com/p/32909043\" target=\"_blank\" rel=\"noopener\">谈一谈 Fetch API 中的 “res.blob()”</a>；也可以参考 <a href=\"https://github.github.io/fetch/\" target=\"_blank\" rel=\"noopener\">fetch documentation</a> ，这一篇比较详细，也提供了较多其他的例子。<br>\n关于浏览器缓存问题，Medium 上这篇 <a href=\"https://medium.com/@codebyamir/a-web-developers-guide-to-browser-caching-cc41f3b73e7c\" target=\"_blank\" rel=\"noopener\">A Web Developer’s Guide to Browser Caching</a> 写得不错。如果存在代理服务器，即使我们设置了 <code>mode: 'no-store'</code> ，代理服务器也会缓存。为了避免这个情况，我们可以在每次发送请求时构造新的 URL ，加上时间戳 <code>?t=Date.now()</code> 。🐮🍺<br>\n二、Jest<br>\n  我们在使用 jest 测试时，有时候需要引入一些外部文件/外部变量，如从 <code>config.json</code> 文件中引入某个变量。为了在测试文件中可以访问到该变量，我们可以在 <code>jest.config.js</code> 中配置全局变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  globals: &#123;</span><br><span class=\"line\">    API_BASE: &quot;&quot;,</span><br><span class=\"line\">    DATA_API: &quot;&quot;,</span><br><span class=\"line\">    TRACK_API: &quot;&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setupFiles: [&quot;./jestSetup.ts&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  由于 <code>globals</code> 只支持 JSON 格式的变量，如果我们需要定义全局函数，则可以使用 <code>setupFiles</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// jestSetup.ts</span><br><span class=\"line\">(global as any).fn= () =&gt; &#123;&#125;;</span><br><span class=\"line\">(global as any).variable = &quot;XXX&quot;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019731\">2019/7/31</h4>\n<p>1）<code>position: fixed</code> 和 flex 布局是不能同时起作用的。绝对布局脱离文档流，不会参与到 flex layout 中。如果想实现左侧菜单栏，右侧内容，两者不同时滚动（菜单栏 fixed），但菜单栏的大小可以改变（flex 父布局）。可以让父容器是 flex 布局，左侧菜单栏和右侧内容区域都是 flex element ， 菜单栏内部再有一个 <code>position: fixed</code> 的 div 。<br>\n2）如果想让 <code>position: fixed</code> 的元素相对父容器定位，可以给父容器增加 CSS 属性 <code>transform: translate(0,0)</code> 。参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">MDN - position</a></p>\n<blockquote>\n<p>fixed: It is positioned relative to the initial containing block established by the viewport, except when one of its ancestors has a transform, perspective, or filter property set to something other than none.</p>\n</blockquote>\n<h4 id=\"2019730\">2019/7/30</h4>\n<p><code>useEffect</code> 中的异步请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 错误写法， return 必须是 cleanup function</span><br><span class=\"line\">useEffect(async () =&gt; &#123;</span><br><span class=\"line\">  const newVal = await asyncCall();</span><br><span class=\"line\">  setVal(newVal);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确写法</span><br><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  asyncCall().then(resp =&gt; setVal(resp.data));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>好文共享：<a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\" target=\"_blank\" rel=\"noopener\">How to fetch data with React Hooks?</a>，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  async function fetchMyAPI() &#123;</span><br><span class=\"line\">    let url = &apos;http://something/&apos; + productId;</span><br><span class=\"line\">    let config = &#123;&#125;;</span><br><span class=\"line\">    const response = await myFetch(url);</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  fetchMyAPI();</span><br><span class=\"line\">&#125;, [productId]);</span><br></pre></td></tr></table></figure>\n<p>如果要保证请求按顺序发出，可以采用如下写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  let didCancel = false;</span><br><span class=\"line\"></span><br><span class=\"line\">  async function fetchMyAPI() &#123;</span><br><span class=\"line\">    let url = &apos;http://something/&apos; + productId;</span><br><span class=\"line\">    let config = &#123;&#125;;</span><br><span class=\"line\">    const response = await myFetch(url);</span><br><span class=\"line\">    if (!didCancel) &#123; // Ignore if we started fetching something else</span><br><span class=\"line\">      console.log(response);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  fetchMyAPI();</span><br><span class=\"line\">  return () =&gt; &#123; didCancel = true; &#125;; // Remember if we start fetching something else</span><br><span class=\"line\">&#125;, [productId]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019729\">2019/7/29</h4>\n<p>一、<a href=\"https://stackoverflow.com/questions/30795525/performance-now-vs-date-now\" target=\"_blank\" rel=\"noopener\">performance.now() vs Date.now()</a><br>\n  在程序中打印执行时间时，使用 <code>performance.now(）</code> 更准确。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const start = performance.now();</span><br><span class=\"line\">doSomething();</span><br><span class=\"line\">const end = performance.now();</span><br><span class=\"line\">console.log(&quot;Call to doSomething took &quot; + (start - end) + &quot; milliseconds.&quot;);</span><br></pre></td></tr></table></figure>\n<p>二、<a href=\"https://stackoverflow.com/questions/47738344/does-javascript-slice-method-return-a-shallow-copy\" target=\"_blank\" rel=\"noopener\">Does javascript slice method return a shallow copy?</a><br>\n  mdn 上对 <code>slice()</code> 方法的介绍：</p>\n<blockquote>\n<p>The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included) where begin and end represent the index of items in that array. The original array will not be modified.</p>\n</blockquote>\n<p>  注意这里的浅复制指的是对数组中值的浅复制，而不是对整个数组的浅复制。如果是一个字符串数组，则修改新数组时，原数组不会改变；如果是对象数组，修改新数组对象值时，原数组也会发生变化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const animals = [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;];</span><br><span class=\"line\">const newAnimals = animals.slice(2);</span><br><span class=\"line\"></span><br><span class=\"line\">newAnimals[0].name = &apos;aaa&apos;;</span><br><span class=\"line\">console.log(newAnimals); // [&#123;name: &apos;aaa&apos;&#125;]</span><br><span class=\"line\">console.log(animals);    // [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;aaa&apos;&#125;]</span><br></pre></td></tr></table></figure>\n<p>  注意如果是重新赋值，则等于重新分配空间，不会改变原数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const animals = [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;];</span><br><span class=\"line\">const newAnimals = animals.slice(2);</span><br><span class=\"line\"></span><br><span class=\"line\">newAnimals[0] = &#123;name: &apos;aaa&apos;&#125;;</span><br><span class=\"line\">console.log(newAnimals); // [&#123;name: &apos;aaa&apos;&#125;]</span><br><span class=\"line\">console.log(animals);    // [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;]</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019726\">2019/7/26</h4>\n<p>  应用场景：我们需要请求并更新菜单栏中任务的状态，如果一个请求完成立马更新会导致 React 频繁刷新，需要缓冲批处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; runInAction &#125; from &quot;mobx&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">let handlers: Array&lt;() =&gt; void&gt; = [];</span><br><span class=\"line\">const runHandlers = () =&gt; &#123;</span><br><span class=\"line\">  runInAction(() =&gt; &#123;</span><br><span class=\"line\">    handlers.forEach(f =&gt; f());</span><br><span class=\"line\">    handlers = [];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (const task of tasks) &#123;</span><br><span class=\"line\">  const &#123;data&#125; = await requestFn();</span><br><span class=\"line\">  </span><br><span class=\"line\">  handlers.push(() =&gt; &#123;</span><br><span class=\"line\">    // deal with data, update state</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if(handlers.length &gt; 30) &#123;</span><br><span class=\"line\">    runHandlers();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">runHandlers();</span><br></pre></td></tr></table></figure>\n<p>  上述代码主要是利用了自定义的 <code>handlers</code> 来暂存状态更新函数，之后使用 mobx 提供的 <code>runInAction</code> 执行函数并更新状态，更新状态都需要使用 <code>action</code> 函数， <code>runInAction</code> 接受一个代码块并在一个(匿名)操作中执行，有利于动态创建和执行操作，<code>runInAction(f) = action(f)()</code>。此外，必要时还可加上 <code>lodash.memoize(func,[resolver])</code>，记录主函数请求结果。</p>\n<blockquote>\n<p>For one-time-actions runInAction(name?, fn) can be used, which is sugar for action(name, fn)()</p>\n</blockquote>\n<h4 id=\"2019718\">2019/7/18</h4>\n<p>一、编程模式：<br>\n   首先先记住这几种编程模式的中文：Imperative Programming 是命令式编程，Declarative Programming 是声明式编程，Reactive Programming 是响应式编程。（流下了英文不好的泪水）<br>\n1）先看命令式编程和声明式编程的区别，直接上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 命令式编程 imperative programming</span><br><span class=\"line\">const array = [0,1,2,3,4,5];</span><br><span class=\"line\">const output = [];</span><br><span class=\"line\">for (let i = 0; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">  const tmp = array[i] * 2;</span><br><span class=\"line\">  output.push(tmp)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(output) // =&gt; [0,2,4,6,8,10]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明式编程 declarative programming</span><br><span class=\"line\">const array = [0,1,2,3,4,5];</span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">console.log(output) // =&gt; [0,2,3,6,8,10]</span><br></pre></td></tr></table></figure>\n<p>  很明显可以看到，命令式编程的关注点在于 how ，我们需要一步步告诉机器接下来要做什么，告诉他怎么去遍历一个数组，怎么去运算得到最后的结果，怎么去输出；声明式编程的关注点在于 what ，我们只关注最后的结果，由机器自己去摸索过程，如直接调用 <code>map</code> 函数，只告诉程序我们需要一个2倍输出。<br>\n2）接着看声明式编程和响应式编程的对比<br>\n  可以阅读：<a href=\"https://codepen.io/HunorMarton/post/imperative-vs-reactive\" target=\"_blank\" rel=\"noopener\">Imperative vs Reactive</a>，解释很清晰，比喻也很形象，但我觉得文章里的 Imperative 应该改成 Declarative 比较准确。继续沿用上面的例子，修改一下声明式编程的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明式编程 declarative programming</span><br><span class=\"line\">const array = [1,2];</span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">output.forEach(item =&gt; console.log(item)) // =&gt; 2 4</span><br><span class=\"line\">array.push(3);  // =&gt; no output </span><br><span class=\"line\">array.push(4);  // =&gt; no output</span><br></pre></td></tr></table></figure>\n<p>响应式编程的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Subject &#125; from `rxjs`;</span><br><span class=\"line\">let array = new Subject();</span><br><span class=\"line\">array.next(1);</span><br><span class=\"line\">array.next(2);</span><br><span class=\"line\"></span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">output.forEach(item =&gt; console.log(item)); // =&gt; 2 4</span><br><span class=\"line\"></span><br><span class=\"line\">array.next(3); // =&gt; 6</span><br><span class=\"line\">array.next(4); // =&gt; 8</span><br></pre></td></tr></table></figure>\n<p>  首先要注意的是，这两种方式中的 <code>map</code> ， <code>forEach</code> 等函数并不是一样的，内部实现机制是不同的。我们可以发现区别：在声明式编程中，如果在最后向原数组添加值，并不会打印出来，因为这是在 <code>console.log</code> 语句执行后发生的。但在响应式编程里，任何变化都可以被反应出来，它引入了一个<strong>异步数据流</strong>（asynchronous data streams）的概念，可以随时创建、更改或组合这些数据流，所以打印事件是一个 continuous observation case。<br>\n二、类库<br>\n<a href=\"https://github.com/bvaughn/react-virtualized\" target=\"_blank\" rel=\"noopener\">react-virtualized</a> 的轻量级版 <a href=\"https://github.com/bvaughn/react-window\" target=\"_blank\" rel=\"noopener\">react-window</a>，用于高效渲染长列表。</p>\n<h4 id=\"2019717\">2019/7/17</h4>\n<p>  如果我们在项目中需要请求很多图片，想要实现请求出错时继续发送请求，成功时返回数据，可以使用 <code>Promise</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fetchURL(url: string):Promise&lt;Blob&gt; &#123;</span><br><span class=\"line\">  return Axios.get(url, &#123;responeType: &quot;blob&quot;&#125;)</span><br><span class=\"line\">              .then( resp =&gt; Promise.resolve(resp.data) )</span><br><span class=\"line\">              .catch( () =&gt; fetchURL(url) )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后可以使用 <code>rxjs</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mergeMap, bufferTime, takeUntil &#125; from &quot;rxjs/operators&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">[url1,...,url10]</span><br><span class=\"line\">  .pipe(</span><br><span class=\"line\">    mergeMap( url =&gt; fetchURL(url).then( val =&gt; val )),</span><br><span class=\"line\">    bufferTime(10000)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .subscribe(&#123;</span><br><span class=\"line\">    next: resps =&gt; &#123;</span><br><span class=\"line\">      // do sth with resps:Blob[]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>  每次遇到 <code>rxjs</code> 都很头大，现在也没有发现一个比较完善清晰的教程，但它又真的很强大，后续要开专题好好学习记录这个东西。</p>\n<h4 id=\"2019716\">2019/7/16</h4>\n<p>一、今日阅读：<a href=\"https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\" target=\"_blank\" rel=\"noopener\">How to read an often-changing value from useCallback?</a><br>\n直接上官网代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  const textRef = useRef();</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    textRef.current = text; // Write it to the ref</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleSubmit = useCallback(() =&gt; &#123;</span><br><span class=\"line\">    const currentText = textRef.current; // Read it from the ref</span><br><span class=\"line\">    alert(currentText);</span><br><span class=\"line\">  &#125;, [textRef]); // Don&apos;t recreate handleSubmit like [text] would do</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   也就是说，当 <code>text</code> 的值经常发生变化时，即使 <code>handleSubmit</code> 用 <code>useCallback</code> 包裹了，还是会重新声明。解决办法是传入一个 <code>ref</code> 对象代替原始值。也可以写一个 custom hook ：<br>\n1）官网的版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function useEventCallback(fn, dependencies) &#123;</span><br><span class=\"line\">  const ref = useRef(() =&gt; &#123;</span><br><span class=\"line\">    throw new Error(&apos;Cannot call an event handler while rendering.&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ref.current = fn;</span><br><span class=\"line\">  &#125;, [fn, ...dependencies]);</span><br><span class=\"line\"></span><br><span class=\"line\">  return useCallback(() =&gt; &#123;</span><br><span class=\"line\">    const fn = ref.current;</span><br><span class=\"line\">    return fn();</span><br><span class=\"line\">  &#125;, [ref]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  // Will be memoized even if `text` changes:</span><br><span class=\"line\">  const handleSubmit = useEventCallback(() =&gt; &#123;</span><br><span class=\"line\">    alert(text);</span><br><span class=\"line\">  &#125;, [text]);</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2）导师的版本：（他来了，他带着代码又来了）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param callback</span><br><span class=\"line\"> * @param oRefs</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function useCallbackWithRefs&lt;</span><br><span class=\"line\">  Refs,</span><br><span class=\"line\">  Callback extends (...args: any[]) =&gt; void</span><br><span class=\"line\">&gt;(callback: (refs: Refs) =&gt; Callback, oRefs: Refs) &#123;</span><br><span class=\"line\">  const refs = useRef(oRefs);</span><br><span class=\"line\">  useEffect(</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">      refs.current = oRefs;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [oRefs]</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  return useCallback(</span><br><span class=\"line\">    (...args: any[]) =&gt; callback(refs.current)(...args),</span><br><span class=\"line\">    []</span><br><span class=\"line\">  ) as Callback;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 原先的 callback 也可以有参数</span><br><span class=\"line\">  const handleSubmit = useCallbackWithRefs(</span><br><span class=\"line\">    refs =&gt; (params: any) =&gt; &#123;</span><br><span class=\"line\">      // 要注意在函数内必须使用 `refs.xxx`，不能直接使用函数外部的任何变量 `xxx`</span><br><span class=\"line\">      console.log(refs.text);</span><br><span class=\"line\">  &#125;, &#123;text&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  总的来说，官网的实现是将 <code>callback</code> 作为 <code>ref</code> 对象，并作为 <code>useCallback</code> 的依赖，不会频繁改变；如果在函数 <code>handleSubmit</code> 中要访问外部变量 <code>text</code> ，直接使用 <code>test</code> 即可。第二种实现方式是把经常变化的值作为 <code>ref</code> 对象，返回值 <code>useCallback</code> 第一个参数是 <code>refs =&gt; callback</code> ，依赖是空数组；这时如果要在函数 <code>handleSubmit</code> 中要访问外部变量 <code>text</code> ，必须使用 <code>refs.test</code> ，否则访问的只是 <code>test</code> 的初始值。<br>\n  React 博大精深，接下来要好好研读一下这个 <a href=\"https://reactjs.org/docs/hooks-faq.html\" target=\"_blank\" rel=\"noopener\">FAQ</a>。<br>\n二、今日网址<br>\n  一个 <a href=\"https://www.emojicopy.com/\" target=\"_blank\" rel=\"noopener\">emoji copy</a> 网站，我们 👧 就是喜欢这些花里胡哨的东西。</p>\n<h4 id=\"2019715\">2019/7/15</h4>\n<p>  今天在项目中使用 React Hooks 又踩坑了，看来自己对这部分还是没有理解透彻。在使用 <code>useCallback</code> 和 <code>useEffect</code> 时，要注意第二个参数，也就是传入的 <code>[deps]</code>。如果使用 <code>useCallback(fn,[deps])</code> ， <code>[deps]</code> 应该包含函数 <code>fn</code> 所涉及的所有变量；如果使用 <code>useEffect(fn,[deps])</code> ， 当 <code>deps</code> 的值变化时，就会执行 <code>fn</code>，因此<code>[deps]</code> 不一定要包含函数 <code>fn</code> 所涉及的所有变量，而是应该传入会引起该函数执行的那些参数。<br>\n  今日踩坑记录：为了优化子组件，作为 <code>props</code> 的函数都使用 <code>useCallback</code> 包裹了，并传入了空数组作为第二个参数，表示没有依赖。但是函数中的运算需要用到组件中一个变量，如果没有将该变量作为 <code>deps</code> ，这个变量就会一直保持初始值，值并不会改变，运行结果就会与预期不符。（真的太蠢了，缓缓躺倒）</p>\n<h4 id=\"2019714\">2019/7/14</h4>\n<p>周末当然是约会啦。😍</p>\n<h4 id=\"2019713\">2019/7/13</h4>\n<p>一、今日阅读：<a href=\"https://stackoverflow.com/questions/53446020/how-to-compare-oldvalues-and-newvalues-on-react-hooks-useeffect\" target=\"_blank\" rel=\"noopener\">How to compare oldValues and newValues on React Hooks useEffect?</a><br>\n   React class 组件提供了 <code>ComponentDidUpdate</code> 之类的方法来获取到当前 <code>props</code> 和前一个 <code>props</code> ，并进行比较，决定是否进行更新。函数式组件只有 <code>useEffect</code> 函数来模仿生命周期函数，当我们需要获取组件先前的 <code>props</code> 时，可以使用下面的 custom hook ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function usePrevious(value) &#123;</span><br><span class=\"line\">  const ref = useRef();</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ref.current = value;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return ref.current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  之后在 <code>useEffect</code> 中使用上面的函数来模拟 <code>ComponentDidUpdate</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Component = (props) =&gt; &#123;</span><br><span class=\"line\">    const &#123;receiveAmount, sendAmount &#125; = props</span><br><span class=\"line\">    const prevAmount = usePrevious(&#123;receiveAmount, sendAmount&#125;);</span><br><span class=\"line\">    useEffect(() =&gt; &#123;</span><br><span class=\"line\">        if(prevAmount.receiveAmount !== receiveAmount) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         // process here</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(prevAmount.sendAmount !== sendAmount) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         // process here</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, [receiveAmount, sendAmount])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  有时候在 debug 时，我们想知道组件为什么会重新渲染，是那些 <code>props</code> 更新了，也可以使用上面的方法来获取 <code>prevProps</code>，并在函数组件最开始时写一个 <code>useEffect</code> 将参数都打印出来，使用 <code>===</code> 比较。</p>\n<h4 id=\"2019712\">2019/7/12</h4>\n<p>一、今日技能<br>\n  项目中经常会涉及到 JSON 字符串的解析，解析出错就扑街了，一般是用 <code>try {...} catch {...}</code> 包裹。今天导师在 code review 时建议我使用如下函数，该函数也可以覆盖空字符串的检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function safeJsonParse&lt;T&gt;(str): &#123; ok: true, value: T &#125; | &#123; ok: false &#125; &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ok: true,</span><br><span class=\"line\">      value: JSON.parse(str)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; catch &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ok: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二、今日阅读：<a href=\"https://imweb.io/topic/5b72d4ef15554e6d3409f817\" target=\"_blank\" rel=\"noopener\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a>。<br>\n  这一篇很好地梳理了进程、线程、浏览器<strong>多进程</strong>、浏览器内核<strong>多线程</strong>、JS单线程、JS运行机制的相关知识，很连贯，建议时不时回顾。简单记录几个知识点：<br>\n1）进程是CPU资源分配的最小单位，线程是CPU调度的最小单位。（想当年考操作系统的时候还背得滚瓜烂熟）<br>\n2）<strong>浏览器是多进程的</strong>，包括的主要进程有：</p>\n<ul>\n<li>Browser进程（浏览器的主进程，只有一个）</li>\n<li>浏览器渲染进程（浏览器内核，Renderer进程，渲染进程，内部是多线程的）：默认每个Tab一个进程</li>\n<li>第三方插件进程</li>\n<li>GPU进程：3D绘制</li>\n</ul>\n<p>3）重点是浏览器内核，它是多线程的，主要常驻线程有：</p>\n<ul>\n<li>GUI渲染线程：渲染页面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制，repaint 和 reflow 等。</li>\n<li>JS引擎线程：处理任务队列中的任务，与 GUI 渲染线程是互斥的。</li>\n<li>事件触发线程：控制事件循环，把事件添加到任务队列的末尾。</li>\n<li>定时触发线程：<code>setTimeout</code> 和 <code>setInterval</code>，同样也是计时完毕后添加到队列末尾。</li>\n<li>异步 http 请求线程</li>\n</ul>\n<p>4）Browser进程和浏览器内核之间是需要通信的<br>\n5）时间循环机制 <code>Event Loop</code> ：JS分为同步任务和异步任务，同步任务都会在主线程上运行，形成一个执行栈；主线程之外，由事件触发线程管理一个<strong>任务队列/事件队列</strong>，异步任务的运行结果会被添加到任务队列中。一旦执行栈中所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到执行栈中开始执行。<br>\n6）进阶：macrotask / task 和 microtask/ job。ES6中的 <code>Promise</code> 就属于 microtask 微任务 ，而主代码块，事件队列中的时间如 <code>setTimeout</code> 和 <code>setInterval</code> 就属于 macrotask 宏任务。总结的运行机制就是：</p>\n<ul>\n<li>执行宏任务。（从执行栈中获取，如果没有就从事件队列中获取）</li>\n<li>执行过程中如果遇到微任务，就添加到微任务队列 Job Queues 中。（作者猜测这个队列由JS引擎线程维护，因为是在主线程下无缝执行的）</li>\n<li>宏任务执行完毕后，立即依次执行当前微任务队列中所有微任务。</li>\n<li>检查渲染，由 GUI 线程接管。</li>\n<li>渲染完毕后，由 JS 引擎线程接管，从时间队列中获取并执行下一个宏任务。</li>\n</ul>\n<p>7）在第六点中提到的是一个进阶的概念，对应一道题目，如果代码中依次有 <code>setTimeout</code> 和 <code>Promise</code> ，是会先打印出 <code>Promise</code> 的执行结果的。</p>\n<h4 id=\"2019711\">2019/7/11</h4>\n<p>   React 16.8 提出了 <code>hook</code> 的概念，函数式组件也可以拥有自己的状态。现在的工作项目已经摒弃了 <code>class</code> ，改用函数式组件，正在慢慢摸索中。今天在腾讯<a href=\"http://imweb.io/\" target=\"_blank\" rel=\"noopener\">IMWeb前端博客</a>中看到了两篇介绍 <code>React hook</code> 的文章，受益匪浅，简单记录一下。<br>\n一、<a href=\"https://imweb.io/topic/5cd845cadcd62f86299fcd76\" target=\"_blank\" rel=\"noopener\">react hook——你可能不是“我”所认识的useEffect</a><br>\n  这篇介绍了 <code>useEffect</code> 这个API，用它模拟了class组件的生命周期函数。<code>useEffect</code> 用于执行副作用，相当于 <code>ComponentDidMount</code> 和 <code>ComponentDidUpdate</code>。该API有两个参数和一个返回值。第一个参数是一个副作用函数，返回值是清除函数，相当于 <code>ComponentWillUnmount</code>，每一次 <code>render</code> 都会执行副作用和清除上一次副作用。<strong>第二个参数是一个数组，传入的是副作用函数所需要的依赖，当任一依赖更新时，会重新生成一个新的副作用并执行；如果传入一个空数组，没有依赖，只会执行一次，相当于 <code>ComponentDidMount</code>；如果不传，就是没有说明自己有没有依赖（注意是不知道有没有，不是没有！），每次 <code>render</code> 时就执行，相当于 <code>ComponentDidUpdate</code> 。</strong><br>\n   最后还讲了 <code>useEffect</code> 和 <code>useLayoutEffect</code> 的区别，简单来说前者是异步的，后者是同步的。还没好好深入这部分，TODO。<br>\n二、<a href=\"https://imweb.io/topic/5d1e3657f7b5692b080f2651\" target=\"_blank\" rel=\"noopener\">可能你的react函数组件从来没有优化过</a><br>\n  优化问题真是我一个痛点。这篇文章很清楚地解释了 <code>Hooks</code> 一些可用于组件优化的API。强推！<br>\n   特别地，文章介绍了当函数组件中传入的 <code>props</code> 值为函数时，由于每一次执行或重新执行，作用域里面一切都是重新开始，函数不是简单数据类型，不能画上等号，子组件都会重新渲染。针对这个问题文章提出了几种解决办法：<br>\n1） 作为 <code>props</code> 的函数在函数组件外定义，函数组件用 <code>React.memo()</code> 包裹。<br>\n   <code>React.memo()</code> 类似于 <code>PureComponent</code> 和 <code>ComponentDidUpdate</code> ，如果函数组件的 <code>props</code> 值都一样，就会跳过该组件的执行，减少不必要的渲染，实现性能优化。<br>\n2） 作为 <code>props</code> 的函数在函数组件内定义，使用<code>useCallBack</code> 或 <code>useMemo</code>包裹，函数组件用 <code>React.memo()</code> 包裹。<br>\n   <code>useCallback(() =&gt; {}, [deps])</code> 返回一个函数，当 <code>deps</code> 不变时（如传入空数组，表示没有依赖），都是同一个函数。<code>const a = useMemo(() =&gt; memorizeValue, [deps])</code>，当 <code>deps</code> 不变时，<code>a</code> 的值还是上次的 <code>memorizeValue</code>，省去了重新计算的过程。<br>\n   注意当 <code>memorizeValue</code> 是一个函数时，<code>useCallback(fn, inputs) &lt;=&gt; useMemo(() =&gt; fn, inputs)</code>。</p>\n<h4 id=\"2019710\">2019/7/10</h4>\n<p>  今天在项目中接触到了 <code>symbol</code>，鉴于之前一直没有注意这个数据类型，在今天补上。 <code>symbol</code> 是 ES6 新增的<strong>基本</strong>数据类型。它的使用如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const s1 = Symbol();</span><br><span class=\"line\">const s2 = Symbol();</span><br><span class=\"line\">console.log(s1 === s2); // false</span><br><span class=\"line\"></span><br><span class=\"line\">const s3 = new Symbol() // TypeError: Symbol is not a constructor</span><br><span class=\"line\">Symbol(&quot;foo&quot;) === Symbol(&quot;foo&quot;); // false</span><br></pre></td></tr></table></figure>\n<p><code>Symbol()</code> 返回的每个 <code>symbol</code> 值都是唯一的，可以接受一个字符串作为参数。它最常被用于对象属性的标识符，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;&#125;</span><br><span class=\"line\">const foo = Symbol(&quot;foo&quot;)</span><br><span class=\"line\">obj[foo] = &quot;foo&quot;</span><br><span class=\"line\">obj.bar = &quot;bar&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(obj); // &#123; bar: &quot;bar&quot; , Symbol(foo): &quot;foo&quot;&#125;</span><br><span class=\"line\">console.log(foo in obj); // true</span><br><span class=\"line\">console.log(obj[foo]); // foo</span><br><span class=\"line\">console.log(Object.keys(obj)); // [&quot;bar&quot;]</span><br><span class=\"line\">console.log(Object.getOwnPropertySymbols(obj)) // [Symbol(foo)]</span><br></pre></td></tr></table></figure>\n<p>也就是说， <code>Object.key()</code> 不会返回 <code>symbol</code> 值，同理，<code>Object.getOwnPropertyNames()</code>、<code>for..in</code>、<code>for...of</code> 也不会返回。<code>JSON.stringify()</code> 也会忽略：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.stringify(&#123;[Symbol(&apos;foo&apos;)]: &apos;foo&apos;&#125;);                 </span><br><span class=\"line\">// &apos;&#123;&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p><code>Symbol</code> 还有两个方法。 <code>Symbol.for(key)</code> 是根据指定的 <code>key</code> 搜索现有的 <code>symbol</code> 并返回, 如果找不到，会使用 <code>key</code> 在全局的 <code>symbol</code> 注册表中创建一个新的 <code>symbol</code> 。<code>Symbol.keyFor(sym)</code> 是在全局注册表中检索，返回共享的 <code>symbol key</code> 。</p>\n<h4 id=\"201979\">2019/7/9</h4>\n<p>一个不好的编程习惯：让函数在内部获取自己所需的依赖。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个可复用函数</span><br><span class=\"line\">function doSomething(key: string) &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;Button</span><br><span class=\"line\">            loading = &#123;key===&quot;str1&quot;? Compoment1 : Compoment2&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">            button</span><br><span class=\"line\">        &lt;/Button&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>lodaing</code> 所需的组件应该是作为函数参数传入的，不然如果我们新增了一个 <code>key</code>，很容易忽略了该地方的修改。这个观点类似于依赖反转。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>前言</h4>\n<p>📝 recap and cheat sheet ，记录每天学到的知识/想法。<br>\n🔊 每日一问：今天你比昨天更博学了吗？</p>\n<h4>2019/8/25</h4>\n<p>今日踩坑记录：<br>\n展开语法（spread syntax）只能取到 enumerable properties。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const imageData = new ImageData(200, 100);</span><br><span class=\"line\">// ImageData &#123; width: 200, height: 100, data: Uint8ClampedArray[80000] &#125;</span><br><span class=\"line\">const result = &#123;...imageData&#125;</span><br><span class=\"line\">// result 只会包含 data ，不能取到 width 和 height</span><br></pre></td></tr></table></figure>\n<h4>2019/8/24</h4>\n<p>避免组件重新挂载，可以使用事件的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BussinessProvider &#123;</span><br><span class=\"line\">  sp$ = new Subject&lt;&#123;url: string, slic: string&#125;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Canvas &#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">     this.props.sp$.pipe(takeUntil(this.unmount$)).subscribe(ev =&gt; &#123;</span><br><span class=\"line\">        if (ev.url === this.url) &#123;</span><br><span class=\"line\">           this.handleSuperPixelChange(ev.slic)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>2019/8/24</h4>\n<p>一、Promise</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">  // do something...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(onFulfilled[, onRejected]);</span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">  // fulfillment</span><br><span class=\"line\">&#125;, reason =&gt; &#123;</span><br><span class=\"line\">  // rejection</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.catch(onRejected);</span><br><span class=\"line\">promise.catch(function(reason) &#123;</span><br><span class=\"line\">   // rejection</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简单来说，<code>reject(value)</code> 可以被 <code>promise.then</code> 第二个函数参数捕获，也可以被 <code>promise.catch</code> 捕获。如果两者同时存在，会被 <code>promise.then</code> 第二个函数参数捕获，<code>promise.catch</code> 无输出。</p>\n<p>下载图片的典型例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function loadImage(url) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    let img = new Image();</span><br><span class=\"line\">    // img.onload = () =&gt; resolve(img)</span><br><span class=\"line\">    img.addEventListener(&apos;load&apos;, e =&gt; resolve(img));</span><br><span class=\"line\">    // img.onerror = () =&gt; reject(XXX)</span><br><span class=\"line\">    img.addEventListener(&apos;error&apos;, () =&gt; &#123;</span><br><span class=\"line\">      reject(new Error(`Failed to load image&apos;s URL: $&#123;url&#125;`));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    img.src = url;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">loadImage(&apos;http://thecatapi.com/api/images/get?format=src&amp;type=jpg&amp;size=small&apos;)</span><br><span class=\"line\">  .then(img =&gt; document.getElementById(&apos;image-holder&apos;).appendChild(img))</span><br><span class=\"line\">  .catch(error =&gt; console.error(error));</span><br></pre></td></tr></table></figure>\n<p>二、await<br>\n<code>[rv] = await expression</code>:</p>\n<blockquote>\n<p>TL;DR returns the fulfilled value of the promise,<br>\nThe await expression causes async function execution to pause until a Promise is settled, that is fulfilled or rejected, and to resume execution of the async function after fulfillment. When resumed, the value of the await expression is that of the fulfilled Promise.<br>\nIf the Promise is rejected, the await expression throws the rejected value.<br>\nIf the value of the expression following the await operator is not a Promise, it’s converted to a resolved Promise.</p>\n</blockquote>\n<h4>2019/8/23</h4>\n<p><code>String.prototype.localeCompare()</code></p>\n<blockquote>\n<p>return a number, indicating whether the reference string comes before, after or is the same as the compareString in sort order. Returns one of three values:<br>\n-1: if the reference string is sorted before the compareString<br>\n0: if the two strings are equal<br>\n1: if the reference string is sorted after the compareString</p>\n</blockquote>\n<p><code>Array.prototype.sort()</code></p>\n<blockquote>\n<p>sorts the elements of an array in place and returns the sorted array.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">items.sort((a,b) =&gt; a.localeCompare(b))</span><br></pre></td></tr></table></figure>\n<h4>2019/8/21</h4>\n<p>今日阅读：<br>\n<a href=\"https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci\" target=\"_blank\" rel=\"noopener\">What is the difference between “npm install” and “npm ci”?</a><br>\n<a href=\"https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8\" target=\"_blank\" rel=\"noopener\">Everything You Wanted To Know About package-lock.json But Were Too Afraid To Ask</a></p>\n<h4>2019/8/20</h4>\n<p>模仿 react hook <code>useState</code> 的第二个参数：<br>\n  因为在 jest 测试中某个函数的参数是 <code>useState</code> 的第二个参数，写了一个替代，不过不确定是否有错。😳</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// for example</span><br><span class=\"line\">const [str,setStr] = useState&lt;string[]&gt;([]);</span><br><span class=\"line\"></span><br><span class=\"line\">// fake setStr</span><br><span class=\"line\">let str:string[] = [];</span><br><span class=\"line\">const setStr = (val: string[] | ((prev:string[]) =&gt; string[])) =&gt; &#123;</span><br><span class=\"line\">  if (typeof val === &quot;object&quot;) &#123;</span><br><span class=\"line\">    str = val;</span><br><span class=\"line\">  &#125; else if (typeof val === &quot;function&quot;) &#123;</span><br><span class=\"line\">    str = val(str)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>2019/8/19</h4>\n<p>今日阅读：<a href=\"https://searchenginelaws.com/seo/what-is-rel-noopener-noreferrer-tag/\" target=\"_blank\" rel=\"noopener\">What is rel=noopener noreferrer link</a><br>\n  使用 <code>a</code> 标签，且属性 <code>target=&quot;_blank&quot;</code> 时，需要加上 <code>rel=&quot;noopener noreferrer&quot;</code> 。可以防止新窗口利用 <code>window.opener</code> 的特性窃取原窗口信息。具体而言，如果 window A 打开了 window B，那么 B.opener 会返回 A。如果加上 <code>rel=&quot;noopener&quot;</code> ，会返回 null 。</p>\n<h4>2019/8/12</h4>\n<p>一、download files using axios</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &quot;axios&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.get(url,&#123;</span><br><span class=\"line\">  responseType: &apos;blob&apos;, // important</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &apos;Authorization&apos;: AuthStr </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(resp =&gt; &#123;</span><br><span class=\"line\">  const &#123;data&#125; = resp;</span><br><span class=\"line\">  const file = new File([data],&quot;data.txt&quot;);</span><br><span class=\"line\">  const objectURL = URL.createObjectURL(file);</span><br><span class=\"line\">  const a = document.createElement(&quot;a&quot;);</span><br><span class=\"line\">  a.href = objectURL;</span><br><span class=\"line\">  a.download = &quot;data.txt&quot;;</span><br><span class=\"line\">  a.click();</span><br><span class=\"line\">  URL.revokeObjectURL(objectURL);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>  如果是单次点击下载多个文件，Chrome 只会弹出一个弹窗下载最后一个文件。这个时候可以加上 <code>setTimeout</code> ，触发多次下载，或是加上 <code>a.target = &quot;_blank&quot;</code> ，打开多个新窗口。<br>\n二、curl<br>\n查看命令：<br>\n<code>curl --help</code><br>\n-H 指定Header：<br>\n<code>curl -H &quot;Authorization: XXXXXXXX&quot; URL</code><br>\n<code>curl POST -d data -H &quot;Authorization: XXXXXXXX&quot; URL</code></p>\n<h4>2019/8/9</h4>\n<p>一、<a href=\"https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/\" target=\"_blank\" rel=\"noopener\">useRef vs useState: Should we re-render or not?</a><br>\n<img src=\"FE_20190809.png\" alt=\"FE_20190808\"><br>\n二、Hooks 监听键盘事件<br>\nkeyCode: <a href=\"https://keycode.info/\" target=\"_blank\" rel=\"noopener\">https://keycode.info/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function useKeyPress(targetKey) &#123;</span><br><span class=\"line\">  const [keyPressed, setKeyPressed] = useState(false);</span><br><span class=\"line\"></span><br><span class=\"line\">  function downHandler(&#123; key &#125;) &#123;</span><br><span class=\"line\">    if (key === targetKey) &#123;</span><br><span class=\"line\">      setKeyPressed(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const upHandler = (&#123; key &#125;) =&gt; &#123;</span><br><span class=\"line\">    if (key === targetKey) &#123;</span><br><span class=\"line\">      setKeyPressed(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    window.addEventListener(&apos;keydown&apos;, downHandler);</span><br><span class=\"line\">    window.addEventListener(&apos;keyup&apos;, upHandler);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      window.removeEventListener(&apos;keydown&apos;, downHandler);</span><br><span class=\"line\">      window.removeEventListener(&apos;keyup&apos;, upHandler);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  return keyPressed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>2019/8/8</h4>\n<p>  工程中经常会看到 CI/CD 的概念。CI 指的是持续集成，侧重于简化发布准备工作的实践，比如自动测试；CD 指的是持续交付，意味着不仅让测试自动化，让发布流程也自动化了。更多概念对比可以参考：<a href=\"https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment\" target=\"_blank\" rel=\"noopener\">Continuous integration VS continuous delivery VS continuous deployment</a><br>\n  下面这个图很清晰地描述了三者的不同：<br>\n<img src=\"FE_20190808.png\" alt=\"FE_20190808\"><br>\n  在 gitlab 上的实践可以参考：<a href=\"https://mp.weixin.qq.com/s/z2f1i2FgrVGofQR6nKTd1A\" target=\"_blank\" rel=\"noopener\">基于 GitLab CI/CD 的自动化构建、发布实践</a></p>\n<h4>2019/8/7</h4>\n<p>Typescript: <a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions\" target=\"_blank\" rel=\"noopener\">Discriminated Unions</a><br>\n  当我们某个参数可能有多个类型，而这些类型中又有公共的属性时，就可以使用这种形式约束。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Each interface has a kind property with a different string literal type. </span><br><span class=\"line\">// The kind property is called the discriminant or tag. </span><br><span class=\"line\">interface Square &#123;</span><br><span class=\"line\">    kind: &quot;square&quot;;</span><br><span class=\"line\">    size: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Rectangle &#123;</span><br><span class=\"line\">    kind: &quot;rectangle&quot;;</span><br><span class=\"line\">    width: number;</span><br><span class=\"line\">    height: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Circle &#123;</span><br><span class=\"line\">    kind: &quot;circle&quot;;</span><br><span class=\"line\">    radius: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// put the interfaces into a union</span><br><span class=\"line\">type Shape = Square | Rectangle | Circle;</span><br><span class=\"line\"></span><br><span class=\"line\">// use the discriminated union</span><br><span class=\"line\">function area(s: Shape) &#123;</span><br><span class=\"line\">    switch (s.kind) &#123;</span><br><span class=\"line\">        case &quot;square&quot;: return s.size * s.size;</span><br><span class=\"line\">        case &quot;rectangle&quot;: return s.height * s.width;</span><br><span class=\"line\">        case &quot;circle&quot;: return Math.PI * s.radius ** 2;</span><br><span class=\"line\">        default: return assertNever(s); // error here if there are missing cases</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Exhaustiveness checking </span><br><span class=\"line\">function assertNever(x: never): never &#123;</span><br><span class=\"line\">    throw new Error(&quot;Unexpected object: &quot; + x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>2019/8/6</h4>\n<p>Stack Overflow: <a href=\"https://stackoverflow.com/questions/54069253/usestate-set-method-not-reflecting-change-immediately\" target=\"_blank\" rel=\"noopener\">useState set method not reflecting change immediately.</a><br>\n  今天在实践中发现，<code>setState</code> 后马上打印，并不会取到更新后的值。查阅资料后发现这个函数是一个异步的函数，不会立即更新，但会触发重新渲染。如下：<br>\n<img src=\"FE_20190806.png\" alt=\"FE_20190806\"></p>\n<h4>2019/8/1</h4>\n<p>一、<a href=\"https://javascript.info/fetch-api\" target=\"_blank\" rel=\"noopener\">Fetch API</a><br>\n  用 fetch 来请求网络资源，可以配置不同的参数来解决缓存、跨域等问题，如下示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 不缓存请求结果 </span><br><span class=\"line\">// https://stackoverflow.com/questions/29246444/fetch-how-do-you-make-a-non-cached-request</span><br><span class=\"line\">const headers = new Headers();</span><br><span class=\"line\">headers.append(&quot;pragma&quot;, &quot;no-cache&quot;);</span><br><span class=\"line\">headers.append(&quot;cache-control&quot;, &quot;no-store&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 完全忽略 http-cache ，每次都从服务器请求数据</span><br><span class=\"line\">// https://developer.mozilla.org/en-US/docs/Web/API/Request/cache</span><br><span class=\"line\">const cache: RequestCache = &quot;no-store&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 请求模式，若有的请求会因为 cors 而失败，可以设置为 &quot;no-cors&quot;</span><br><span class=\"line\">// https://developer.mozilla.org/en-US/docs/Web/API/Request/mode</span><br><span class=\"line\">const mode: RequestMode = needCors ? &quot;cors&quot; : &quot;no-cors&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">await fetch(url. &#123;headers, cache, mode&#125;)</span><br><span class=\"line\">  .then(res =&gt; res.blob())</span><br><span class=\"line\">  .then(blob =&gt; &#123;</span><br><span class=\"line\">    // doSomething with blob</span><br><span class=\"line\">    const url = URL.createObjectURL(blob)</span><br><span class=\"line\">    let a = document.createElement(&apos;a&apos;)</span><br><span class=\"line\">    a.download = &apos;example.zip&apos;</span><br><span class=\"line\">    a.href = url</span><br><span class=\"line\">    document.body.appendChild(a)</span><br><span class=\"line\">    a.click()</span><br><span class=\"line\">    document.body.removeChild(a)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(err =&gt; &#123;</span><br><span class=\"line\">    console.log(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .finally(() =&gt; &#123;</span><br><span class=\"line\">    // doSomething</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>  关于 <code>res.blob()</code> ，可以参考知乎上<a href=\"https://zhuanlan.zhihu.com/p/32909043\" target=\"_blank\" rel=\"noopener\">谈一谈 Fetch API 中的 “res.blob()”</a>；也可以参考 <a href=\"https://github.github.io/fetch/\" target=\"_blank\" rel=\"noopener\">fetch documentation</a> ，这一篇比较详细，也提供了较多其他的例子。<br>\n关于浏览器缓存问题，Medium 上这篇 <a href=\"https://medium.com/@codebyamir/a-web-developers-guide-to-browser-caching-cc41f3b73e7c\" target=\"_blank\" rel=\"noopener\">A Web Developer’s Guide to Browser Caching</a> 写得不错。如果存在代理服务器，即使我们设置了 <code>mode: 'no-store'</code> ，代理服务器也会缓存。为了避免这个情况，我们可以在每次发送请求时构造新的 URL ，加上时间戳 <code>?t=Date.now()</code> 。🐮🍺<br>\n二、Jest<br>\n  我们在使用 jest 测试时，有时候需要引入一些外部文件/外部变量，如从 <code>config.json</code> 文件中引入某个变量。为了在测试文件中可以访问到该变量，我们可以在 <code>jest.config.js</code> 中配置全局变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  globals: &#123;</span><br><span class=\"line\">    API_BASE: &quot;&quot;,</span><br><span class=\"line\">    DATA_API: &quot;&quot;,</span><br><span class=\"line\">    TRACK_API: &quot;&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setupFiles: [&quot;./jestSetup.ts&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  由于 <code>globals</code> 只支持 JSON 格式的变量，如果我们需要定义全局函数，则可以使用 <code>setupFiles</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// jestSetup.ts</span><br><span class=\"line\">(global as any).fn= () =&gt; &#123;&#125;;</span><br><span class=\"line\">(global as any).variable = &quot;XXX&quot;;</span><br></pre></td></tr></table></figure>\n<h4>2019/7/31</h4>\n<p>1）<code>position: fixed</code> 和 flex 布局是不能同时起作用的。绝对布局脱离文档流，不会参与到 flex layout 中。如果想实现左侧菜单栏，右侧内容，两者不同时滚动（菜单栏 fixed），但菜单栏的大小可以改变（flex 父布局）。可以让父容器是 flex 布局，左侧菜单栏和右侧内容区域都是 flex element ， 菜单栏内部再有一个 <code>position: fixed</code> 的 div 。<br>\n2）如果想让 <code>position: fixed</code> 的元素相对父容器定位，可以给父容器增加 CSS 属性 <code>transform: translate(0,0)</code> 。参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">MDN - position</a></p>\n<blockquote>\n<p>fixed: It is positioned relative to the initial containing block established by the viewport, except when one of its ancestors has a transform, perspective, or filter property set to something other than none.</p>\n</blockquote>\n<h4>2019/7/30</h4>\n<p><code>useEffect</code> 中的异步请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 错误写法， return 必须是 cleanup function</span><br><span class=\"line\">useEffect(async () =&gt; &#123;</span><br><span class=\"line\">  const newVal = await asyncCall();</span><br><span class=\"line\">  setVal(newVal);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确写法</span><br><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  asyncCall().then(resp =&gt; setVal(resp.data));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>好文共享：<a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\" target=\"_blank\" rel=\"noopener\">How to fetch data with React Hooks?</a>，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  async function fetchMyAPI() &#123;</span><br><span class=\"line\">    let url = &apos;http://something/&apos; + productId;</span><br><span class=\"line\">    let config = &#123;&#125;;</span><br><span class=\"line\">    const response = await myFetch(url);</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  fetchMyAPI();</span><br><span class=\"line\">&#125;, [productId]);</span><br></pre></td></tr></table></figure>\n<p>如果要保证请求按顺序发出，可以采用如下写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  let didCancel = false;</span><br><span class=\"line\"></span><br><span class=\"line\">  async function fetchMyAPI() &#123;</span><br><span class=\"line\">    let url = &apos;http://something/&apos; + productId;</span><br><span class=\"line\">    let config = &#123;&#125;;</span><br><span class=\"line\">    const response = await myFetch(url);</span><br><span class=\"line\">    if (!didCancel) &#123; // Ignore if we started fetching something else</span><br><span class=\"line\">      console.log(response);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  fetchMyAPI();</span><br><span class=\"line\">  return () =&gt; &#123; didCancel = true; &#125;; // Remember if we start fetching something else</span><br><span class=\"line\">&#125;, [productId]);</span><br></pre></td></tr></table></figure>\n<h4>2019/7/29</h4>\n<p>一、<a href=\"https://stackoverflow.com/questions/30795525/performance-now-vs-date-now\" target=\"_blank\" rel=\"noopener\">performance.now() vs Date.now()</a><br>\n  在程序中打印执行时间时，使用 <code>performance.now(）</code> 更准确。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const start = performance.now();</span><br><span class=\"line\">doSomething();</span><br><span class=\"line\">const end = performance.now();</span><br><span class=\"line\">console.log(&quot;Call to doSomething took &quot; + (start - end) + &quot; milliseconds.&quot;);</span><br></pre></td></tr></table></figure>\n<p>二、<a href=\"https://stackoverflow.com/questions/47738344/does-javascript-slice-method-return-a-shallow-copy\" target=\"_blank\" rel=\"noopener\">Does javascript slice method return a shallow copy?</a><br>\n  mdn 上对 <code>slice()</code> 方法的介绍：</p>\n<blockquote>\n<p>The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included) where begin and end represent the index of items in that array. The original array will not be modified.</p>\n</blockquote>\n<p>  注意这里的浅复制指的是对数组中值的浅复制，而不是对整个数组的浅复制。如果是一个字符串数组，则修改新数组时，原数组不会改变；如果是对象数组，修改新数组对象值时，原数组也会发生变化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const animals = [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;];</span><br><span class=\"line\">const newAnimals = animals.slice(2);</span><br><span class=\"line\"></span><br><span class=\"line\">newAnimals[0].name = &apos;aaa&apos;;</span><br><span class=\"line\">console.log(newAnimals); // [&#123;name: &apos;aaa&apos;&#125;]</span><br><span class=\"line\">console.log(animals);    // [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;aaa&apos;&#125;]</span><br></pre></td></tr></table></figure>\n<p>  注意如果是重新赋值，则等于重新分配空间，不会改变原数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const animals = [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;];</span><br><span class=\"line\">const newAnimals = animals.slice(2);</span><br><span class=\"line\"></span><br><span class=\"line\">newAnimals[0] = &#123;name: &apos;aaa&apos;&#125;;</span><br><span class=\"line\">console.log(newAnimals); // [&#123;name: &apos;aaa&apos;&#125;]</span><br><span class=\"line\">console.log(animals);    // [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;]</span><br></pre></td></tr></table></figure>\n<h4>2019/7/26</h4>\n<p>  应用场景：我们需要请求并更新菜单栏中任务的状态，如果一个请求完成立马更新会导致 React 频繁刷新，需要缓冲批处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; runInAction &#125; from &quot;mobx&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">let handlers: Array&lt;() =&gt; void&gt; = [];</span><br><span class=\"line\">const runHandlers = () =&gt; &#123;</span><br><span class=\"line\">  runInAction(() =&gt; &#123;</span><br><span class=\"line\">    handlers.forEach(f =&gt; f());</span><br><span class=\"line\">    handlers = [];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (const task of tasks) &#123;</span><br><span class=\"line\">  const &#123;data&#125; = await requestFn();</span><br><span class=\"line\">  </span><br><span class=\"line\">  handlers.push(() =&gt; &#123;</span><br><span class=\"line\">    // deal with data, update state</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if(handlers.length &gt; 30) &#123;</span><br><span class=\"line\">    runHandlers();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">runHandlers();</span><br></pre></td></tr></table></figure>\n<p>  上述代码主要是利用了自定义的 <code>handlers</code> 来暂存状态更新函数，之后使用 mobx 提供的 <code>runInAction</code> 执行函数并更新状态，更新状态都需要使用 <code>action</code> 函数， <code>runInAction</code> 接受一个代码块并在一个(匿名)操作中执行，有利于动态创建和执行操作，<code>runInAction(f) = action(f)()</code>。此外，必要时还可加上 <code>lodash.memoize(func,[resolver])</code>，记录主函数请求结果。</p>\n<blockquote>\n<p>For one-time-actions runInAction(name?, fn) can be used, which is sugar for action(name, fn)()</p>\n</blockquote>\n<h4>2019/7/18</h4>\n<p>一、编程模式：<br>\n   首先先记住这几种编程模式的中文：Imperative Programming 是命令式编程，Declarative Programming 是声明式编程，Reactive Programming 是响应式编程。（流下了英文不好的泪水）<br>\n1）先看命令式编程和声明式编程的区别，直接上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 命令式编程 imperative programming</span><br><span class=\"line\">const array = [0,1,2,3,4,5];</span><br><span class=\"line\">const output = [];</span><br><span class=\"line\">for (let i = 0; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">  const tmp = array[i] * 2;</span><br><span class=\"line\">  output.push(tmp)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(output) // =&gt; [0,2,4,6,8,10]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明式编程 declarative programming</span><br><span class=\"line\">const array = [0,1,2,3,4,5];</span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">console.log(output) // =&gt; [0,2,3,6,8,10]</span><br></pre></td></tr></table></figure>\n<p>  很明显可以看到，命令式编程的关注点在于 how ，我们需要一步步告诉机器接下来要做什么，告诉他怎么去遍历一个数组，怎么去运算得到最后的结果，怎么去输出；声明式编程的关注点在于 what ，我们只关注最后的结果，由机器自己去摸索过程，如直接调用 <code>map</code> 函数，只告诉程序我们需要一个2倍输出。<br>\n2）接着看声明式编程和响应式编程的对比<br>\n  可以阅读：<a href=\"https://codepen.io/HunorMarton/post/imperative-vs-reactive\" target=\"_blank\" rel=\"noopener\">Imperative vs Reactive</a>，解释很清晰，比喻也很形象，但我觉得文章里的 Imperative 应该改成 Declarative 比较准确。继续沿用上面的例子，修改一下声明式编程的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明式编程 declarative programming</span><br><span class=\"line\">const array = [1,2];</span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">output.forEach(item =&gt; console.log(item)) // =&gt; 2 4</span><br><span class=\"line\">array.push(3);  // =&gt; no output </span><br><span class=\"line\">array.push(4);  // =&gt; no output</span><br></pre></td></tr></table></figure>\n<p>响应式编程的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Subject &#125; from `rxjs`;</span><br><span class=\"line\">let array = new Subject();</span><br><span class=\"line\">array.next(1);</span><br><span class=\"line\">array.next(2);</span><br><span class=\"line\"></span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">output.forEach(item =&gt; console.log(item)); // =&gt; 2 4</span><br><span class=\"line\"></span><br><span class=\"line\">array.next(3); // =&gt; 6</span><br><span class=\"line\">array.next(4); // =&gt; 8</span><br></pre></td></tr></table></figure>\n<p>  首先要注意的是，这两种方式中的 <code>map</code> ， <code>forEach</code> 等函数并不是一样的，内部实现机制是不同的。我们可以发现区别：在声明式编程中，如果在最后向原数组添加值，并不会打印出来，因为这是在 <code>console.log</code> 语句执行后发生的。但在响应式编程里，任何变化都可以被反应出来，它引入了一个<strong>异步数据流</strong>（asynchronous data streams）的概念，可以随时创建、更改或组合这些数据流，所以打印事件是一个 continuous observation case。<br>\n二、类库<br>\n<a href=\"https://github.com/bvaughn/react-virtualized\" target=\"_blank\" rel=\"noopener\">react-virtualized</a> 的轻量级版 <a href=\"https://github.com/bvaughn/react-window\" target=\"_blank\" rel=\"noopener\">react-window</a>，用于高效渲染长列表。</p>\n<h4>2019/7/17</h4>\n<p>  如果我们在项目中需要请求很多图片，想要实现请求出错时继续发送请求，成功时返回数据，可以使用 <code>Promise</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fetchURL(url: string):Promise&lt;Blob&gt; &#123;</span><br><span class=\"line\">  return Axios.get(url, &#123;responeType: &quot;blob&quot;&#125;)</span><br><span class=\"line\">              .then( resp =&gt; Promise.resolve(resp.data) )</span><br><span class=\"line\">              .catch( () =&gt; fetchURL(url) )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后可以使用 <code>rxjs</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mergeMap, bufferTime, takeUntil &#125; from &quot;rxjs/operators&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">[url1,...,url10]</span><br><span class=\"line\">  .pipe(</span><br><span class=\"line\">    mergeMap( url =&gt; fetchURL(url).then( val =&gt; val )),</span><br><span class=\"line\">    bufferTime(10000)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .subscribe(&#123;</span><br><span class=\"line\">    next: resps =&gt; &#123;</span><br><span class=\"line\">      // do sth with resps:Blob[]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>  每次遇到 <code>rxjs</code> 都很头大，现在也没有发现一个比较完善清晰的教程，但它又真的很强大，后续要开专题好好学习记录这个东西。</p>\n<h4>2019/7/16</h4>\n<p>一、今日阅读：<a href=\"https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\" target=\"_blank\" rel=\"noopener\">How to read an often-changing value from useCallback?</a><br>\n直接上官网代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  const textRef = useRef();</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    textRef.current = text; // Write it to the ref</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleSubmit = useCallback(() =&gt; &#123;</span><br><span class=\"line\">    const currentText = textRef.current; // Read it from the ref</span><br><span class=\"line\">    alert(currentText);</span><br><span class=\"line\">  &#125;, [textRef]); // Don&apos;t recreate handleSubmit like [text] would do</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   也就是说，当 <code>text</code> 的值经常发生变化时，即使 <code>handleSubmit</code> 用 <code>useCallback</code> 包裹了，还是会重新声明。解决办法是传入一个 <code>ref</code> 对象代替原始值。也可以写一个 custom hook ：<br>\n1）官网的版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function useEventCallback(fn, dependencies) &#123;</span><br><span class=\"line\">  const ref = useRef(() =&gt; &#123;</span><br><span class=\"line\">    throw new Error(&apos;Cannot call an event handler while rendering.&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ref.current = fn;</span><br><span class=\"line\">  &#125;, [fn, ...dependencies]);</span><br><span class=\"line\"></span><br><span class=\"line\">  return useCallback(() =&gt; &#123;</span><br><span class=\"line\">    const fn = ref.current;</span><br><span class=\"line\">    return fn();</span><br><span class=\"line\">  &#125;, [ref]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  // Will be memoized even if `text` changes:</span><br><span class=\"line\">  const handleSubmit = useEventCallback(() =&gt; &#123;</span><br><span class=\"line\">    alert(text);</span><br><span class=\"line\">  &#125;, [text]);</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2）导师的版本：（他来了，他带着代码又来了）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param callback</span><br><span class=\"line\"> * @param oRefs</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function useCallbackWithRefs&lt;</span><br><span class=\"line\">  Refs,</span><br><span class=\"line\">  Callback extends (...args: any[]) =&gt; void</span><br><span class=\"line\">&gt;(callback: (refs: Refs) =&gt; Callback, oRefs: Refs) &#123;</span><br><span class=\"line\">  const refs = useRef(oRefs);</span><br><span class=\"line\">  useEffect(</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">      refs.current = oRefs;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [oRefs]</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  return useCallback(</span><br><span class=\"line\">    (...args: any[]) =&gt; callback(refs.current)(...args),</span><br><span class=\"line\">    []</span><br><span class=\"line\">  ) as Callback;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 原先的 callback 也可以有参数</span><br><span class=\"line\">  const handleSubmit = useCallbackWithRefs(</span><br><span class=\"line\">    refs =&gt; (params: any) =&gt; &#123;</span><br><span class=\"line\">      // 要注意在函数内必须使用 `refs.xxx`，不能直接使用函数外部的任何变量 `xxx`</span><br><span class=\"line\">      console.log(refs.text);</span><br><span class=\"line\">  &#125;, &#123;text&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  总的来说，官网的实现是将 <code>callback</code> 作为 <code>ref</code> 对象，并作为 <code>useCallback</code> 的依赖，不会频繁改变；如果在函数 <code>handleSubmit</code> 中要访问外部变量 <code>text</code> ，直接使用 <code>test</code> 即可。第二种实现方式是把经常变化的值作为 <code>ref</code> 对象，返回值 <code>useCallback</code> 第一个参数是 <code>refs =&gt; callback</code> ，依赖是空数组；这时如果要在函数 <code>handleSubmit</code> 中要访问外部变量 <code>text</code> ，必须使用 <code>refs.test</code> ，否则访问的只是 <code>test</code> 的初始值。<br>\n  React 博大精深，接下来要好好研读一下这个 <a href=\"https://reactjs.org/docs/hooks-faq.html\" target=\"_blank\" rel=\"noopener\">FAQ</a>。<br>\n二、今日网址<br>\n  一个 <a href=\"https://www.emojicopy.com/\" target=\"_blank\" rel=\"noopener\">emoji copy</a> 网站，我们 👧 就是喜欢这些花里胡哨的东西。</p>\n<h4>2019/7/15</h4>\n<p>  今天在项目中使用 React Hooks 又踩坑了，看来自己对这部分还是没有理解透彻。在使用 <code>useCallback</code> 和 <code>useEffect</code> 时，要注意第二个参数，也就是传入的 <code>[deps]</code>。如果使用 <code>useCallback(fn,[deps])</code> ， <code>[deps]</code> 应该包含函数 <code>fn</code> 所涉及的所有变量；如果使用 <code>useEffect(fn,[deps])</code> ， 当 <code>deps</code> 的值变化时，就会执行 <code>fn</code>，因此<code>[deps]</code> 不一定要包含函数 <code>fn</code> 所涉及的所有变量，而是应该传入会引起该函数执行的那些参数。<br>\n  今日踩坑记录：为了优化子组件，作为 <code>props</code> 的函数都使用 <code>useCallback</code> 包裹了，并传入了空数组作为第二个参数，表示没有依赖。但是函数中的运算需要用到组件中一个变量，如果没有将该变量作为 <code>deps</code> ，这个变量就会一直保持初始值，值并不会改变，运行结果就会与预期不符。（真的太蠢了，缓缓躺倒）</p>\n<h4>2019/7/14</h4>\n<p>周末当然是约会啦。😍</p>\n<h4>2019/7/13</h4>\n<p>一、今日阅读：<a href=\"https://stackoverflow.com/questions/53446020/how-to-compare-oldvalues-and-newvalues-on-react-hooks-useeffect\" target=\"_blank\" rel=\"noopener\">How to compare oldValues and newValues on React Hooks useEffect?</a><br>\n   React class 组件提供了 <code>ComponentDidUpdate</code> 之类的方法来获取到当前 <code>props</code> 和前一个 <code>props</code> ，并进行比较，决定是否进行更新。函数式组件只有 <code>useEffect</code> 函数来模仿生命周期函数，当我们需要获取组件先前的 <code>props</code> 时，可以使用下面的 custom hook ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function usePrevious(value) &#123;</span><br><span class=\"line\">  const ref = useRef();</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ref.current = value;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return ref.current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  之后在 <code>useEffect</code> 中使用上面的函数来模拟 <code>ComponentDidUpdate</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Component = (props) =&gt; &#123;</span><br><span class=\"line\">    const &#123;receiveAmount, sendAmount &#125; = props</span><br><span class=\"line\">    const prevAmount = usePrevious(&#123;receiveAmount, sendAmount&#125;);</span><br><span class=\"line\">    useEffect(() =&gt; &#123;</span><br><span class=\"line\">        if(prevAmount.receiveAmount !== receiveAmount) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         // process here</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(prevAmount.sendAmount !== sendAmount) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         // process here</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, [receiveAmount, sendAmount])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  有时候在 debug 时，我们想知道组件为什么会重新渲染，是那些 <code>props</code> 更新了，也可以使用上面的方法来获取 <code>prevProps</code>，并在函数组件最开始时写一个 <code>useEffect</code> 将参数都打印出来，使用 <code>===</code> 比较。</p>\n<h4>2019/7/12</h4>\n<p>一、今日技能<br>\n  项目中经常会涉及到 JSON 字符串的解析，解析出错就扑街了，一般是用 <code>try {...} catch {...}</code> 包裹。今天导师在 code review 时建议我使用如下函数，该函数也可以覆盖空字符串的检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function safeJsonParse&lt;T&gt;(str): &#123; ok: true, value: T &#125; | &#123; ok: false &#125; &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ok: true,</span><br><span class=\"line\">      value: JSON.parse(str)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; catch &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ok: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二、今日阅读：<a href=\"https://imweb.io/topic/5b72d4ef15554e6d3409f817\" target=\"_blank\" rel=\"noopener\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a>。<br>\n  这一篇很好地梳理了进程、线程、浏览器<strong>多进程</strong>、浏览器内核<strong>多线程</strong>、JS单线程、JS运行机制的相关知识，很连贯，建议时不时回顾。简单记录几个知识点：<br>\n1）进程是CPU资源分配的最小单位，线程是CPU调度的最小单位。（想当年考操作系统的时候还背得滚瓜烂熟）<br>\n2）<strong>浏览器是多进程的</strong>，包括的主要进程有：</p>\n<ul>\n<li>Browser进程（浏览器的主进程，只有一个）</li>\n<li>浏览器渲染进程（浏览器内核，Renderer进程，渲染进程，内部是多线程的）：默认每个Tab一个进程</li>\n<li>第三方插件进程</li>\n<li>GPU进程：3D绘制</li>\n</ul>\n<p>3）重点是浏览器内核，它是多线程的，主要常驻线程有：</p>\n<ul>\n<li>GUI渲染线程：渲染页面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制，repaint 和 reflow 等。</li>\n<li>JS引擎线程：处理任务队列中的任务，与 GUI 渲染线程是互斥的。</li>\n<li>事件触发线程：控制事件循环，把事件添加到任务队列的末尾。</li>\n<li>定时触发线程：<code>setTimeout</code> 和 <code>setInterval</code>，同样也是计时完毕后添加到队列末尾。</li>\n<li>异步 http 请求线程</li>\n</ul>\n<p>4）Browser进程和浏览器内核之间是需要通信的<br>\n5）时间循环机制 <code>Event Loop</code> ：JS分为同步任务和异步任务，同步任务都会在主线程上运行，形成一个执行栈；主线程之外，由事件触发线程管理一个<strong>任务队列/事件队列</strong>，异步任务的运行结果会被添加到任务队列中。一旦执行栈中所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到执行栈中开始执行。<br>\n6）进阶：macrotask / task 和 microtask/ job。ES6中的 <code>Promise</code> 就属于 microtask 微任务 ，而主代码块，事件队列中的时间如 <code>setTimeout</code> 和 <code>setInterval</code> 就属于 macrotask 宏任务。总结的运行机制就是：</p>\n<ul>\n<li>执行宏任务。（从执行栈中获取，如果没有就从事件队列中获取）</li>\n<li>执行过程中如果遇到微任务，就添加到微任务队列 Job Queues 中。（作者猜测这个队列由JS引擎线程维护，因为是在主线程下无缝执行的）</li>\n<li>宏任务执行完毕后，立即依次执行当前微任务队列中所有微任务。</li>\n<li>检查渲染，由 GUI 线程接管。</li>\n<li>渲染完毕后，由 JS 引擎线程接管，从时间队列中获取并执行下一个宏任务。</li>\n</ul>\n<p>7）在第六点中提到的是一个进阶的概念，对应一道题目，如果代码中依次有 <code>setTimeout</code> 和 <code>Promise</code> ，是会先打印出 <code>Promise</code> 的执行结果的。</p>\n<h4>2019/7/11</h4>\n<p>   React 16.8 提出了 <code>hook</code> 的概念，函数式组件也可以拥有自己的状态。现在的工作项目已经摒弃了 <code>class</code> ，改用函数式组件，正在慢慢摸索中。今天在腾讯<a href=\"http://imweb.io/\" target=\"_blank\" rel=\"noopener\">IMWeb前端博客</a>中看到了两篇介绍 <code>React hook</code> 的文章，受益匪浅，简单记录一下。<br>\n一、<a href=\"https://imweb.io/topic/5cd845cadcd62f86299fcd76\" target=\"_blank\" rel=\"noopener\">react hook——你可能不是“我”所认识的useEffect</a><br>\n  这篇介绍了 <code>useEffect</code> 这个API，用它模拟了class组件的生命周期函数。<code>useEffect</code> 用于执行副作用，相当于 <code>ComponentDidMount</code> 和 <code>ComponentDidUpdate</code>。该API有两个参数和一个返回值。第一个参数是一个副作用函数，返回值是清除函数，相当于 <code>ComponentWillUnmount</code>，每一次 <code>render</code> 都会执行副作用和清除上一次副作用。<strong>第二个参数是一个数组，传入的是副作用函数所需要的依赖，当任一依赖更新时，会重新生成一个新的副作用并执行；如果传入一个空数组，没有依赖，只会执行一次，相当于 <code>ComponentDidMount</code>；如果不传，就是没有说明自己有没有依赖（注意是不知道有没有，不是没有！），每次 <code>render</code> 时就执行，相当于 <code>ComponentDidUpdate</code> 。</strong><br>\n   最后还讲了 <code>useEffect</code> 和 <code>useLayoutEffect</code> 的区别，简单来说前者是异步的，后者是同步的。还没好好深入这部分，TODO。<br>\n二、<a href=\"https://imweb.io/topic/5d1e3657f7b5692b080f2651\" target=\"_blank\" rel=\"noopener\">可能你的react函数组件从来没有优化过</a><br>\n  优化问题真是我一个痛点。这篇文章很清楚地解释了 <code>Hooks</code> 一些可用于组件优化的API。强推！<br>\n   特别地，文章介绍了当函数组件中传入的 <code>props</code> 值为函数时，由于每一次执行或重新执行，作用域里面一切都是重新开始，函数不是简单数据类型，不能画上等号，子组件都会重新渲染。针对这个问题文章提出了几种解决办法：<br>\n1） 作为 <code>props</code> 的函数在函数组件外定义，函数组件用 <code>React.memo()</code> 包裹。<br>\n   <code>React.memo()</code> 类似于 <code>PureComponent</code> 和 <code>ComponentDidUpdate</code> ，如果函数组件的 <code>props</code> 值都一样，就会跳过该组件的执行，减少不必要的渲染，实现性能优化。<br>\n2） 作为 <code>props</code> 的函数在函数组件内定义，使用<code>useCallBack</code> 或 <code>useMemo</code>包裹，函数组件用 <code>React.memo()</code> 包裹。<br>\n   <code>useCallback(() =&gt; {}, [deps])</code> 返回一个函数，当 <code>deps</code> 不变时（如传入空数组，表示没有依赖），都是同一个函数。<code>const a = useMemo(() =&gt; memorizeValue, [deps])</code>，当 <code>deps</code> 不变时，<code>a</code> 的值还是上次的 <code>memorizeValue</code>，省去了重新计算的过程。<br>\n   注意当 <code>memorizeValue</code> 是一个函数时，<code>useCallback(fn, inputs) &lt;=&gt; useMemo(() =&gt; fn, inputs)</code>。</p>\n<h4>2019/7/10</h4>\n<p>  今天在项目中接触到了 <code>symbol</code>，鉴于之前一直没有注意这个数据类型，在今天补上。 <code>symbol</code> 是 ES6 新增的<strong>基本</strong>数据类型。它的使用如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const s1 = Symbol();</span><br><span class=\"line\">const s2 = Symbol();</span><br><span class=\"line\">console.log(s1 === s2); // false</span><br><span class=\"line\"></span><br><span class=\"line\">const s3 = new Symbol() // TypeError: Symbol is not a constructor</span><br><span class=\"line\">Symbol(&quot;foo&quot;) === Symbol(&quot;foo&quot;); // false</span><br></pre></td></tr></table></figure>\n<p><code>Symbol()</code> 返回的每个 <code>symbol</code> 值都是唯一的，可以接受一个字符串作为参数。它最常被用于对象属性的标识符，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;&#125;</span><br><span class=\"line\">const foo = Symbol(&quot;foo&quot;)</span><br><span class=\"line\">obj[foo] = &quot;foo&quot;</span><br><span class=\"line\">obj.bar = &quot;bar&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(obj); // &#123; bar: &quot;bar&quot; , Symbol(foo): &quot;foo&quot;&#125;</span><br><span class=\"line\">console.log(foo in obj); // true</span><br><span class=\"line\">console.log(obj[foo]); // foo</span><br><span class=\"line\">console.log(Object.keys(obj)); // [&quot;bar&quot;]</span><br><span class=\"line\">console.log(Object.getOwnPropertySymbols(obj)) // [Symbol(foo)]</span><br></pre></td></tr></table></figure>\n<p>也就是说， <code>Object.key()</code> 不会返回 <code>symbol</code> 值，同理，<code>Object.getOwnPropertyNames()</code>、<code>for..in</code>、<code>for...of</code> 也不会返回。<code>JSON.stringify()</code> 也会忽略：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.stringify(&#123;[Symbol(&apos;foo&apos;)]: &apos;foo&apos;&#125;);                 </span><br><span class=\"line\">// &apos;&#123;&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p><code>Symbol</code> 还有两个方法。 <code>Symbol.for(key)</code> 是根据指定的 <code>key</code> 搜索现有的 <code>symbol</code> 并返回, 如果找不到，会使用 <code>key</code> 在全局的 <code>symbol</code> 注册表中创建一个新的 <code>symbol</code> 。<code>Symbol.keyFor(sym)</code> 是在全局注册表中检索，返回共享的 <code>symbol key</code> 。</p>\n<h4>2019/7/9</h4>\n<p>一个不好的编程习惯：让函数在内部获取自己所需的依赖。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个可复用函数</span><br><span class=\"line\">function doSomething(key: string) &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;Button</span><br><span class=\"line\">            loading = &#123;key===&quot;str1&quot;? Compoment1 : Compoment2&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">            button</span><br><span class=\"line\">        &lt;/Button&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>lodaing</code> 所需的组件应该是作为函数参数传入的，不然如果我们新增了一个 <code>key</code>，很容易忽略了该地方的修改。这个观点类似于依赖反转。</p>\n"},{"title":"FrontEnd Daily Learning [2019.12]","catalog":true,"date":"2019-12-09T15:33:36.000Z","subtitle":null,"header-img":null,"_content":"\n#### About\n\n📅 2019 年 12 月的零散学习记录。\n\n#### 2019/12/26\n今日阅读：[When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)\n起因是刷 reddit 时看到了这篇 [帖子](https://www.reddit.com/r/reactjs/comments/efjgfc/should_i_use_usecallback_in_every_function/)，提问者的问题是 \"Should I use useCallback in every function declared inside a functional component?\"，评论中有人贴出了这个链接，更正了我对性能优化的一些错误认知。\n作者在文章中举了一个例子，在某个函数组件中有这样一个函数：\n```\nconst dispense = candy => {\n  setCandies(allCandies => allCandies.filter(c => c !== candy))\n}\n```\n问题：如果用 `useCallback` 包裹，那么性能会不会更好呢？\n```\nconst dispense = React.useCallback(candy => {\n  setCandies(allCandies => allCandies.filter(c => c !== candy))\n}, [])\n```\n我刚开始的答案是使用 `useCallback` 会更好，毫无疑问是错的。上面的函数也可被写成：\n```\nconst dispense = candy => {\n    setCandies(allCandies => allCandies.filter(c => c !== candy))\n  }\n+ const dispenseCallback = React.useCallback(dispense, [])\n```\ndiff 之后会发现只是多了一行，该有的声明还是有，还需要做更多的工作。现在不仅仅要定义函数，还要定义依赖数组，调用 `useCallback` 进行赋值分配等工作。之前我一直误以为，使用 `useCallback` 后，函数只会在第一次渲染时定义并赋值，第二次渲染不会做额外的操作。其实不是的，这里的相等可以理解为是 “指向的位置” 相等，类似 `ref` 和 `ref.current`，重新渲染时就相当于执行 `ref.current = newVal` 。\n那什么时候需要用到 `useCallback` 呢？官方文档是这样写的：\n> This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).\n\n最简单粗暴的经验，是当你需要将这个函数传递给子组件时，可以使用 `useCallback` 来避免子组件不必要的渲染（子组件使用 `useMemo`）；更准确的说法，是当你需要依赖引用相等性时，就应使用 `useCallback` 。  \n\n#### 2019/12/17\n保留四位有效数字：\n```\nx.toPrecise(4) // return string\n```\n\n#### 2019/12/9\n\n使用原生方法实现文件点击/拖拽上传，并限制只能上传单个 JSON 文件：\n主要思想是监听 `onClick` 和 `onDrop` 事件，注意在 React 中，如果我们需要注册捕获阶段的事件处理函数，则应为事件名添加 `Capture`。例如，使用处理捕获阶段的点击事件 `onClickCapture`，而不是 `onClick`。详情可参考官方文档 [Supported Events](https://reactjs.org/docs/events.html#supported-events) 。\n\n```\n// upload.tsx\n  ...\n  const handleUploadClick = () => {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = \".json,application/json\";\n    input.onchange = ev => {\n      // double-checked\n      if (\n        input.files &&\n        input.files.length === 1 &&\n        input.files[0].type === \"application/json\"\n      ) {\n        // deal with input.files\n      }\n    };\n    input.click();\n  };\n\n  const handleUploadDrop = (ev:       React.DragEvent<HTMLDivElement>) => {\n    if (ev.dataTransfer.files.length > 1) {\n      console.error(\"只允许上传单个文件\");\n    } else if (ev.dataTransfer.files[0].type !== \"application/json\") {\n      console.error(\"只允许上传json文件\");\n    } else {\n      // deal with ev.dataTransfer.files[0]\n    }\n  };\n\n  ...\n\n  render() {\n    return (\n      <div\n        onClickCapture={ev => {\n          ev.preventDefault();\n          ev.stopPropagation();\n          handleUploadClick();\n        }}\n        onDropCapture={ev => {\n          ev.preventDefault();\n          ev.stopPropagation();\n          handleUploadDrop(ev);\n        }}\n      >\n        Click or drag file to this area to upload\n      </div>\n    )\n  }\n\n```\n","source":"_posts/FrontEnd-Daily-Learning-2019-12.md","raw":"---\ntitle: \"FrontEnd Daily Learning [2019.12]\"\ncatalog: true\ndate: 2019-12-09 23:33:36\nsubtitle:\nheader-img:\ntags: FE\n---\n\n#### About\n\n📅 2019 年 12 月的零散学习记录。\n\n#### 2019/12/26\n今日阅读：[When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)\n起因是刷 reddit 时看到了这篇 [帖子](https://www.reddit.com/r/reactjs/comments/efjgfc/should_i_use_usecallback_in_every_function/)，提问者的问题是 \"Should I use useCallback in every function declared inside a functional component?\"，评论中有人贴出了这个链接，更正了我对性能优化的一些错误认知。\n作者在文章中举了一个例子，在某个函数组件中有这样一个函数：\n```\nconst dispense = candy => {\n  setCandies(allCandies => allCandies.filter(c => c !== candy))\n}\n```\n问题：如果用 `useCallback` 包裹，那么性能会不会更好呢？\n```\nconst dispense = React.useCallback(candy => {\n  setCandies(allCandies => allCandies.filter(c => c !== candy))\n}, [])\n```\n我刚开始的答案是使用 `useCallback` 会更好，毫无疑问是错的。上面的函数也可被写成：\n```\nconst dispense = candy => {\n    setCandies(allCandies => allCandies.filter(c => c !== candy))\n  }\n+ const dispenseCallback = React.useCallback(dispense, [])\n```\ndiff 之后会发现只是多了一行，该有的声明还是有，还需要做更多的工作。现在不仅仅要定义函数，还要定义依赖数组，调用 `useCallback` 进行赋值分配等工作。之前我一直误以为，使用 `useCallback` 后，函数只会在第一次渲染时定义并赋值，第二次渲染不会做额外的操作。其实不是的，这里的相等可以理解为是 “指向的位置” 相等，类似 `ref` 和 `ref.current`，重新渲染时就相当于执行 `ref.current = newVal` 。\n那什么时候需要用到 `useCallback` 呢？官方文档是这样写的：\n> This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).\n\n最简单粗暴的经验，是当你需要将这个函数传递给子组件时，可以使用 `useCallback` 来避免子组件不必要的渲染（子组件使用 `useMemo`）；更准确的说法，是当你需要依赖引用相等性时，就应使用 `useCallback` 。  \n\n#### 2019/12/17\n保留四位有效数字：\n```\nx.toPrecise(4) // return string\n```\n\n#### 2019/12/9\n\n使用原生方法实现文件点击/拖拽上传，并限制只能上传单个 JSON 文件：\n主要思想是监听 `onClick` 和 `onDrop` 事件，注意在 React 中，如果我们需要注册捕获阶段的事件处理函数，则应为事件名添加 `Capture`。例如，使用处理捕获阶段的点击事件 `onClickCapture`，而不是 `onClick`。详情可参考官方文档 [Supported Events](https://reactjs.org/docs/events.html#supported-events) 。\n\n```\n// upload.tsx\n  ...\n  const handleUploadClick = () => {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = \".json,application/json\";\n    input.onchange = ev => {\n      // double-checked\n      if (\n        input.files &&\n        input.files.length === 1 &&\n        input.files[0].type === \"application/json\"\n      ) {\n        // deal with input.files\n      }\n    };\n    input.click();\n  };\n\n  const handleUploadDrop = (ev:       React.DragEvent<HTMLDivElement>) => {\n    if (ev.dataTransfer.files.length > 1) {\n      console.error(\"只允许上传单个文件\");\n    } else if (ev.dataTransfer.files[0].type !== \"application/json\") {\n      console.error(\"只允许上传json文件\");\n    } else {\n      // deal with ev.dataTransfer.files[0]\n    }\n  };\n\n  ...\n\n  render() {\n    return (\n      <div\n        onClickCapture={ev => {\n          ev.preventDefault();\n          ev.stopPropagation();\n          handleUploadClick();\n        }}\n        onDropCapture={ev => {\n          ev.preventDefault();\n          ev.stopPropagation();\n          handleUploadDrop(ev);\n        }}\n      >\n        Click or drag file to this area to upload\n      </div>\n    )\n  }\n\n```\n","slug":"FrontEnd-Daily-Learning-2019-12","published":1,"updated":"2020-03-04T02:51:22.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7ef1vhb0007qsue0q13ggxd","content":"<h4 id=\"about\">About</h4>\n<p>📅 2019 年 12 月的零散学习记录。</p>\n<h4 id=\"20191226\">2019/12/26</h4>\n<p>今日阅读：<a href=\"https://kentcdodds.com/blog/usememo-and-usecallback\" target=\"_blank\" rel=\"noopener\">When to useMemo and useCallback</a><br>\n起因是刷 reddit 时看到了这篇 <a href=\"https://www.reddit.com/r/reactjs/comments/efjgfc/should_i_use_usecallback_in_every_function/\" target=\"_blank\" rel=\"noopener\">帖子</a>，提问者的问题是 “Should I use useCallback in every function declared inside a functional component?”，评论中有人贴出了这个链接，更正了我对性能优化的一些错误认知。<br>\n作者在文章中举了一个例子，在某个函数组件中有这样一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = candy =&gt; &#123;</span><br><span class=\"line\">  setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题：如果用 <code>useCallback</code> 包裹，那么性能会不会更好呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = React.useCallback(candy =&gt; &#123;</span><br><span class=\"line\">  setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">&#125;, [])</span><br></pre></td></tr></table></figure>\n<p>我刚开始的答案是使用 <code>useCallback</code> 会更好，毫无疑问是错的。上面的函数也可被写成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = candy =&gt; &#123;</span><br><span class=\"line\">    setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">+ const dispenseCallback = React.useCallback(dispense, [])</span><br></pre></td></tr></table></figure>\n<p>diff 之后会发现只是多了一行，该有的声明还是有，还需要做更多的工作。现在不仅仅要定义函数，还要定义依赖数组，调用 <code>useCallback</code> 进行赋值分配等工作。之前我一直误以为，使用 <code>useCallback</code> 后，函数只会在第一次渲染时定义并赋值，第二次渲染不会做额外的操作。其实不是的，这里的相等可以理解为是 “指向的位置” 相等，类似 <code>ref</code> 和 <code>ref.current</code>，重新渲染时就相当于执行 <code>ref.current = newVal</code> 。<br>\n那什么时候需要用到 <code>useCallback</code> 呢？官方文档是这样写的：</p>\n<blockquote>\n<p>This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).</p>\n</blockquote>\n<p>最简单粗暴的经验，是当你需要将这个函数传递给子组件时，可以使用 <code>useCallback</code> 来避免子组件不必要的渲染（子组件使用 <code>useMemo</code>）；更准确的说法，是当你需要依赖引用相等性时，就应使用 <code>useCallback</code> 。</p>\n<h4 id=\"20191217\">2019/12/17</h4>\n<p>保留四位有效数字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x.toPrecise(4) // return string</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019129\">2019/12/9</h4>\n<p>使用原生方法实现文件点击/拖拽上传，并限制只能上传单个 JSON 文件：<br>\n主要思想是监听 <code>onClick</code> 和 <code>onDrop</code> 事件，注意在 React 中，如果我们需要注册捕获阶段的事件处理函数，则应为事件名添加 <code>Capture</code>。例如，使用处理捕获阶段的点击事件 <code>onClickCapture</code>，而不是 <code>onClick</code>。详情可参考官方文档 <a href=\"https://reactjs.org/docs/events.html#supported-events\" target=\"_blank\" rel=\"noopener\">Supported Events</a> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// upload.tsx</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  const handleUploadClick = () =&gt; &#123;</span><br><span class=\"line\">    const input = document.createElement(&quot;input&quot;);</span><br><span class=\"line\">    input.type = &quot;file&quot;;</span><br><span class=\"line\">    input.accept = &quot;.json,application/json&quot;;</span><br><span class=\"line\">    input.onchange = ev =&gt; &#123;</span><br><span class=\"line\">      // double-checked</span><br><span class=\"line\">      if (</span><br><span class=\"line\">        input.files &amp;&amp;</span><br><span class=\"line\">        input.files.length === 1 &amp;&amp;</span><br><span class=\"line\">        input.files[0].type === &quot;application/json&quot;</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        // deal with input.files</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    input.click();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleUploadDrop = (ev:       React.DragEvent&lt;HTMLDivElement&gt;) =&gt; &#123;</span><br><span class=\"line\">    if (ev.dataTransfer.files.length &gt; 1) &#123;</span><br><span class=\"line\">      console.error(&quot;只允许上传单个文件&quot;);</span><br><span class=\"line\">    &#125; else if (ev.dataTransfer.files[0].type !== &quot;application/json&quot;) &#123;</span><br><span class=\"line\">      console.error(&quot;只允许上传json文件&quot;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // deal with ev.dataTransfer.files[0]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div</span><br><span class=\"line\">        onClickCapture=&#123;ev =&gt; &#123;</span><br><span class=\"line\">          ev.preventDefault();</span><br><span class=\"line\">          ev.stopPropagation();</span><br><span class=\"line\">          handleUploadClick();</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">        onDropCapture=&#123;ev =&gt; &#123;</span><br><span class=\"line\">          ev.preventDefault();</span><br><span class=\"line\">          ev.stopPropagation();</span><br><span class=\"line\">          handleUploadDrop(ev);</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        Click or drag file to this area to upload</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4>About</h4>\n<p>📅 2019 年 12 月的零散学习记录。</p>\n<h4>2019/12/26</h4>\n<p>今日阅读：<a href=\"https://kentcdodds.com/blog/usememo-and-usecallback\" target=\"_blank\" rel=\"noopener\">When to useMemo and useCallback</a><br>\n起因是刷 reddit 时看到了这篇 <a href=\"https://www.reddit.com/r/reactjs/comments/efjgfc/should_i_use_usecallback_in_every_function/\" target=\"_blank\" rel=\"noopener\">帖子</a>，提问者的问题是 “Should I use useCallback in every function declared inside a functional component?”，评论中有人贴出了这个链接，更正了我对性能优化的一些错误认知。<br>\n作者在文章中举了一个例子，在某个函数组件中有这样一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = candy =&gt; &#123;</span><br><span class=\"line\">  setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题：如果用 <code>useCallback</code> 包裹，那么性能会不会更好呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = React.useCallback(candy =&gt; &#123;</span><br><span class=\"line\">  setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">&#125;, [])</span><br></pre></td></tr></table></figure>\n<p>我刚开始的答案是使用 <code>useCallback</code> 会更好，毫无疑问是错的。上面的函数也可被写成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = candy =&gt; &#123;</span><br><span class=\"line\">    setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">+ const dispenseCallback = React.useCallback(dispense, [])</span><br></pre></td></tr></table></figure>\n<p>diff 之后会发现只是多了一行，该有的声明还是有，还需要做更多的工作。现在不仅仅要定义函数，还要定义依赖数组，调用 <code>useCallback</code> 进行赋值分配等工作。之前我一直误以为，使用 <code>useCallback</code> 后，函数只会在第一次渲染时定义并赋值，第二次渲染不会做额外的操作。其实不是的，这里的相等可以理解为是 “指向的位置” 相等，类似 <code>ref</code> 和 <code>ref.current</code>，重新渲染时就相当于执行 <code>ref.current = newVal</code> 。<br>\n那什么时候需要用到 <code>useCallback</code> 呢？官方文档是这样写的：</p>\n<blockquote>\n<p>This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).</p>\n</blockquote>\n<p>最简单粗暴的经验，是当你需要将这个函数传递给子组件时，可以使用 <code>useCallback</code> 来避免子组件不必要的渲染（子组件使用 <code>useMemo</code>）；更准确的说法，是当你需要依赖引用相等性时，就应使用 <code>useCallback</code> 。</p>\n<h4>2019/12/17</h4>\n<p>保留四位有效数字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x.toPrecise(4) // return string</span><br></pre></td></tr></table></figure>\n<h4>2019/12/9</h4>\n<p>使用原生方法实现文件点击/拖拽上传，并限制只能上传单个 JSON 文件：<br>\n主要思想是监听 <code>onClick</code> 和 <code>onDrop</code> 事件，注意在 React 中，如果我们需要注册捕获阶段的事件处理函数，则应为事件名添加 <code>Capture</code>。例如，使用处理捕获阶段的点击事件 <code>onClickCapture</code>，而不是 <code>onClick</code>。详情可参考官方文档 <a href=\"https://reactjs.org/docs/events.html#supported-events\" target=\"_blank\" rel=\"noopener\">Supported Events</a> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// upload.tsx</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  const handleUploadClick = () =&gt; &#123;</span><br><span class=\"line\">    const input = document.createElement(&quot;input&quot;);</span><br><span class=\"line\">    input.type = &quot;file&quot;;</span><br><span class=\"line\">    input.accept = &quot;.json,application/json&quot;;</span><br><span class=\"line\">    input.onchange = ev =&gt; &#123;</span><br><span class=\"line\">      // double-checked</span><br><span class=\"line\">      if (</span><br><span class=\"line\">        input.files &amp;&amp;</span><br><span class=\"line\">        input.files.length === 1 &amp;&amp;</span><br><span class=\"line\">        input.files[0].type === &quot;application/json&quot;</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        // deal with input.files</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    input.click();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleUploadDrop = (ev:       React.DragEvent&lt;HTMLDivElement&gt;) =&gt; &#123;</span><br><span class=\"line\">    if (ev.dataTransfer.files.length &gt; 1) &#123;</span><br><span class=\"line\">      console.error(&quot;只允许上传单个文件&quot;);</span><br><span class=\"line\">    &#125; else if (ev.dataTransfer.files[0].type !== &quot;application/json&quot;) &#123;</span><br><span class=\"line\">      console.error(&quot;只允许上传json文件&quot;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // deal with ev.dataTransfer.files[0]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div</span><br><span class=\"line\">        onClickCapture=&#123;ev =&gt; &#123;</span><br><span class=\"line\">          ev.preventDefault();</span><br><span class=\"line\">          ev.stopPropagation();</span><br><span class=\"line\">          handleUploadClick();</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">        onDropCapture=&#123;ev =&gt; &#123;</span><br><span class=\"line\">          ev.preventDefault();</span><br><span class=\"line\">          ev.stopPropagation();</span><br><span class=\"line\">          handleUploadDrop(ev);</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        Click or drag file to this area to upload</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/re-paramerise.png","slug":"re-paramerise.png","post":"ck7bsdjt3000jcsueyf07r7qy","modified":0,"renderable":0},{"_id":"source/_posts/PaperReadingNotes2020-0223/ofa-results1.png","slug":"ofa-results1.png","post":"ck7bsdjsj0003csueaqsyrfl7","modified":0,"renderable":0},{"_id":"source/_posts/PaperReadingNotes2020-0223/progressive_shrinking.png","slug":"progressive_shrinking.png","post":"ck7bsdjsj0003csueaqsyrfl7","modified":0,"renderable":0},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/gumbel1.png","slug":"gumbel1.png","post":"ck7bsdjt3000jcsueyf07r7qy","modified":0,"renderable":0},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/gumbel2.png","slug":"gumbel2.png","post":"ck7bsdjt3000jcsueyf07r7qy","modified":0,"renderable":0},{"_id":"source/_posts/FrontEnd-Daily-Learning-2019-07-08/FE_20190806.png","slug":"FE_20190806.png","post":"ck7ef1vha0006qsue6h208ah6","modified":0,"renderable":0},{"_id":"source/_posts/FrontEnd-Daily-Learning-2019-07-08/FE_20190808.png","slug":"FE_20190808.png","post":"ck7ef1vha0006qsue6h208ah6","modified":0,"renderable":0},{"_id":"source/_posts/FrontEnd-Daily-Learning-2019-07-08/FE_20190809.png","slug":"FE_20190809.png","post":"ck7ef1vha0006qsue6h208ah6","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ck7bsdjsj0003csueaqsyrfl7","tag_id":"ck7bsdjsp0007csuemh8cgkua","_id":"ck7bsdjsy000ccsue4mr7xdae"},{"post_id":"ck7bsdjsy000dcsuenbqvrjub","tag_id":"ck7bsdjsx000bcsuecdgv5lmm","_id":"ck7bsdjt1000gcsuez94437oc"},{"post_id":"ck7bsdjsn0005csue4cevoipf","tag_id":"ck7bsdjsx000bcsuecdgv5lmm","_id":"ck7bsdjt3000icsuej6ywo597"},{"post_id":"ck7bsdjt3000jcsueyf07r7qy","tag_id":"ck7bsdjsp0007csuemh8cgkua","_id":"ck7bsdjt8000scsueike6z47b"},{"post_id":"ck7bsdjt5000mcsuet8q93a0a","tag_id":"ck7bsdjsx000bcsuecdgv5lmm","_id":"ck7bsdjt9000ucsue1dsr97qk"},{"post_id":"ck7bsdjt6000ocsueqv17rczw","tag_id":"ck7bsdjsp0007csuemh8cgkua","_id":"ck7bsdjt9000xcsue6jpm3pa3"},{"post_id":"ck7bsdjt7000rcsue7jehi3vv","tag_id":"ck7bsdjsx000bcsuecdgv5lmm","_id":"ck7bsdjta000ycsueq8qycqiw"},{"post_id":"ck7bsdjsv000acsue3tru7iq8","tag_id":"ck7bsdjt6000pcsuebmhkg7f7","_id":"ck7bsdjta000zcsuehenwkjf1"},{"post_id":"ck7bsdjt8000tcsue78f03yg1","tag_id":"ck7bsdjsx000bcsuecdgv5lmm","_id":"ck7bsdjta0010csue7sdq8elm"},{"post_id":"ck7bsdjt8000tcsue78f03yg1","tag_id":"ck7bsdjt9000vcsueq37fhvjw","_id":"ck7bsdjta0011csue6lfx8p0i"},{"post_id":"ck7ef1vgj0000qsuep0ntbnn9","tag_id":"ck7bsdjsx000bcsuecdgv5lmm","_id":"ck7ef1vgy0002qsue9mq6kly8"},{"post_id":"ck7ef1vgo0001qsue1imt4il3","tag_id":"ck7bsdjsx000bcsuecdgv5lmm","_id":"ck7ef1vgz0004qsuelhkt1yyn"},{"post_id":"ck7ef1vgy0003qsueq3hxi5vd","tag_id":"ck7bsdjsx000bcsuecdgv5lmm","_id":"ck7ef1vh00005qsuejd0q3n1g"},{"post_id":"ck7ef1vha0006qsue6h208ah6","tag_id":"ck7bsdjsx000bcsuecdgv5lmm","_id":"ck7ef1vhf0008qsue98reqpwp"},{"post_id":"ck7ef1vhb0007qsue0q13ggxd","tag_id":"ck7bsdjsx000bcsuecdgv5lmm","_id":"ck7ef1vhg0009qsuen0u4ko7a"}],"Tag":[{"name":"ML","_id":"ck7bsdjsp0007csuemh8cgkua"},{"name":"FE","_id":"ck7bsdjsx000bcsuecdgv5lmm"},{"name":"Daily","_id":"ck7bsdjt6000pcsuebmhkg7f7"},{"name":"YDKJS","_id":"ck7bsdjt9000vcsueq37fhvjw"}]}}