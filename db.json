{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/huweihuang/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/avatar/we.png","path":"img/avatar/we.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/404.jpg","path":"img/header_img/404.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/tag.jpg","path":"img/header_img/tag.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":0,"renderable":0},{"_id":"source/img/blog.jpg","path":"img/blog.jpg","modified":0,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":0,"renderable":0},{"_id":"source/img/avatar/we.jpg","path":"img/avatar/we.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8b9e17605b69cf3d2b0cbf8ddc5c7357d538ccd9","modified":1575788116882},{"_id":"source/CNAME","hash":"60a9ce3696e7262df3d5ba09815b15082353176e","modified":1575788116882},{"_id":"themes/huweihuang/_config.yml","hash":"f29811ef62e8d1bec51d14eac30eae0d345b130a","modified":1575795257635},{"_id":"themes/huweihuang/LICENSE","hash":"c48eaae47a703282e0ffe7b91d69366452046214","modified":1575788117127},{"_id":"source/about/index.md","hash":"563abf8b0f19e4b3476e8ed0669b56bafc32a2dc","modified":1575797945824},{"_id":"source/_posts/FE-Resources-Collection.md","hash":"acb9e4788a40b167929134af6829fcf56ea36d65","modified":1578363938350},{"_id":"source/_posts/FrontEnd-Daily-Learning.md","hash":"3c1367fa0e9c88023090bbb44435c18edc8327a3","modified":1575793973615},{"_id":"source/_posts/FrontEnd-Notes-2019-12.md","hash":"666482d88a364d1d7ccd828ef4bfa1ae96fb900c","modified":1577930268925},{"_id":"source/_posts/FrontEnd-Notes-2020-01.md","hash":"579f66af28169dd7573bf4ff0cd8b2314d7b0908","modified":1578797219170},{"_id":"source/_posts/We Are Graduated!.md","hash":"c75b86faa55caae69d57ef2ccf0138e0be0b419d","modified":1575788116892},{"_id":"source/_posts/Resources.md","hash":"a0b0f179d0e2cb4802b3b64ef5934660b518b75f","modified":1577930452567},{"_id":"source/_posts/一些工作中涉及到的技术文档集合.md","hash":"946feb8512a809eace7f930e20ecb23d83bf002c","modified":1578534030731},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick.md","hash":"d78fd9ad10ac89959082577441ed07ae172e7420","modified":1575907751836},{"_id":"source/archive/index.md","hash":"87e995582a1fedab64a901410a1a9d7390f75b94","modified":1575788116926},{"_id":"source/tags/index.md","hash":"9a417cb743a80a4ea6e78e833c13d5faeba2508c","modified":1575798133019},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1575790252732},{"_id":"themes/huweihuang/layout/404.ejs","hash":"2e8d719fab50014b7963d3c2f4ee34c23e749d7b","modified":1575788117137},{"_id":"themes/huweihuang/layout/about.ejs","hash":"96c08fc3580b842ad9d8f37f2cdf02e6fa57d7bc","modified":1575788117144},{"_id":"themes/huweihuang/layout/archive.ejs","hash":"62781e8b0ce4de9c3db6042fedeaf13c26d138f8","modified":1575788117145},{"_id":"themes/huweihuang/layout/index.ejs","hash":"f293cefe4bf9f9c6848dff08b6dac4aeb7948892","modified":1575788117145},{"_id":"themes/huweihuang/layout/layout.ejs","hash":"389fc11a45676f94b77ebd2cb0d658a0358979c8","modified":1575788117146},{"_id":"themes/huweihuang/layout/keynote.ejs","hash":"e177b9e4a159f40b512f4ae1bfd928be4ab60840","modified":1575788117146},{"_id":"themes/huweihuang/layout/page.ejs","hash":"f77a9eb0e09931eac85e8244027eb5678c7b0705","modified":1575788117147},{"_id":"themes/huweihuang/layout/tags.ejs","hash":"63911a99e6daf9968bfdd7d69f0d3d697039902e","modified":1575788117148},{"_id":"themes/huweihuang/languages_to_be_added/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1575788117129},{"_id":"themes/huweihuang/languages_to_be_added/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1575788117130},{"_id":"themes/huweihuang/layout/post.ejs","hash":"1d5e2e84ed5d8e7679612ae07660128b02f8e954","modified":1575793973615},{"_id":"themes/huweihuang/languages_to_be_added/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1575788117130},{"_id":"themes/huweihuang/languages_to_be_added/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1575788117131},{"_id":"themes/huweihuang/languages_to_be_added/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1575788117132},{"_id":"themes/huweihuang/languages_to_be_added/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1575788117132},{"_id":"themes/huweihuang/languages_to_be_added/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1575788117134},{"_id":"themes/huweihuang/languages_to_be_added/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1575788117135},{"_id":"themes/huweihuang/languages_to_be_added/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1575788117136},{"_id":"source/_posts/FrontEnd-Daily-Learning/FE_20190809.png","hash":"8e381370d624b8863b6eb44fd2fa8e55c4ce5296","modified":1575788116888},{"_id":"source/_posts/FrontEnd-Daily-Learning/FE_20190806.png","hash":"cf1e11f4935faca118ffa5ec422350393827b54b","modified":1575788116886},{"_id":"source/_posts/FrontEnd-Daily-Learning/FE_20190808.png","hash":"bca41264a7be4e31f610710c569b14e04e0e68a8","modified":1575788116887},{"_id":"themes/huweihuang/layout/_partial/footer.ejs","hash":"f3619af90437b15c757b2fdd37907cc6a7484e7d","modified":1575788117138},{"_id":"themes/huweihuang/layout/_partial/head.ejs","hash":"07e23da21331914b971bb0317f545ea677484180","modified":1575788117139},{"_id":"themes/huweihuang/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1575788117141},{"_id":"themes/huweihuang/layout/_partial/nav.ejs","hash":"e65bfec3d14a9eb9f1e09b592bb34023e6bf6e83","modified":1575788117140},{"_id":"themes/huweihuang/layout/_partial/header.ejs","hash":"10d5e0966895f86373b0652e9ad2df69d742bfe4","modified":1575788117140},{"_id":"themes/huweihuang/layout/_partial/sidebar.ejs","hash":"bc7834dd769eeac94a76ffd9cfbb13a622861b62","modified":1575788117141},{"_id":"themes/huweihuang/layout/_partial/toc.ejs","hash":"aa41fc56f2fa03559aa266fc062772e9e3bbebbf","modified":1575788117141},{"_id":"themes/huweihuang/layout/_widget/archive.ejs","hash":"ad9fb0073d40fe90bfe3a1e3246e0b07e12b3ecf","modified":1575788117142},{"_id":"themes/huweihuang/layout/_widget/featured-tags.ejs","hash":"e29431fa78c81d7c521bb1f7be356651fcde959c","modified":1575788117142},{"_id":"themes/huweihuang/layout/_widget/friends-blog.ejs","hash":"b185fcffb0d181ddd9eb2259af38cf7d82fb2846","modified":1575788117143},{"_id":"themes/huweihuang/layout/_widget/recent-posts.ejs","hash":"814dd716083a8a75eb31f9d2d6ab28150b01c533","modified":1575788117143},{"_id":"themes/huweihuang/layout/_widget/category.ejs","hash":"c32e6fb8f3a07c5cbaffcebf93c357237c18b009","modified":1575788117142},{"_id":"themes/huweihuang/layout/_widget/short-about.ejs","hash":"bc918e897eead442ca3b6e5a11824402a8aeb18d","modified":1575788117144},{"_id":"themes/huweihuang/source/css/archive.styl","hash":"bcb216ef65804c97b1a5dbe5f519fc171a13aaf1","modified":1575788117149},{"_id":"themes/huweihuang/source/css/beantech.css","hash":"5e9bee0a553da83a3efd4e9bc975a0ebd13b1b7d","modified":1575788117149},{"_id":"themes/huweihuang/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1575788117150},{"_id":"themes/huweihuang/source/css/donate.css","hash":"948c148076e7e0e0f78225f753813012938f5022","modified":1575788117153},{"_id":"themes/huweihuang/source/css/highlight.styl","hash":"831f8195f3577ba5bea374f2e24b90054d445055","modified":1575788117154},{"_id":"themes/huweihuang/source/css/signature.styl","hash":"63ae8051f59d5e69544647cc4173eabc81d99aae","modified":1575788117155},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1575788117154},{"_id":"themes/huweihuang/source/css/rocket.styl","hash":"0abbccdbcd6cce70e8a0bab7152c38adc0b708f1","modified":1575788117155},{"_id":"themes/huweihuang/source/css/widget.styl","hash":"f996466e299c68274145ba5afaca9b6d1dd83114","modified":1575788117157},{"_id":"themes/huweihuang/source/css/toc.styl","hash":"e197d57dc5312b20974193b6991c779e266fadca","modified":1575788117156},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1575788117157},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1575788117159},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1575788117160},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1575788117161},{"_id":"themes/huweihuang/source/js/hux-blog.js","hash":"3d3c93e42a9990b2a2e6df5a08e9816f9a221e0f","modified":1575788117165},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","hash":"ee99af17a1a69ac8d85a695fed0349ba202789ae","modified":1575788117166},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","hash":"313da686ebbe387064f2d1899c64ea562b81eb40","modified":1575788117164},{"_id":"themes/huweihuang/source/js/jquery.nav.js","hash":"bc6383fa2aa8f437978cf044a3b6f10a65114398","modified":1575788117173},{"_id":"themes/huweihuang/source/js/toc.js","hash":"4ffe95b7755b035ee1b41664fa72b0ebea29c3f8","modified":1575788117174},{"_id":"themes/huweihuang/source/js/totop.js","hash":"f796b09b4f6177c3674a8c1542a8c92e8590cb5c","modified":1575788117175},{"_id":"source/_posts/Reinforcement-Learning-Post-1-Basic-Knowledge-and-Background/LDS-GNN.png","hash":"5fcbe43d5637218a0a05b5938af037d262ebd53e","modified":1575788116891},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","hash":"448017ff32f75f444ed7985d10a21b3ad92ab100","modified":1575788117174},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","hash":"1818a346630e7133a1f194669f613f613fcfa97c","modified":1575788117153},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1575788117158},{"_id":"themes/huweihuang/source/js/bootstrap.js","hash":"5d69034fb6eded2e5961ea54dd47129a88cd5182","modified":1575788117163},{"_id":"themes/huweihuang/source/js/jquery.min.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1575788117172},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1575788117125},{"_id":"themes/huweihuang/source/css/bootstrap.css","hash":"d1a24afac31222d70b4e001e0361ef045aa42043","modified":1575788117151},{"_id":"themes/huweihuang/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1575788117155},{"_id":"themes/huweihuang/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1575788117155},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/re-paramerise.png","hash":"44fd0e604c5419e1aa8bc710b9696ed860f891cb","modified":1575788116906},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/gumbel2.png","hash":"723753b396f4b0490ef5c831db3be60c3f0aff75","modified":1575788116902},{"_id":"source/img/avatar/we.png","hash":"bcb66101bf0be4147664ad308baf85904e7054d5","modified":1575788117008},{"_id":"source/img/header_img/home.jpg","hash":"67be147e02ddb76ea40a3c07e0f7e41805b52354","modified":1575817320311},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1575788117121},{"_id":"themes/huweihuang/source/js/jquery.js","hash":"4bb763dc96da604aed08ac024a1a3f5de73eea39","modified":1575788117170},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/gumbel1.png","hash":"f4553c67e4b451a8461cfccd9ec7ebf767631b52","modified":1575788116897},{"_id":"source/img/article_header/article_bg.jpg","hash":"acc16e8a1e024239415bed316e09f481651c342d","modified":1575796664058},{"_id":"source/img/header_img/404.jpg","hash":"5313a0db2c29e6ea1c48e952e48ffc59f931d169","modified":1575816281673},{"_id":"source/img/header_img/tag.jpg","hash":"f16f692e9fd31cba89b2df25d23079260a8fe8ec","modified":1575816045471},{"_id":"source/img/header_img/about.jpg","hash":"eee9ab1704c5220d629cc552611954c8f1420137","modified":1575815839059},{"_id":"source/img/blog.jpg","hash":"a76af0b98dbe92ca2d21babcef13f094e409554b","modified":1575790252731},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1575788116952},{"_id":"source/img/header_img/archive.jpg","hash":"78ab7bc8c864c0e1922cd5229ff115edf80f999d","modified":1575815899943},{"_id":"source/_posts/hexo-theme-huweihuang/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1575790252725},{"_id":"source/img/avatar/we.jpg","hash":"86b6728028a68a6ba9cbf1302ee08daa73e95d65","modified":1575788117005}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2019-12-08T06:55:16.882Z","updated":"2019-12-08T06:55:16.882Z","path":"404.html","title":"","comments":1,"_id":"ck5393iqu0000icueop2xnqrp","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2017-10-03T02:48:33.000Z","description":"Enjoy Coding, Enjoy Life","header-img":"/img/header_img/about.jpg","aplayer":false,"fixed":false,"_content":"\n### Who Are We?\n\nWe are lovers:couple_with_heart: graduated from [School of Data and Computer Science](http://sdcs.sysu.edu.cn/) in [Sun Yat-Sen university](http://www.sysu.edu.cn/2012/en/index.htm). \n\n### What This Blog for?\n\nWe build this site to track our life and thoughts.\n\n### What Are in This Blog?\n\nWe are interested in Front-end technologies, Machine Learning & Deep Learning Algorithms.  \nWe also track our life moments here.\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2017-10-03 10:48:33\ndescription: \"Enjoy Coding, Enjoy Life\"\nheader-img: \"/img/header_img/about.jpg\"\naplayer: false\nfixed: false\n---\n\n### Who Are We?\n\nWe are lovers:couple_with_heart: graduated from [School of Data and Computer Science](http://sdcs.sysu.edu.cn/) in [Sun Yat-Sen university](http://www.sysu.edu.cn/2012/en/index.htm). \n\n### What This Blog for?\n\nWe build this site to track our life and thoughts.\n\n### What Are in This Blog?\n\nWe are interested in Front-end technologies, Machine Learning & Deep Learning Algorithms.  \nWe also track our life moments here.\n","updated":"2019-12-08T09:39:05.824Z","path":"about/index.html","comments":1,"_id":"ck5393irt0002icuemyjo2ksw","content":"<h3 id=\"who-are-we\">Who Are We?</h3>\n<p>We are lovers:couple_with_heart: graduated from <a href=\"http://sdcs.sysu.edu.cn/\" target=\"_blank\" rel=\"noopener\">School of Data and Computer Science</a> in <a href=\"http://www.sysu.edu.cn/2012/en/index.htm\" target=\"_blank\" rel=\"noopener\">Sun Yat-Sen university</a>.</p>\n<h3 id=\"what-this-blog-for\">What This Blog for?</h3>\n<p>We build this site to track our life and thoughts.</p>\n<h3 id=\"what-are-in-this-blog\">What Are in This Blog?</h3>\n<p>We are interested in Front-end technologies, Machine Learning &amp; Deep Learning Algorithms.<br>\nWe also track our life moments here.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>Who Are We?</h3>\n<p>We are lovers:couple_with_heart: graduated from <a href=\"http://sdcs.sysu.edu.cn/\" target=\"_blank\" rel=\"noopener\">School of Data and Computer Science</a> in <a href=\"http://www.sysu.edu.cn/2012/en/index.htm\" target=\"_blank\" rel=\"noopener\">Sun Yat-Sen university</a>.</p>\n<h3>What This Blog for?</h3>\n<p>We build this site to track our life and thoughts.</p>\n<h3>What Are in This Blog?</h3>\n<p>We are interested in Front-end technologies, Machine Learning &amp; Deep Learning Algorithms.<br>\nWe also track our life moments here.</p>\n"},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-12-08T06:55:16.926Z","path":"archive/index.html","_id":"ck5393irw0004icuekux89w6t","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.jpg","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.jpg\"\n---\n","date":"2019-12-08T09:42:13.019Z","updated":"2019-12-08T09:42:13.019Z","path":"tags/index.html","comments":1,"_id":"ck5393it0000oicuexwch1xr1","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"FE Resources Collection","catalog":true,"date":"2020-01-02T02:23:08.000Z","subtitle":null,"header-img":null,"_content":"👷🚧\n\n### 博客/社区/论坛\n- [Dev Community](https://dev.to/)\n- [Github](https://github.com/)\n- [Medium](https://medium.com/)\n- [Reddit](https://www.reddit.com/)\n- [腾讯 IMWeb 团队前端社区](https://imweb.io/topic/tab/all)\n- [腾讯 AlloyTeam 全端博客](http://www.alloyteam.com/page/0/)\n- [React 团队成员 Dan Abramov 个人博客](https://overreacted.io/)\n\n### 资讯类\n- [每日时报](https://github.com/wubaiqing/zaobao)\n- [前端面试每日三问](https://github.com/haizlin/fe-interview)\n- [Github Daily](https://github.com/GitHubDaily/GitHubDaily)\n\n### 技能图谱/技术清单\n- [Frontend Developer](https://roadmap.sh/frontend)\n- [React Developer Roadmap](https://github.com/adam-golab/react-developer-roadmap)\n- [前端技术清单](https://alienzhou.github.io/frontend-tech-list/)\n\n### 面试宝典\n- [大前端面试宝典 - 图解前端](https://lucifer.ren/fe-interview/#/)\n\n","source":"_posts/FE-Resources-Collection.md","raw":"---\ntitle: FE Resources Collection\ncatalog: true\ndate: 2020-01-02 10:23:08\nsubtitle:\nheader-img:\ntags: FE \n---\n👷🚧\n\n### 博客/社区/论坛\n- [Dev Community](https://dev.to/)\n- [Github](https://github.com/)\n- [Medium](https://medium.com/)\n- [Reddit](https://www.reddit.com/)\n- [腾讯 IMWeb 团队前端社区](https://imweb.io/topic/tab/all)\n- [腾讯 AlloyTeam 全端博客](http://www.alloyteam.com/page/0/)\n- [React 团队成员 Dan Abramov 个人博客](https://overreacted.io/)\n\n### 资讯类\n- [每日时报](https://github.com/wubaiqing/zaobao)\n- [前端面试每日三问](https://github.com/haizlin/fe-interview)\n- [Github Daily](https://github.com/GitHubDaily/GitHubDaily)\n\n### 技能图谱/技术清单\n- [Frontend Developer](https://roadmap.sh/frontend)\n- [React Developer Roadmap](https://github.com/adam-golab/react-developer-roadmap)\n- [前端技术清单](https://alienzhou.github.io/frontend-tech-list/)\n\n### 面试宝典\n- [大前端面试宝典 - 图解前端](https://lucifer.ren/fe-interview/#/)\n\n","slug":"FE-Resources-Collection","published":1,"updated":"2020-01-07T02:25:38.350Z","_id":"ck5393irp0001icue4956j72g","comments":1,"layout":"post","photos":[],"link":"","content":"<p>👷🚧</p>\n<h3 id=\"博客社区论坛\"><a href=\"#博客-社区-论坛\" class=\"headerlink\" title=\"博客/社区/论坛\"></a>博客/社区/论坛</h3><ul>\n<li><a href=\"https://dev.to/\" target=\"_blank\" rel=\"noopener\">Dev Community</a></li>\n<li><a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n<li><a href=\"https://medium.com/\" target=\"_blank\" rel=\"noopener\">Medium</a></li>\n<li><a href=\"https://www.reddit.com/\" target=\"_blank\" rel=\"noopener\">Reddit</a></li>\n<li><a href=\"https://imweb.io/topic/tab/all\" target=\"_blank\" rel=\"noopener\">腾讯 IMWeb 团队前端社区</a></li>\n<li><a href=\"http://www.alloyteam.com/page/0/\" target=\"_blank\" rel=\"noopener\">腾讯 AlloyTeam 全端博客</a></li>\n<li><a href=\"https://overreacted.io/\" target=\"_blank\" rel=\"noopener\">React 团队成员 Dan Abramov 个人博客</a></li>\n</ul>\n<h3 id=\"资讯类\"><a href=\"#资讯类\" class=\"headerlink\" title=\"资讯类\"></a>资讯类</h3><ul>\n<li><a href=\"https://github.com/wubaiqing/zaobao\" target=\"_blank\" rel=\"noopener\">每日时报</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\" target=\"_blank\" rel=\"noopener\">前端面试每日三问</a></li>\n<li><a href=\"https://github.com/GitHubDaily/GitHubDaily\" target=\"_blank\" rel=\"noopener\">Github Daily</a></li>\n</ul>\n<h3 id=\"技能图谱技术清单\"><a href=\"#技能图谱-技术清单\" class=\"headerlink\" title=\"技能图谱/技术清单\"></a>技能图谱/技术清单</h3><ul>\n<li><a href=\"https://roadmap.sh/frontend\" target=\"_blank\" rel=\"noopener\">Frontend Developer</a></li>\n<li><a href=\"https://github.com/adam-golab/react-developer-roadmap\" target=\"_blank\" rel=\"noopener\">React Developer Roadmap</a></li>\n<li><a href=\"https://alienzhou.github.io/frontend-tech-list/\" target=\"_blank\" rel=\"noopener\">前端技术清单</a></li>\n</ul>\n<h3 id=\"面试宝典\"><a href=\"#面试宝典\" class=\"headerlink\" title=\"面试宝典\"></a>面试宝典</h3><ul>\n<li><a href=\"https://lucifer.ren/fe-interview/#/\" target=\"_blank\" rel=\"noopener\">大前端面试宝典 - 图解前端</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>👷🚧</p>\n<h3 id=\"博客-社区-论坛\"><a href=\"#博客-社区-论坛\" class=\"headerlink\" title=\"博客/社区/论坛\"></a>博客/社区/论坛</h3><ul>\n<li><a href=\"https://dev.to/\" target=\"_blank\" rel=\"noopener\">Dev Community</a></li>\n<li><a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n<li><a href=\"https://medium.com/\" target=\"_blank\" rel=\"noopener\">Medium</a></li>\n<li><a href=\"https://www.reddit.com/\" target=\"_blank\" rel=\"noopener\">Reddit</a></li>\n<li><a href=\"https://imweb.io/topic/tab/all\" target=\"_blank\" rel=\"noopener\">腾讯 IMWeb 团队前端社区</a></li>\n<li><a href=\"http://www.alloyteam.com/page/0/\" target=\"_blank\" rel=\"noopener\">腾讯 AlloyTeam 全端博客</a></li>\n<li><a href=\"https://overreacted.io/\" target=\"_blank\" rel=\"noopener\">React 团队成员 Dan Abramov 个人博客</a></li>\n</ul>\n<h3 id=\"资讯类\"><a href=\"#资讯类\" class=\"headerlink\" title=\"资讯类\"></a>资讯类</h3><ul>\n<li><a href=\"https://github.com/wubaiqing/zaobao\" target=\"_blank\" rel=\"noopener\">每日时报</a></li>\n<li><a href=\"https://github.com/haizlin/fe-interview\" target=\"_blank\" rel=\"noopener\">前端面试每日三问</a></li>\n<li><a href=\"https://github.com/GitHubDaily/GitHubDaily\" target=\"_blank\" rel=\"noopener\">Github Daily</a></li>\n</ul>\n<h3 id=\"技能图谱-技术清单\"><a href=\"#技能图谱-技术清单\" class=\"headerlink\" title=\"技能图谱/技术清单\"></a>技能图谱/技术清单</h3><ul>\n<li><a href=\"https://roadmap.sh/frontend\" target=\"_blank\" rel=\"noopener\">Frontend Developer</a></li>\n<li><a href=\"https://github.com/adam-golab/react-developer-roadmap\" target=\"_blank\" rel=\"noopener\">React Developer Roadmap</a></li>\n<li><a href=\"https://alienzhou.github.io/frontend-tech-list/\" target=\"_blank\" rel=\"noopener\">前端技术清单</a></li>\n</ul>\n<h3 id=\"面试宝典\"><a href=\"#面试宝典\" class=\"headerlink\" title=\"面试宝典\"></a>面试宝典</h3><ul>\n<li><a href=\"https://lucifer.ren/fe-interview/#/\" target=\"_blank\" rel=\"noopener\">大前端面试宝典 - 图解前端</a></li>\n</ul>\n"},{"title":"FrontEnd Notes [2019.12]","catalog":true,"date":"2019-12-09T15:33:36.000Z","subtitle":null,"header-img":null,"_content":"\n#### About\n\n📅 2019 年 12 月的零散学习记录。\n\n#### 2019/12/26\n今日阅读：[When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)\n起因是刷 reddit 时看到了这篇 [帖子](https://www.reddit.com/r/reactjs/comments/efjgfc/should_i_use_usecallback_in_every_function/)，提问者的问题是 \"Should I use useCallback in every function declared inside a functional component?\"，评论中有人贴出了这个链接，更正了我对性能优化的一些错误认知。\n作者在文章中举了一个例子，在某个函数组件中有这样一个函数：\n```\nconst dispense = candy => {\n  setCandies(allCandies => allCandies.filter(c => c !== candy))\n}\n```\n问题：如果用 `useCallback` 包裹，那么性能会不会更好呢？\n```\nconst dispense = React.useCallback(candy => {\n  setCandies(allCandies => allCandies.filter(c => c !== candy))\n}, [])\n```\n我刚开始的答案是使用 `useCallback` 会更好，毫无疑问是错的。上面的函数也可被写成：\n```\nconst dispense = candy => {\n    setCandies(allCandies => allCandies.filter(c => c !== candy))\n  }\n+ const dispenseCallback = React.useCallback(dispense, [])\n```\ndiff 之后会发现只是多了一行，该有的声明还是有，还需要做更多的工作。现在不仅仅要定义函数，还要定义依赖数组，调用 `useCallback` 进行赋值分配等工作。之前我一直误以为，使用 `useCallback` 后，函数只会在第一次渲染时定义并赋值，第二次渲染不会做额外的操作。其实不是的，这里的相等可以理解为是 “指向的位置” 相等，类似 `ref` 和 `ref.current`，重新渲染时就相当于执行 `ref.current = newVal` 。\n那什么时候需要用到 `useCallback` 呢？官方文档是这样写的：\n> This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).\n\n最简单粗暴的经验，是当你需要将这个函数传递给子组件时，可以使用 `useCallback` 来避免子组件不必要的渲染（子组件使用 `useMemo`）；更准确的说法，是当你需要依赖引用相等性时，就应使用 `useCallback` 。  \n\n#### 2019/12/17\n保留四位有效数字：\n```\nx.toPrecise(4) // return string\n```\n\n#### 2019/12/9\n\n使用原生方法实现文件点击/拖拽上传，并限制只能上传单个 JSON 文件：\n主要思想是监听 `onClick` 和 `onDrop` 事件，注意在 React 中，如果我们需要注册捕获阶段的事件处理函数，则应为事件名添加 `Capture`。例如，使用处理捕获阶段的点击事件 `onClickCapture`，而不是 `onClick`。详情可参考官方文档 [Supported Events](https://reactjs.org/docs/events.html#supported-events) 。\n\n```\n// upload.tsx\n  ...\n  const handleUploadClick = () => {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = \".json,application/json\";\n    input.onchange = ev => {\n      // double-checked\n      if (\n        input.files &&\n        input.files.length === 1 &&\n        input.files[0].type === \"application/json\"\n      ) {\n        // deal with input.files\n      }\n    };\n    input.click();\n  };\n\n  const handleUploadDrop = (ev:       React.DragEvent<HTMLDivElement>) => {\n    if (ev.dataTransfer.files.length > 1) {\n      console.error(\"只允许上传单个文件\");\n    } else if (ev.dataTransfer.files[0].type !== \"application/json\") {\n      console.error(\"只允许上传json文件\");\n    } else {\n      // deal with ev.dataTransfer.files[0]\n    }\n  };\n\n  ...\n\n  render() {\n    return (\n      <div\n        onClickCapture={ev => {\n          ev.preventDefault();\n          ev.stopPropagation();\n          handleUploadClick();\n        }}\n        onDropCapture={ev => {\n          ev.preventDefault();\n          ev.stopPropagation();\n          handleUploadDrop(ev);\n        }}\n      >\n        Click or drag file to this area to upload\n      </div>\n    )\n  }\n\n```\n","source":"_posts/FrontEnd-Notes-2019-12.md","raw":"---\ntitle: \"FrontEnd Notes [2019.12]\"\ncatalog: true\ndate: 2019-12-09 23:33:36\nsubtitle:\nheader-img:\ntags: FE\n---\n\n#### About\n\n📅 2019 年 12 月的零散学习记录。\n\n#### 2019/12/26\n今日阅读：[When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)\n起因是刷 reddit 时看到了这篇 [帖子](https://www.reddit.com/r/reactjs/comments/efjgfc/should_i_use_usecallback_in_every_function/)，提问者的问题是 \"Should I use useCallback in every function declared inside a functional component?\"，评论中有人贴出了这个链接，更正了我对性能优化的一些错误认知。\n作者在文章中举了一个例子，在某个函数组件中有这样一个函数：\n```\nconst dispense = candy => {\n  setCandies(allCandies => allCandies.filter(c => c !== candy))\n}\n```\n问题：如果用 `useCallback` 包裹，那么性能会不会更好呢？\n```\nconst dispense = React.useCallback(candy => {\n  setCandies(allCandies => allCandies.filter(c => c !== candy))\n}, [])\n```\n我刚开始的答案是使用 `useCallback` 会更好，毫无疑问是错的。上面的函数也可被写成：\n```\nconst dispense = candy => {\n    setCandies(allCandies => allCandies.filter(c => c !== candy))\n  }\n+ const dispenseCallback = React.useCallback(dispense, [])\n```\ndiff 之后会发现只是多了一行，该有的声明还是有，还需要做更多的工作。现在不仅仅要定义函数，还要定义依赖数组，调用 `useCallback` 进行赋值分配等工作。之前我一直误以为，使用 `useCallback` 后，函数只会在第一次渲染时定义并赋值，第二次渲染不会做额外的操作。其实不是的，这里的相等可以理解为是 “指向的位置” 相等，类似 `ref` 和 `ref.current`，重新渲染时就相当于执行 `ref.current = newVal` 。\n那什么时候需要用到 `useCallback` 呢？官方文档是这样写的：\n> This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).\n\n最简单粗暴的经验，是当你需要将这个函数传递给子组件时，可以使用 `useCallback` 来避免子组件不必要的渲染（子组件使用 `useMemo`）；更准确的说法，是当你需要依赖引用相等性时，就应使用 `useCallback` 。  \n\n#### 2019/12/17\n保留四位有效数字：\n```\nx.toPrecise(4) // return string\n```\n\n#### 2019/12/9\n\n使用原生方法实现文件点击/拖拽上传，并限制只能上传单个 JSON 文件：\n主要思想是监听 `onClick` 和 `onDrop` 事件，注意在 React 中，如果我们需要注册捕获阶段的事件处理函数，则应为事件名添加 `Capture`。例如，使用处理捕获阶段的点击事件 `onClickCapture`，而不是 `onClick`。详情可参考官方文档 [Supported Events](https://reactjs.org/docs/events.html#supported-events) 。\n\n```\n// upload.tsx\n  ...\n  const handleUploadClick = () => {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = \".json,application/json\";\n    input.onchange = ev => {\n      // double-checked\n      if (\n        input.files &&\n        input.files.length === 1 &&\n        input.files[0].type === \"application/json\"\n      ) {\n        // deal with input.files\n      }\n    };\n    input.click();\n  };\n\n  const handleUploadDrop = (ev:       React.DragEvent<HTMLDivElement>) => {\n    if (ev.dataTransfer.files.length > 1) {\n      console.error(\"只允许上传单个文件\");\n    } else if (ev.dataTransfer.files[0].type !== \"application/json\") {\n      console.error(\"只允许上传json文件\");\n    } else {\n      // deal with ev.dataTransfer.files[0]\n    }\n  };\n\n  ...\n\n  render() {\n    return (\n      <div\n        onClickCapture={ev => {\n          ev.preventDefault();\n          ev.stopPropagation();\n          handleUploadClick();\n        }}\n        onDropCapture={ev => {\n          ev.preventDefault();\n          ev.stopPropagation();\n          handleUploadDrop(ev);\n        }}\n      >\n        Click or drag file to this area to upload\n      </div>\n    )\n  }\n\n```\n","slug":"FrontEnd-Notes-2019-12","published":1,"updated":"2020-01-02T01:57:48.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5393iru0003icuef84ro4rr","content":"<h4 id=\"about\">About</h4>\n<p>📅 2019 年 12 月的零散学习记录。</p>\n<h4 id=\"20191226\">2019/12/26</h4>\n<p>今日阅读：<a href=\"https://kentcdodds.com/blog/usememo-and-usecallback\" target=\"_blank\" rel=\"noopener\">When to useMemo and useCallback</a><br>\n起因是刷 reddit 时看到了这篇 <a href=\"https://www.reddit.com/r/reactjs/comments/efjgfc/should_i_use_usecallback_in_every_function/\" target=\"_blank\" rel=\"noopener\">帖子</a>，提问者的问题是 “Should I use useCallback in every function declared inside a functional component?”，评论中有人贴出了这个链接，更正了我对性能优化的一些错误认知。<br>\n作者在文章中举了一个例子，在某个函数组件中有这样一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = candy =&gt; &#123;</span><br><span class=\"line\">  setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题：如果用 <code>useCallback</code> 包裹，那么性能会不会更好呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = React.useCallback(candy =&gt; &#123;</span><br><span class=\"line\">  setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">&#125;, [])</span><br></pre></td></tr></table></figure>\n<p>我刚开始的答案是使用 <code>useCallback</code> 会更好，毫无疑问是错的。上面的函数也可被写成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = candy =&gt; &#123;</span><br><span class=\"line\">    setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">+ const dispenseCallback = React.useCallback(dispense, [])</span><br></pre></td></tr></table></figure>\n<p>diff 之后会发现只是多了一行，该有的声明还是有，还需要做更多的工作。现在不仅仅要定义函数，还要定义依赖数组，调用 <code>useCallback</code> 进行赋值分配等工作。之前我一直误以为，使用 <code>useCallback</code> 后，函数只会在第一次渲染时定义并赋值，第二次渲染不会做额外的操作。其实不是的，这里的相等可以理解为是 “指向的位置” 相等，类似 <code>ref</code> 和 <code>ref.current</code>，重新渲染时就相当于执行 <code>ref.current = newVal</code> 。<br>\n那什么时候需要用到 <code>useCallback</code> 呢？官方文档是这样写的：</p>\n<blockquote>\n<p>This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).</p>\n</blockquote>\n<p>最简单粗暴的经验，是当你需要将这个函数传递给子组件时，可以使用 <code>useCallback</code> 来避免子组件不必要的渲染（子组件使用 <code>useMemo</code>）；更准确的说法，是当你需要依赖引用相等性时，就应使用 <code>useCallback</code> 。</p>\n<h4 id=\"20191217\">2019/12/17</h4>\n<p>保留四位有效数字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x.toPrecise(4) // return string</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019129\">2019/12/9</h4>\n<p>使用原生方法实现文件点击/拖拽上传，并限制只能上传单个 JSON 文件：<br>\n主要思想是监听 <code>onClick</code> 和 <code>onDrop</code> 事件，注意在 React 中，如果我们需要注册捕获阶段的事件处理函数，则应为事件名添加 <code>Capture</code>。例如，使用处理捕获阶段的点击事件 <code>onClickCapture</code>，而不是 <code>onClick</code>。详情可参考官方文档 <a href=\"https://reactjs.org/docs/events.html#supported-events\" target=\"_blank\" rel=\"noopener\">Supported Events</a> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// upload.tsx</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  const handleUploadClick = () =&gt; &#123;</span><br><span class=\"line\">    const input = document.createElement(&quot;input&quot;);</span><br><span class=\"line\">    input.type = &quot;file&quot;;</span><br><span class=\"line\">    input.accept = &quot;.json,application/json&quot;;</span><br><span class=\"line\">    input.onchange = ev =&gt; &#123;</span><br><span class=\"line\">      // double-checked</span><br><span class=\"line\">      if (</span><br><span class=\"line\">        input.files &amp;&amp;</span><br><span class=\"line\">        input.files.length === 1 &amp;&amp;</span><br><span class=\"line\">        input.files[0].type === &quot;application/json&quot;</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        // deal with input.files</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    input.click();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleUploadDrop = (ev:       React.DragEvent&lt;HTMLDivElement&gt;) =&gt; &#123;</span><br><span class=\"line\">    if (ev.dataTransfer.files.length &gt; 1) &#123;</span><br><span class=\"line\">      console.error(&quot;只允许上传单个文件&quot;);</span><br><span class=\"line\">    &#125; else if (ev.dataTransfer.files[0].type !== &quot;application/json&quot;) &#123;</span><br><span class=\"line\">      console.error(&quot;只允许上传json文件&quot;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // deal with ev.dataTransfer.files[0]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div</span><br><span class=\"line\">        onClickCapture=&#123;ev =&gt; &#123;</span><br><span class=\"line\">          ev.preventDefault();</span><br><span class=\"line\">          ev.stopPropagation();</span><br><span class=\"line\">          handleUploadClick();</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">        onDropCapture=&#123;ev =&gt; &#123;</span><br><span class=\"line\">          ev.preventDefault();</span><br><span class=\"line\">          ev.stopPropagation();</span><br><span class=\"line\">          handleUploadDrop(ev);</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        Click or drag file to this area to upload</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4>About</h4>\n<p>📅 2019 年 12 月的零散学习记录。</p>\n<h4>2019/12/26</h4>\n<p>今日阅读：<a href=\"https://kentcdodds.com/blog/usememo-and-usecallback\" target=\"_blank\" rel=\"noopener\">When to useMemo and useCallback</a><br>\n起因是刷 reddit 时看到了这篇 <a href=\"https://www.reddit.com/r/reactjs/comments/efjgfc/should_i_use_usecallback_in_every_function/\" target=\"_blank\" rel=\"noopener\">帖子</a>，提问者的问题是 “Should I use useCallback in every function declared inside a functional component?”，评论中有人贴出了这个链接，更正了我对性能优化的一些错误认知。<br>\n作者在文章中举了一个例子，在某个函数组件中有这样一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = candy =&gt; &#123;</span><br><span class=\"line\">  setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>问题：如果用 <code>useCallback</code> 包裹，那么性能会不会更好呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = React.useCallback(candy =&gt; &#123;</span><br><span class=\"line\">  setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">&#125;, [])</span><br></pre></td></tr></table></figure>\n<p>我刚开始的答案是使用 <code>useCallback</code> 会更好，毫无疑问是错的。上面的函数也可被写成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const dispense = candy =&gt; &#123;</span><br><span class=\"line\">    setCandies(allCandies =&gt; allCandies.filter(c =&gt; c !== candy))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">+ const dispenseCallback = React.useCallback(dispense, [])</span><br></pre></td></tr></table></figure>\n<p>diff 之后会发现只是多了一行，该有的声明还是有，还需要做更多的工作。现在不仅仅要定义函数，还要定义依赖数组，调用 <code>useCallback</code> 进行赋值分配等工作。之前我一直误以为，使用 <code>useCallback</code> 后，函数只会在第一次渲染时定义并赋值，第二次渲染不会做额外的操作。其实不是的，这里的相等可以理解为是 “指向的位置” 相等，类似 <code>ref</code> 和 <code>ref.current</code>，重新渲染时就相当于执行 <code>ref.current = newVal</code> 。<br>\n那什么时候需要用到 <code>useCallback</code> 呢？官方文档是这样写的：</p>\n<blockquote>\n<p>This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).</p>\n</blockquote>\n<p>最简单粗暴的经验，是当你需要将这个函数传递给子组件时，可以使用 <code>useCallback</code> 来避免子组件不必要的渲染（子组件使用 <code>useMemo</code>）；更准确的说法，是当你需要依赖引用相等性时，就应使用 <code>useCallback</code> 。</p>\n<h4>2019/12/17</h4>\n<p>保留四位有效数字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x.toPrecise(4) // return string</span><br></pre></td></tr></table></figure>\n<h4>2019/12/9</h4>\n<p>使用原生方法实现文件点击/拖拽上传，并限制只能上传单个 JSON 文件：<br>\n主要思想是监听 <code>onClick</code> 和 <code>onDrop</code> 事件，注意在 React 中，如果我们需要注册捕获阶段的事件处理函数，则应为事件名添加 <code>Capture</code>。例如，使用处理捕获阶段的点击事件 <code>onClickCapture</code>，而不是 <code>onClick</code>。详情可参考官方文档 <a href=\"https://reactjs.org/docs/events.html#supported-events\" target=\"_blank\" rel=\"noopener\">Supported Events</a> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// upload.tsx</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  const handleUploadClick = () =&gt; &#123;</span><br><span class=\"line\">    const input = document.createElement(&quot;input&quot;);</span><br><span class=\"line\">    input.type = &quot;file&quot;;</span><br><span class=\"line\">    input.accept = &quot;.json,application/json&quot;;</span><br><span class=\"line\">    input.onchange = ev =&gt; &#123;</span><br><span class=\"line\">      // double-checked</span><br><span class=\"line\">      if (</span><br><span class=\"line\">        input.files &amp;&amp;</span><br><span class=\"line\">        input.files.length === 1 &amp;&amp;</span><br><span class=\"line\">        input.files[0].type === &quot;application/json&quot;</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        // deal with input.files</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    input.click();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleUploadDrop = (ev:       React.DragEvent&lt;HTMLDivElement&gt;) =&gt; &#123;</span><br><span class=\"line\">    if (ev.dataTransfer.files.length &gt; 1) &#123;</span><br><span class=\"line\">      console.error(&quot;只允许上传单个文件&quot;);</span><br><span class=\"line\">    &#125; else if (ev.dataTransfer.files[0].type !== &quot;application/json&quot;) &#123;</span><br><span class=\"line\">      console.error(&quot;只允许上传json文件&quot;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // deal with ev.dataTransfer.files[0]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div</span><br><span class=\"line\">        onClickCapture=&#123;ev =&gt; &#123;</span><br><span class=\"line\">          ev.preventDefault();</span><br><span class=\"line\">          ev.stopPropagation();</span><br><span class=\"line\">          handleUploadClick();</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">        onDropCapture=&#123;ev =&gt; &#123;</span><br><span class=\"line\">          ev.preventDefault();</span><br><span class=\"line\">          ev.stopPropagation();</span><br><span class=\"line\">          handleUploadDrop(ev);</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        Click or drag file to this area to upload</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"FrontEnd Daily Learning","catalog":true,"date":"2019-07-11T11:44:53.000Z","subtitle":null,"header-img":null,"_content":"#### 前言\n📝 recap and cheat sheet ，记录每天学到的知识/想法。\n🔊 每日一问：今天你比昨天更博学了吗？\n\n\n#### 2019/8/25\n今日踩坑记录：\n展开语法（spread syntax）只能取到 enumerable properties。例如：\n```\nconst imageData = new ImageData(200, 100);\n// ImageData { width: 200, height: 100, data: Uint8ClampedArray[80000] }\nconst result = {...imageData}\n// result 只会包含 data ，不能取到 width 和 height\n```\n\n\n#### 2019/8/24\n避免组件重新挂载，可以使用事件的形式：\n```\nclass BussinessProvider {\n  sp$ = new Subject<{url: string, slic: string}>();\n}\n\nclass Canvas {\n  componentDidMount() {\n     this.props.sp$.pipe(takeUntil(this.unmount$)).subscribe(ev => {\n        if (ev.url === this.url) {\n           this.handleSuperPixelChange(ev.slic)\n        }\n     })\n  }\n}\n```\n\n\n#### 2019/8/24\n一、Promise\n```\nnew Promise((resolve,reject) => {\n  // do something...\n})\n\npromise.then(onFulfilled[, onRejected]);\npromise.then(value => {\n  // fulfillment\n}, reason => {\n  // rejection\n});\n\npromise.catch(onRejected);\npromise.catch(function(reason) {\n   // rejection\n});\n```\n简单来说，`reject(value)` 可以被 `promise.then` 第二个函数参数捕获，也可以被 `promise.catch` 捕获。如果两者同时存在，会被 `promise.then` 第二个函数参数捕获，`promise.catch` 无输出。\n\n下载图片的典型例子：\n```\nfunction loadImage(url) {\n  return new Promise((resolve, reject) => {\n    let img = new Image();\n    // img.onload = () => resolve(img)\n    img.addEventListener('load', e => resolve(img));\n    // img.onerror = () => reject(XXX)\n    img.addEventListener('error', () => {\n      reject(new Error(`Failed to load image's URL: ${url}`));\n    });\n    img.src = url;\n  });\n}\n\nloadImage('http://thecatapi.com/api/images/get?format=src&type=jpg&size=small')\n  .then(img => document.getElementById('image-holder').appendChild(img))\n  .catch(error => console.error(error));\n```\n\n二、await\n`[rv] = await expression`:\n>TL;DR returns the fulfilled value of the promise, \nThe await expression causes async function execution to pause until a Promise is settled, that is fulfilled or rejected, and to resume execution of the async function after fulfillment. When resumed, the value of the await expression is that of the fulfilled Promise.\nIf the Promise is rejected, the await expression throws the rejected value.\nIf the value of the expression following the await operator is not a Promise, it's converted to a resolved Promise.\n\n\n#### 2019/8/23\n`String.prototype.localeCompare()`\n> return a number, indicating whether the reference string comes before, after or is the same as the compareString in sort order. Returns one of three values:\n-1: if the reference string is sorted before the compareString\n 0: if the two strings are equal\n 1: if the reference string is sorted after the compareString\n\n`Array.prototype.sort()`\n>  sorts the elements of an array in place and returns the sorted array. \n\n```\nitems.sort((a,b) => a.localeCompare(b))\n```\n\n\n#### 2019/8/21\n今日阅读：\n[What is the difference between “npm install” and “npm ci”?](https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci)\n[Everything You Wanted To Know About package-lock.json But Were Too Afraid To Ask](https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8)\n\n\n#### 2019/8/20\n模仿 react hook `useState` 的第二个参数：\n&emsp;&emsp;因为在 jest 测试中某个函数的参数是 `useState` 的第二个参数，写了一个替代，不过不确定是否有错。😳\n```\n// for example\nconst [str,setStr] = useState<string[]>([]);\n\n// fake setStr\nlet str:string[] = [];\nconst setStr = (val: string[] | ((prev:string[]) => string[])) => {\n  if (typeof val === \"object\") {\n    str = val;\n  } else if (typeof val === \"function\") {\n    str = val(str)\n  }\n}\n```\n\n#### 2019/8/19\n今日阅读：[What is rel=noopener noreferrer link](https://searchenginelaws.com/seo/what-is-rel-noopener-noreferrer-tag/)\n&emsp;&emsp;使用 `a` 标签，且属性 `target=\"_blank\"` 时，需要加上 `rel=\"noopener noreferrer\"` 。可以防止新窗口利用 `window.opener` 的特性窃取原窗口信息。具体而言，如果 window A 打开了 window B，那么 B.opener 会返回 A。如果加上 `rel=\"noopener\"` ，会返回 null 。\n\n\n#### 2019/8/12\n一、download files using axios\n```\nimport axios from \"axios\"\n\naxios.get(url,{\n  responseType: 'blob', // important\n  headers: {\n    'Authorization': AuthStr \n  }\n}).then(resp => {\n  const {data} = resp;\n  const file = new File([data],\"data.txt\");\n  const objectURL = URL.createObjectURL(file);\n  const a = document.createElement(\"a\");\n  a.href = objectURL;\n  a.download = \"data.txt\";\n  a.click();\n  URL.revokeObjectURL(objectURL);\n})\n```\n&emsp;&emsp;如果是单次点击下载多个文件，Chrome 只会弹出一个弹窗下载最后一个文件。这个时候可以加上 `setTimeout` ，触发多次下载，或是加上 `a.target = \"_blank\"` ，打开多个新窗口。\n二、curl\n查看命令：\n`curl --help`\n-H 指定Header：\n`curl -H \"Authorization: XXXXXXXX\" URL`\n`curl POST -d data -H \"Authorization: XXXXXXXX\" URL`\n\n\n#### 2019/8/9\n一、[useRef vs useState: Should we re-render or not?](https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/)\n![FE_20190808](FE_20190809.png)\n二、Hooks 监听键盘事件\nkeyCode: https://keycode.info/\n```\nfunction useKeyPress(targetKey) {\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  function downHandler({ key }) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  }\n\n  const upHandler = ({ key }) => {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  };\n\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, []);\n\n  return keyPressed;\n}\n```\n\n\n#### 2019/8/8\n&emsp;&emsp;工程中经常会看到 CI/CD 的概念。CI 指的是持续集成，侧重于简化发布准备工作的实践，比如自动测试；CD 指的是持续交付，意味着不仅让测试自动化，让发布流程也自动化了。更多概念对比可以参考：[Continuous integration VS continuous delivery VS continuous deployment](https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment)\n&emsp;&emsp;下面这个图很清晰地描述了三者的不同：\n![FE_20190808](FE_20190808.png)\n&emsp;&emsp;在 gitlab 上的实践可以参考：[基于 GitLab CI/CD 的自动化构建、发布实践](https://mp.weixin.qq.com/s/z2f1i2FgrVGofQR6nKTd1A)\n\n#### 2019/8/7\nTypescript: [Discriminated Unions](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions) \n&emsp;&emsp;当我们某个参数可能有多个类型，而这些类型中又有公共的属性时，就可以使用这种形式约束。\n```\n// Each interface has a kind property with a different string literal type. \n// The kind property is called the discriminant or tag. \ninterface Square {\n    kind: \"square\";\n    size: number;\n}\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\n// put the interfaces into a union\ntype Shape = Square | Rectangle | Circle;\n\n// use the discriminated union\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n        default: return assertNever(s); // error here if there are missing cases\n    }\n}\n\n// Exhaustiveness checking \nfunction assertNever(x: never): never {\n    throw new Error(\"Unexpected object: \" + x);\n}\n```\n\n\n#### 2019/8/6\nStack Overflow: [useState set method not reflecting change immediately.](https://stackoverflow.com/questions/54069253/usestate-set-method-not-reflecting-change-immediately)\n&emsp;&emsp;今天在实践中发现，`setState` 后马上打印，并不会取到更新后的值。查阅资料后发现这个函数是一个异步的函数，不会立即更新，但会触发重新渲染。如下：\n![FE_20190806](FE_20190806.png)\n\n\n#### 2019/8/1\n一、[Fetch API](https://javascript.info/fetch-api)\n&emsp;&emsp;用 fetch 来请求网络资源，可以配置不同的参数来解决缓存、跨域等问题，如下示例代码：\n```\n// 不缓存请求结果 \n// https://stackoverflow.com/questions/29246444/fetch-how-do-you-make-a-non-cached-request\nconst headers = new Headers();\nheaders.append(\"pragma\", \"no-cache\");\nheaders.append(\"cache-control\", \"no-store\");\n\n// 完全忽略 http-cache ，每次都从服务器请求数据\n// https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\nconst cache: RequestCache = \"no-store\";\n\n// 请求模式，若有的请求会因为 cors 而失败，可以设置为 \"no-cors\"\n// https://developer.mozilla.org/en-US/docs/Web/API/Request/mode\nconst mode: RequestMode = needCors ? \"cors\" : \"no-cors\";\n\nawait fetch(url. {headers, cache, mode})\n  .then(res => res.blob())\n  .then(blob => {\n    // doSomething with blob\n    const url = URL.createObjectURL(blob)\n    let a = document.createElement('a')\n    a.download = 'example.zip'\n    a.href = url\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n  })\n  .catch(err => {\n    console.log(err)\n  })\n  .finally(() => {\n    // doSomething\n  })\n```\n&emsp;&emsp;关于 `res.blob()` ，可以参考知乎上[谈一谈 Fetch API 中的 “res.blob()”](https://zhuanlan.zhihu.com/p/32909043)；也可以参考 [fetch documentation](https://github.github.io/fetch/) ，这一篇比较详细，也提供了较多其他的例子。\n关于浏览器缓存问题，Medium 上这篇 [A Web Developer’s Guide to Browser Caching](https://medium.com/@codebyamir/a-web-developers-guide-to-browser-caching-cc41f3b73e7c) 写得不错。如果存在代理服务器，即使我们设置了 `mode: 'no-store'` ，代理服务器也会缓存。为了避免这个情况，我们可以在每次发送请求时构造新的 URL ，加上时间戳 `?t=Date.now()` 。🐮🍺\n二、Jest\n&emsp;&emsp;我们在使用 jest 测试时，有时候需要引入一些外部文件/外部变量，如从 `config.json` 文件中引入某个变量。为了在测试文件中可以访问到该变量，我们可以在 `jest.config.js` 中配置全局变量：\n```\nmodule.exports = {\n  globals: {\n    API_BASE: \"\",\n    DATA_API: \"\",\n    TRACK_API: \"\"\n  },\n  setupFiles: [\"./jestSetup.ts\"]\n}\n```\n&emsp;&emsp;由于 `globals` 只支持 JSON 格式的变量，如果我们需要定义全局函数，则可以使用 `setupFiles`。\n```\n// jestSetup.ts\n(global as any).fn= () => {};\n(global as any).variable = \"XXX\";\n```\n\n\n#### 2019/7/31\n1）`position: fixed` 和 flex 布局是不能同时起作用的。绝对布局脱离文档流，不会参与到 flex layout 中。如果想实现左侧菜单栏，右侧内容，两者不同时滚动（菜单栏 fixed），但菜单栏的大小可以改变（flex 父布局）。可以让父容器是 flex 布局，左侧菜单栏和右侧内容区域都是 flex element ， 菜单栏内部再有一个 `position: fixed` 的 div 。\n2）如果想让 `position: fixed` 的元素相对父容器定位，可以给父容器增加 CSS 属性 `transform: translate(0,0)` 。参考：[MDN - position](https://developer.mozilla.org/en-US/docs/Web/CSS/position)\n> fixed: It is positioned relative to the initial containing block established by the viewport, except when one of its ancestors has a transform, perspective, or filter property set to something other than none. \n\n\n#### 2019/7/30\n`useEffect` 中的异步请求：\n```\n// 错误写法， return 必须是 cleanup function\nuseEffect(async () => {\n  const newVal = await asyncCall();\n  setVal(newVal);\n});\n\n// 正确写法\nuseEffect(() => {\n  asyncCall().then(resp => setVal(resp.data));\n});\n```\n好文共享：[How to fetch data with React Hooks?](https://www.robinwieruch.de/react-hooks-fetch-data/)，代码如下：\n```\nuseEffect(() => {\n  async function fetchMyAPI() {\n    let url = 'http://something/' + productId;\n    let config = {};\n    const response = await myFetch(url);\n    console.log(response);\n  }  \n\n  fetchMyAPI();\n}, [productId]);\n```\n如果要保证请求按顺序发出，可以采用如下写法：\n```\nuseEffect(() => {\n  let didCancel = false;\n\n  async function fetchMyAPI() {\n    let url = 'http://something/' + productId;\n    let config = {};\n    const response = await myFetch(url);\n    if (!didCancel) { // Ignore if we started fetching something else\n      console.log(response);\n    } \n  }  \n\n  fetchMyAPI();\n  return () => { didCancel = true; }; // Remember if we start fetching something else\n}, [productId]);\n```\n\n\n#### 2019/7/29\n一、[performance.now() vs Date.now()](https://stackoverflow.com/questions/30795525/performance-now-vs-date-now)\n&emsp;&emsp;在程序中打印执行时间时，使用 `performance.now(）` 更准确。\n```\nconst start = performance.now();\ndoSomething();\nconst end = performance.now();\nconsole.log(\"Call to doSomething took \" + (start - end) + \" milliseconds.\");\n```\n二、[Does javascript slice method return a shallow copy?](https://stackoverflow.com/questions/47738344/does-javascript-slice-method-return-a-shallow-copy)\n&emsp;&emsp;mdn 上对 `slice()` 方法的介绍：\n>The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included) where begin and end represent the index of items in that array. The original array will not be modified.\n\n&emsp;&emsp;注意这里的浅复制指的是对数组中值的浅复制，而不是对整个数组的浅复制。如果是一个字符串数组，则修改新数组时，原数组不会改变；如果是对象数组，修改新数组对象值时，原数组也会发生变化。\n```\nconst animals = [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}];\nconst newAnimals = animals.slice(2);\n\nnewAnimals[0].name = 'aaa';\nconsole.log(newAnimals); // [{name: 'aaa'}]\nconsole.log(animals);    // [{name: 'ant'}, {name: 'bison'}, {name: 'aaa'}]\n```\n&emsp;&emsp;注意如果是重新赋值，则等于重新分配空间，不会改变原数组。\n```\nconst animals = [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}];\nconst newAnimals = animals.slice(2);\n\nnewAnimals[0] = {name: 'aaa'};\nconsole.log(newAnimals); // [{name: 'aaa'}]\nconsole.log(animals);    // [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}]\n```\n\n#### 2019/7/26\n&emsp;&emsp;应用场景：我们需要请求并更新菜单栏中任务的状态，如果一个请求完成立马更新会导致 React 频繁刷新，需要缓冲批处理：\n```\nimport { runInAction } from \"mobx\";\n\nlet handlers: Array<() => void> = [];\nconst runHandlers = () => {\n  runInAction(() => {\n    handlers.forEach(f => f());\n    handlers = [];\n  });\n};\n\nfor (const task of tasks) {\n  const {data} = await requestFn();\n  \n  handlers.push(() => {\n    // deal with data, update state\n    ...\n  });\n\n  if(handlers.length > 30) {\n    runHandlers();\n  }\n}\n\nrunHandlers();\n```\n&emsp;&emsp;上述代码主要是利用了自定义的 `handlers` 来暂存状态更新函数，之后使用 mobx 提供的 `runInAction` 执行函数并更新状态，更新状态都需要使用 `action` 函数， `runInAction` 接受一个代码块并在一个(匿名)操作中执行，有利于动态创建和执行操作，`runInAction(f) = action(f)()`。此外，必要时还可加上 `lodash.memoize(func,[resolver])`，记录主函数请求结果。\n> For one-time-actions runInAction(name?, fn) can be used, which is sugar for action(name, fn)()\n\n\n#### 2019/7/18 \n一、编程模式：\n&emsp;&emsp; 首先先记住这几种编程模式的中文：Imperative Programming 是命令式编程，Declarative Programming 是声明式编程，Reactive Programming 是响应式编程。（流下了英文不好的泪水）\n1）先看命令式编程和声明式编程的区别，直接上代码：\n```\n// 命令式编程 imperative programming\nconst array = [0,1,2,3,4,5];\nconst output = [];\nfor (let i = 0; i < array.length; i++) {\n  const tmp = array[i] * 2;\n  output.push(tmp)\n};\nconsole.log(output) // => [0,2,4,6,8,10]\n```\n```\n// 声明式编程 declarative programming\nconst array = [0,1,2,3,4,5];\nconst output = array.map(item => item * 2);\nconsole.log(output) // => [0,2,3,6,8,10]\n```\n&emsp;&emsp;很明显可以看到，命令式编程的关注点在于 how ，我们需要一步步告诉机器接下来要做什么，告诉他怎么去遍历一个数组，怎么去运算得到最后的结果，怎么去输出；声明式编程的关注点在于 what ，我们只关注最后的结果，由机器自己去摸索过程，如直接调用 `map` 函数，只告诉程序我们需要一个2倍输出。\n2）接着看声明式编程和响应式编程的对比\n&emsp;&emsp;可以阅读：[Imperative vs Reactive](https://codepen.io/HunorMarton/post/imperative-vs-reactive)，解释很清晰，比喻也很形象，但我觉得文章里的 Imperative 应该改成 Declarative 比较准确。继续沿用上面的例子，修改一下声明式编程的例子：\n```\n// 声明式编程 declarative programming\nconst array = [1,2];\nconst output = array.map(item => item * 2);\noutput.forEach(item => console.log(item)) // => 2 4\narray.push(3);  // => no output \narray.push(4);  // => no output\n```\n响应式编程的例子：\n```\nimport { Subject } from `rxjs`;\nlet array = new Subject();\narray.next(1);\narray.next(2);\n\nconst output = array.map(item => item * 2);\noutput.forEach(item => console.log(item)); // => 2 4\n\narray.next(3); // => 6\narray.next(4); // => 8\n```\n&emsp;&emsp;首先要注意的是，这两种方式中的 `map` ， `forEach` 等函数并不是一样的，内部实现机制是不同的。我们可以发现区别：在声明式编程中，如果在最后向原数组添加值，并不会打印出来，因为这是在 `console.log` 语句执行后发生的。但在响应式编程里，任何变化都可以被反应出来，它引入了一个**异步数据流**（asynchronous data streams）的概念，可以随时创建、更改或组合这些数据流，所以打印事件是一个 continuous observation case。\n二、类库\n[react-virtualized](https://github.com/bvaughn/react-virtualized) 的轻量级版 [react-window](https://github.com/bvaughn/react-window)，用于高效渲染长列表。\n\n\n#### 2019/7/17 \n&emsp;&emsp;如果我们在项目中需要请求很多图片，想要实现请求出错时继续发送请求，成功时返回数据，可以使用 `Promise` ：\n```\nfunction fetchURL(url: string):Promise<Blob> {\n  return Axios.get(url, {responeType: \"blob\"})\n              .then( resp => Promise.resolve(resp.data) )\n              .catch( () => fetchURL(url) )\n}\n```\n之后可以使用 `rxjs` ：\n```\nimport { mergeMap, bufferTime, takeUntil } from \"rxjs/operators\";\n\n[url1,...,url10]\n  .pipe(\n    mergeMap( url => fetchURL(url).then( val => val )),\n    bufferTime(10000)\n  )\n  .subscribe({\n    next: resps => {\n      // do sth with resps:Blob[]\n    }\n  })\n```\n&emsp;&emsp;每次遇到 `rxjs` 都很头大，现在也没有发现一个比较完善清晰的教程，但它又真的很强大，后续要开专题好好学习记录这个东西。\n\n\n#### 2019/7/16\n一、今日阅读：[How to read an often-changing value from useCallback?](https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback)\n直接上官网代码：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  const textRef = useRef();\n\n  useEffect(() => {\n    textRef.current = text; // Write it to the ref\n  });\n\n  const handleSubmit = useCallback(() => {\n    const currentText = textRef.current; // Read it from the ref\n    alert(currentText);\n  }, [textRef]); // Don't recreate handleSubmit like [text] would do\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n&emsp;&emsp; 也就是说，当 `text` 的值经常发生变化时，即使 `handleSubmit` 用 `useCallback` 包裹了，还是会重新声明。解决办法是传入一个 `ref` 对象代替原始值。也可以写一个 custom hook ：\n1）官网的版本：\n```\nfunction useEventCallback(fn, dependencies) {\n  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n```\n实际使用：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  // Will be memoized even if `text` changes:\n  const handleSubmit = useEventCallback(() => {\n    alert(text);\n  }, [text]);\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n2）导师的版本：（他来了，他带着代码又来了）\n```\n/**\n * @param callback\n * @param oRefs\n */\nexport function useCallbackWithRefs<\n  Refs,\n  Callback extends (...args: any[]) => void\n>(callback: (refs: Refs) => Callback, oRefs: Refs) {\n  const refs = useRef(oRefs);\n  useEffect(\n    () => {\n      refs.current = oRefs;\n    },\n    [oRefs]\n  );\n\n  return useCallback(\n    (...args: any[]) => callback(refs.current)(...args),\n    []\n  ) as Callback;\n}\n```\n实际使用：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  \n  // 原先的 callback 也可以有参数\n  const handleSubmit = useCallbackWithRefs(\n    refs => (params: any) => {\n      // 要注意在函数内必须使用 `refs.xxx`，不能直接使用函数外部的任何变量 `xxx`\n      console.log(refs.text);\n  }, {text});\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n&emsp;&emsp;总的来说，官网的实现是将 `callback` 作为 `ref` 对象，并作为 `useCallback` 的依赖，不会频繁改变；如果在函数 `handleSubmit` 中要访问外部变量 `text` ，直接使用 `test` 即可。第二种实现方式是把经常变化的值作为 `ref` 对象，返回值 `useCallback` 第一个参数是 `refs => callback` ，依赖是空数组；这时如果要在函数 `handleSubmit` 中要访问外部变量 `text` ，必须使用 `refs.test` ，否则访问的只是 `test` 的初始值。\n&emsp;&emsp;React 博大精深，接下来要好好研读一下这个 [FAQ](https://reactjs.org/docs/hooks-faq.html)。\n二、今日网址\n&emsp;&emsp;一个 [emoji copy](https://www.emojicopy.com/) 网站，我们 👧 就是喜欢这些花里胡哨的东西。\n\n\n#### 2019/7/15\n&emsp;&emsp;今天在项目中使用 React Hooks 又踩坑了，看来自己对这部分还是没有理解透彻。在使用 `useCallback` 和 `useEffect` 时，要注意第二个参数，也就是传入的 `[deps]`。如果使用 `useCallback(fn,[deps])` ， `[deps]` 应该包含函数 `fn` 所涉及的所有变量；如果使用 `useEffect(fn,[deps])` ， 当 `deps` 的值变化时，就会执行 `fn`，因此`[deps]` 不一定要包含函数 `fn` 所涉及的所有变量，而是应该传入会引起该函数执行的那些参数。\n&emsp;&emsp;今日踩坑记录：为了优化子组件，作为 `props` 的函数都使用 `useCallback` 包裹了，并传入了空数组作为第二个参数，表示没有依赖。但是函数中的运算需要用到组件中一个变量，如果没有将该变量作为 `deps` ，这个变量就会一直保持初始值，值并不会改变，运行结果就会与预期不符。（真的太蠢了，缓缓躺倒）\n\n\n#### 2019/7/14\n周末当然是约会啦。😍\n\n\n#### 2019/7/13\n一、今日阅读：[How to compare oldValues and newValues on React Hooks useEffect?](https://stackoverflow.com/questions/53446020/how-to-compare-oldvalues-and-newvalues-on-react-hooks-useeffect)\n&emsp;&emsp; React class 组件提供了 `ComponentDidUpdate` 之类的方法来获取到当前 `props` 和前一个 `props` ，并进行比较，决定是否进行更新。函数式组件只有 `useEffect` 函数来模仿生命周期函数，当我们需要获取组件先前的 `props` 时，可以使用下面的 custom hook ：\n```\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n```\n&emsp;&emsp;之后在 `useEffect` 中使用上面的函数来模拟 `ComponentDidUpdate` ：\n```\nconst Component = (props) => {\n    const {receiveAmount, sendAmount } = props\n    const prevAmount = usePrevious({receiveAmount, sendAmount});\n    useEffect(() => {\n        if(prevAmount.receiveAmount !== receiveAmount) {\n\n         // process here\n        }\n        if(prevAmount.sendAmount !== sendAmount) {\n\n         // process here\n        }\n    }, [receiveAmount, sendAmount])\n}\n```\n&emsp;&emsp;有时候在 debug 时，我们想知道组件为什么会重新渲染，是那些 `props` 更新了，也可以使用上面的方法来获取 `prevProps`，并在函数组件最开始时写一个 `useEffect` 将参数都打印出来，使用 `===` 比较。 \n\n\n\n#### 2019/7/12\n一、今日技能\n&emsp;&emsp;项目中经常会涉及到 JSON 字符串的解析，解析出错就扑街了，一般是用 `try {...} catch {...}` 包裹。今天导师在 code review 时建议我使用如下函数，该函数也可以覆盖空字符串的检测：\n```\nfunction safeJsonParse<T>(str): { ok: true, value: T } | { ok: false } {\n  try {\n    return {\n      ok: true,\n      value: JSON.parse(str)\n    }\n  } catch {\n    return {\n      ok: false\n    }\n  }\n}\n```\n二、今日阅读：[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://imweb.io/topic/5b72d4ef15554e6d3409f817)。\n&emsp;&emsp;这一篇很好地梳理了进程、线程、浏览器**多进程**、浏览器内核**多线程**、JS单线程、JS运行机制的相关知识，很连贯，建议时不时回顾。简单记录几个知识点：\n1）进程是CPU资源分配的最小单位，线程是CPU调度的最小单位。（想当年考操作系统的时候还背得滚瓜烂熟）\n2）**浏览器是多进程的**，包括的主要进程有：\n- Browser进程（浏览器的主进程，只有一个）\n- 浏览器渲染进程（浏览器内核，Renderer进程，渲染进程，内部是多线程的）：默认每个Tab一个进程\n- 第三方插件进程\n- GPU进程：3D绘制\n\n3）重点是浏览器内核，它是多线程的，主要常驻线程有：\n- GUI渲染线程：渲染页面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制，repaint 和 reflow 等。\n- JS引擎线程：处理任务队列中的任务，与 GUI 渲染线程是互斥的。\n- 事件触发线程：控制事件循环，把事件添加到任务队列的末尾。\n- 定时触发线程：`setTimeout` 和 `setInterval`，同样也是计时完毕后添加到队列末尾。\n- 异步 http 请求线程\n\n4）Browser进程和浏览器内核之间是需要通信的\n5）时间循环机制 `Event Loop` ：JS分为同步任务和异步任务，同步任务都会在主线程上运行，形成一个执行栈；主线程之外，由事件触发线程管理一个**任务队列/事件队列**，异步任务的运行结果会被添加到任务队列中。一旦执行栈中所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到执行栈中开始执行。 \n6）进阶：macrotask / task 和 microtask/ job。ES6中的 `Promise` 就属于 microtask 微任务 ，而主代码块，事件队列中的时间如 `setTimeout` 和 `setInterval` 就属于 macrotask 宏任务。总结的运行机制就是：\n- 执行宏任务。（从执行栈中获取，如果没有就从事件队列中获取）\n- 执行过程中如果遇到微任务，就添加到微任务队列 Job Queues 中。（作者猜测这个队列由JS引擎线程维护，因为是在主线程下无缝执行的）\n- 宏任务执行完毕后，立即依次执行当前微任务队列中所有微任务。\n- 检查渲染，由 GUI 线程接管。\n- 渲染完毕后，由 JS 引擎线程接管，从时间队列中获取并执行下一个宏任务。\n\n7）在第六点中提到的是一个进阶的概念，对应一道题目，如果代码中依次有 `setTimeout` 和 `Promise` ，是会先打印出 `Promise` 的执行结果的。\n\n\n#### 2019/7/11\n&emsp;&emsp; React 16.8 提出了 `hook` 的概念，函数式组件也可以拥有自己的状态。现在的工作项目已经摒弃了 `class` ，改用函数式组件，正在慢慢摸索中。今天在腾讯[IMWeb前端博客](http://imweb.io/)中看到了两篇介绍 `React hook` 的文章，受益匪浅，简单记录一下。\n 一、[react hook——你可能不是“我”所认识的useEffect](https://imweb.io/topic/5cd845cadcd62f86299fcd76)\n&emsp;&emsp;这篇介绍了 `useEffect` 这个API，用它模拟了class组件的生命周期函数。`useEffect` 用于执行副作用，相当于 `ComponentDidMount` 和 `ComponentDidUpdate`。该API有两个参数和一个返回值。第一个参数是一个副作用函数，返回值是清除函数，相当于 `ComponentWillUnmount`，每一次 `render` 都会执行副作用和清除上一次副作用。**第二个参数是一个数组，传入的是副作用函数所需要的依赖，当任一依赖更新时，会重新生成一个新的副作用并执行；如果传入一个空数组，没有依赖，只会执行一次，相当于 `ComponentDidMount`；如果不传，就是没有说明自己有没有依赖（注意是不知道有没有，不是没有！），每次 `render` 时就执行，相当于 `ComponentDidUpdate` 。**\n&emsp;&emsp; 最后还讲了 `useEffect` 和 `useLayoutEffect` 的区别，简单来说前者是异步的，后者是同步的。还没好好深入这部分，TODO。\n二、[可能你的react函数组件从来没有优化过](https://imweb.io/topic/5d1e3657f7b5692b080f2651)\n&emsp;&emsp;优化问题真是我一个痛点。这篇文章很清楚地解释了 `Hooks` 一些可用于组件优化的API。强推！\n&emsp;&emsp; 特别地，文章介绍了当函数组件中传入的 `props` 值为函数时，由于每一次执行或重新执行，作用域里面一切都是重新开始，函数不是简单数据类型，不能画上等号，子组件都会重新渲染。针对这个问题文章提出了几种解决办法：\n1） 作为 `props` 的函数在函数组件外定义，函数组件用 `React.memo()` 包裹。\n &emsp;&emsp; `React.memo()` 类似于 `PureComponent` 和 `ComponentDidUpdate` ，如果函数组件的 `props` 值都一样，就会跳过该组件的执行，减少不必要的渲染，实现性能优化。\n2） 作为 `props` 的函数在函数组件内定义，使用`useCallBack` 或 `useMemo`包裹，函数组件用 `React.memo()` 包裹。\n&emsp;&emsp; `useCallback(() => {}, [deps])` 返回一个函数，当 `deps` 不变时（如传入空数组，表示没有依赖），都是同一个函数。`const a = useMemo(() => memorizeValue, [deps])`，当 `deps` 不变时，`a` 的值还是上次的 `memorizeValue`，省去了重新计算的过程。\n&emsp;&emsp; 注意当 `memorizeValue` 是一个函数时，`useCallback(fn, inputs) <=> useMemo(() => fn, inputs)`。\n\n\n#### 2019/7/10\n&emsp;&emsp;今天在项目中接触到了 `symbol`，鉴于之前一直没有注意这个数据类型，在今天补上。 `symbol` 是 ES6 新增的**基本**数据类型。它的使用如下：\n```\nconst s1 = Symbol();\nconst s2 = Symbol();\nconsole.log(s1 === s2); // false\n\nconst s3 = new Symbol() // TypeError: Symbol is not a constructor\nSymbol(\"foo\") === Symbol(\"foo\"); // false\n```\n`Symbol()` 返回的每个 `symbol` 值都是唯一的，可以接受一个字符串作为参数。它最常被用于对象属性的标识符，如：\n```\nconst obj = {}\nconst foo = Symbol(\"foo\")\nobj[foo] = \"foo\"\nobj.bar = \"bar\"\n\nconsole.log(obj); // { bar: \"bar\" , Symbol(foo): \"foo\"}\nconsole.log(foo in obj); // true\nconsole.log(obj[foo]); // foo\nconsole.log(Object.keys(obj)); // [\"bar\"]\nconsole.log(Object.getOwnPropertySymbols(obj)) // [Symbol(foo)]\n```\n也就是说， `Object.key()` 不会返回 `symbol` 值，同理，`Object.getOwnPropertyNames()`、`for..in`、`for...of` 也不会返回。`JSON.stringify()` 也会忽略：\n```\nJSON.stringify({[Symbol('foo')]: 'foo'});                 \n// '{}'\n```\n`Symbol` 还有两个方法。 `Symbol.for(key)` 是根据指定的 `key` 搜索现有的 `symbol` 并返回, 如果找不到，会使用 `key` 在全局的 `symbol` 注册表中创建一个新的 `symbol` 。`Symbol.keyFor(sym)` 是在全局注册表中检索，返回共享的 `symbol key` 。\n\n\n#### 2019/7/9\n一个不好的编程习惯：让函数在内部获取自己所需的依赖。例如：\n```\n// 一个可复用函数\nfunction doSomething(key: string) {\n    return (\n        <Button\n            loading = {key===\"str1\"? Compoment1 : Compoment2}\n        >\n            button\n        </Button>\n    )\n}\n```\n`lodaing` 所需的组件应该是作为函数参数传入的，不然如果我们新增了一个 `key`，很容易忽略了该地方的修改。这个观点类似于依赖反转。","source":"_posts/FrontEnd-Daily-Learning.md","raw":"---\ntitle: FrontEnd Daily Learning\ncatalog: true\ndate: 2019-07-11 19:44:53\nsubtitle:\nheader-img:\ntags: FE\n---\n#### 前言\n📝 recap and cheat sheet ，记录每天学到的知识/想法。\n🔊 每日一问：今天你比昨天更博学了吗？\n\n\n#### 2019/8/25\n今日踩坑记录：\n展开语法（spread syntax）只能取到 enumerable properties。例如：\n```\nconst imageData = new ImageData(200, 100);\n// ImageData { width: 200, height: 100, data: Uint8ClampedArray[80000] }\nconst result = {...imageData}\n// result 只会包含 data ，不能取到 width 和 height\n```\n\n\n#### 2019/8/24\n避免组件重新挂载，可以使用事件的形式：\n```\nclass BussinessProvider {\n  sp$ = new Subject<{url: string, slic: string}>();\n}\n\nclass Canvas {\n  componentDidMount() {\n     this.props.sp$.pipe(takeUntil(this.unmount$)).subscribe(ev => {\n        if (ev.url === this.url) {\n           this.handleSuperPixelChange(ev.slic)\n        }\n     })\n  }\n}\n```\n\n\n#### 2019/8/24\n一、Promise\n```\nnew Promise((resolve,reject) => {\n  // do something...\n})\n\npromise.then(onFulfilled[, onRejected]);\npromise.then(value => {\n  // fulfillment\n}, reason => {\n  // rejection\n});\n\npromise.catch(onRejected);\npromise.catch(function(reason) {\n   // rejection\n});\n```\n简单来说，`reject(value)` 可以被 `promise.then` 第二个函数参数捕获，也可以被 `promise.catch` 捕获。如果两者同时存在，会被 `promise.then` 第二个函数参数捕获，`promise.catch` 无输出。\n\n下载图片的典型例子：\n```\nfunction loadImage(url) {\n  return new Promise((resolve, reject) => {\n    let img = new Image();\n    // img.onload = () => resolve(img)\n    img.addEventListener('load', e => resolve(img));\n    // img.onerror = () => reject(XXX)\n    img.addEventListener('error', () => {\n      reject(new Error(`Failed to load image's URL: ${url}`));\n    });\n    img.src = url;\n  });\n}\n\nloadImage('http://thecatapi.com/api/images/get?format=src&type=jpg&size=small')\n  .then(img => document.getElementById('image-holder').appendChild(img))\n  .catch(error => console.error(error));\n```\n\n二、await\n`[rv] = await expression`:\n>TL;DR returns the fulfilled value of the promise, \nThe await expression causes async function execution to pause until a Promise is settled, that is fulfilled or rejected, and to resume execution of the async function after fulfillment. When resumed, the value of the await expression is that of the fulfilled Promise.\nIf the Promise is rejected, the await expression throws the rejected value.\nIf the value of the expression following the await operator is not a Promise, it's converted to a resolved Promise.\n\n\n#### 2019/8/23\n`String.prototype.localeCompare()`\n> return a number, indicating whether the reference string comes before, after or is the same as the compareString in sort order. Returns one of three values:\n-1: if the reference string is sorted before the compareString\n 0: if the two strings are equal\n 1: if the reference string is sorted after the compareString\n\n`Array.prototype.sort()`\n>  sorts the elements of an array in place and returns the sorted array. \n\n```\nitems.sort((a,b) => a.localeCompare(b))\n```\n\n\n#### 2019/8/21\n今日阅读：\n[What is the difference between “npm install” and “npm ci”?](https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci)\n[Everything You Wanted To Know About package-lock.json But Were Too Afraid To Ask](https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8)\n\n\n#### 2019/8/20\n模仿 react hook `useState` 的第二个参数：\n&emsp;&emsp;因为在 jest 测试中某个函数的参数是 `useState` 的第二个参数，写了一个替代，不过不确定是否有错。😳\n```\n// for example\nconst [str,setStr] = useState<string[]>([]);\n\n// fake setStr\nlet str:string[] = [];\nconst setStr = (val: string[] | ((prev:string[]) => string[])) => {\n  if (typeof val === \"object\") {\n    str = val;\n  } else if (typeof val === \"function\") {\n    str = val(str)\n  }\n}\n```\n\n#### 2019/8/19\n今日阅读：[What is rel=noopener noreferrer link](https://searchenginelaws.com/seo/what-is-rel-noopener-noreferrer-tag/)\n&emsp;&emsp;使用 `a` 标签，且属性 `target=\"_blank\"` 时，需要加上 `rel=\"noopener noreferrer\"` 。可以防止新窗口利用 `window.opener` 的特性窃取原窗口信息。具体而言，如果 window A 打开了 window B，那么 B.opener 会返回 A。如果加上 `rel=\"noopener\"` ，会返回 null 。\n\n\n#### 2019/8/12\n一、download files using axios\n```\nimport axios from \"axios\"\n\naxios.get(url,{\n  responseType: 'blob', // important\n  headers: {\n    'Authorization': AuthStr \n  }\n}).then(resp => {\n  const {data} = resp;\n  const file = new File([data],\"data.txt\");\n  const objectURL = URL.createObjectURL(file);\n  const a = document.createElement(\"a\");\n  a.href = objectURL;\n  a.download = \"data.txt\";\n  a.click();\n  URL.revokeObjectURL(objectURL);\n})\n```\n&emsp;&emsp;如果是单次点击下载多个文件，Chrome 只会弹出一个弹窗下载最后一个文件。这个时候可以加上 `setTimeout` ，触发多次下载，或是加上 `a.target = \"_blank\"` ，打开多个新窗口。\n二、curl\n查看命令：\n`curl --help`\n-H 指定Header：\n`curl -H \"Authorization: XXXXXXXX\" URL`\n`curl POST -d data -H \"Authorization: XXXXXXXX\" URL`\n\n\n#### 2019/8/9\n一、[useRef vs useState: Should we re-render or not?](https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/)\n![FE_20190808](FE_20190809.png)\n二、Hooks 监听键盘事件\nkeyCode: https://keycode.info/\n```\nfunction useKeyPress(targetKey) {\n  const [keyPressed, setKeyPressed] = useState(false);\n\n  function downHandler({ key }) {\n    if (key === targetKey) {\n      setKeyPressed(true);\n    }\n  }\n\n  const upHandler = ({ key }) => {\n    if (key === targetKey) {\n      setKeyPressed(false);\n    }\n  };\n\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, []);\n\n  return keyPressed;\n}\n```\n\n\n#### 2019/8/8\n&emsp;&emsp;工程中经常会看到 CI/CD 的概念。CI 指的是持续集成，侧重于简化发布准备工作的实践，比如自动测试；CD 指的是持续交付，意味着不仅让测试自动化，让发布流程也自动化了。更多概念对比可以参考：[Continuous integration VS continuous delivery VS continuous deployment](https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment)\n&emsp;&emsp;下面这个图很清晰地描述了三者的不同：\n![FE_20190808](FE_20190808.png)\n&emsp;&emsp;在 gitlab 上的实践可以参考：[基于 GitLab CI/CD 的自动化构建、发布实践](https://mp.weixin.qq.com/s/z2f1i2FgrVGofQR6nKTd1A)\n\n#### 2019/8/7\nTypescript: [Discriminated Unions](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions) \n&emsp;&emsp;当我们某个参数可能有多个类型，而这些类型中又有公共的属性时，就可以使用这种形式约束。\n```\n// Each interface has a kind property with a different string literal type. \n// The kind property is called the discriminant or tag. \ninterface Square {\n    kind: \"square\";\n    size: number;\n}\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\n// put the interfaces into a union\ntype Shape = Square | Rectangle | Circle;\n\n// use the discriminated union\nfunction area(s: Shape) {\n    switch (s.kind) {\n        case \"square\": return s.size * s.size;\n        case \"rectangle\": return s.height * s.width;\n        case \"circle\": return Math.PI * s.radius ** 2;\n        default: return assertNever(s); // error here if there are missing cases\n    }\n}\n\n// Exhaustiveness checking \nfunction assertNever(x: never): never {\n    throw new Error(\"Unexpected object: \" + x);\n}\n```\n\n\n#### 2019/8/6\nStack Overflow: [useState set method not reflecting change immediately.](https://stackoverflow.com/questions/54069253/usestate-set-method-not-reflecting-change-immediately)\n&emsp;&emsp;今天在实践中发现，`setState` 后马上打印，并不会取到更新后的值。查阅资料后发现这个函数是一个异步的函数，不会立即更新，但会触发重新渲染。如下：\n![FE_20190806](FE_20190806.png)\n\n\n#### 2019/8/1\n一、[Fetch API](https://javascript.info/fetch-api)\n&emsp;&emsp;用 fetch 来请求网络资源，可以配置不同的参数来解决缓存、跨域等问题，如下示例代码：\n```\n// 不缓存请求结果 \n// https://stackoverflow.com/questions/29246444/fetch-how-do-you-make-a-non-cached-request\nconst headers = new Headers();\nheaders.append(\"pragma\", \"no-cache\");\nheaders.append(\"cache-control\", \"no-store\");\n\n// 完全忽略 http-cache ，每次都从服务器请求数据\n// https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\nconst cache: RequestCache = \"no-store\";\n\n// 请求模式，若有的请求会因为 cors 而失败，可以设置为 \"no-cors\"\n// https://developer.mozilla.org/en-US/docs/Web/API/Request/mode\nconst mode: RequestMode = needCors ? \"cors\" : \"no-cors\";\n\nawait fetch(url. {headers, cache, mode})\n  .then(res => res.blob())\n  .then(blob => {\n    // doSomething with blob\n    const url = URL.createObjectURL(blob)\n    let a = document.createElement('a')\n    a.download = 'example.zip'\n    a.href = url\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n  })\n  .catch(err => {\n    console.log(err)\n  })\n  .finally(() => {\n    // doSomething\n  })\n```\n&emsp;&emsp;关于 `res.blob()` ，可以参考知乎上[谈一谈 Fetch API 中的 “res.blob()”](https://zhuanlan.zhihu.com/p/32909043)；也可以参考 [fetch documentation](https://github.github.io/fetch/) ，这一篇比较详细，也提供了较多其他的例子。\n关于浏览器缓存问题，Medium 上这篇 [A Web Developer’s Guide to Browser Caching](https://medium.com/@codebyamir/a-web-developers-guide-to-browser-caching-cc41f3b73e7c) 写得不错。如果存在代理服务器，即使我们设置了 `mode: 'no-store'` ，代理服务器也会缓存。为了避免这个情况，我们可以在每次发送请求时构造新的 URL ，加上时间戳 `?t=Date.now()` 。🐮🍺\n二、Jest\n&emsp;&emsp;我们在使用 jest 测试时，有时候需要引入一些外部文件/外部变量，如从 `config.json` 文件中引入某个变量。为了在测试文件中可以访问到该变量，我们可以在 `jest.config.js` 中配置全局变量：\n```\nmodule.exports = {\n  globals: {\n    API_BASE: \"\",\n    DATA_API: \"\",\n    TRACK_API: \"\"\n  },\n  setupFiles: [\"./jestSetup.ts\"]\n}\n```\n&emsp;&emsp;由于 `globals` 只支持 JSON 格式的变量，如果我们需要定义全局函数，则可以使用 `setupFiles`。\n```\n// jestSetup.ts\n(global as any).fn= () => {};\n(global as any).variable = \"XXX\";\n```\n\n\n#### 2019/7/31\n1）`position: fixed` 和 flex 布局是不能同时起作用的。绝对布局脱离文档流，不会参与到 flex layout 中。如果想实现左侧菜单栏，右侧内容，两者不同时滚动（菜单栏 fixed），但菜单栏的大小可以改变（flex 父布局）。可以让父容器是 flex 布局，左侧菜单栏和右侧内容区域都是 flex element ， 菜单栏内部再有一个 `position: fixed` 的 div 。\n2）如果想让 `position: fixed` 的元素相对父容器定位，可以给父容器增加 CSS 属性 `transform: translate(0,0)` 。参考：[MDN - position](https://developer.mozilla.org/en-US/docs/Web/CSS/position)\n> fixed: It is positioned relative to the initial containing block established by the viewport, except when one of its ancestors has a transform, perspective, or filter property set to something other than none. \n\n\n#### 2019/7/30\n`useEffect` 中的异步请求：\n```\n// 错误写法， return 必须是 cleanup function\nuseEffect(async () => {\n  const newVal = await asyncCall();\n  setVal(newVal);\n});\n\n// 正确写法\nuseEffect(() => {\n  asyncCall().then(resp => setVal(resp.data));\n});\n```\n好文共享：[How to fetch data with React Hooks?](https://www.robinwieruch.de/react-hooks-fetch-data/)，代码如下：\n```\nuseEffect(() => {\n  async function fetchMyAPI() {\n    let url = 'http://something/' + productId;\n    let config = {};\n    const response = await myFetch(url);\n    console.log(response);\n  }  \n\n  fetchMyAPI();\n}, [productId]);\n```\n如果要保证请求按顺序发出，可以采用如下写法：\n```\nuseEffect(() => {\n  let didCancel = false;\n\n  async function fetchMyAPI() {\n    let url = 'http://something/' + productId;\n    let config = {};\n    const response = await myFetch(url);\n    if (!didCancel) { // Ignore if we started fetching something else\n      console.log(response);\n    } \n  }  \n\n  fetchMyAPI();\n  return () => { didCancel = true; }; // Remember if we start fetching something else\n}, [productId]);\n```\n\n\n#### 2019/7/29\n一、[performance.now() vs Date.now()](https://stackoverflow.com/questions/30795525/performance-now-vs-date-now)\n&emsp;&emsp;在程序中打印执行时间时，使用 `performance.now(）` 更准确。\n```\nconst start = performance.now();\ndoSomething();\nconst end = performance.now();\nconsole.log(\"Call to doSomething took \" + (start - end) + \" milliseconds.\");\n```\n二、[Does javascript slice method return a shallow copy?](https://stackoverflow.com/questions/47738344/does-javascript-slice-method-return-a-shallow-copy)\n&emsp;&emsp;mdn 上对 `slice()` 方法的介绍：\n>The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included) where begin and end represent the index of items in that array. The original array will not be modified.\n\n&emsp;&emsp;注意这里的浅复制指的是对数组中值的浅复制，而不是对整个数组的浅复制。如果是一个字符串数组，则修改新数组时，原数组不会改变；如果是对象数组，修改新数组对象值时，原数组也会发生变化。\n```\nconst animals = [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}];\nconst newAnimals = animals.slice(2);\n\nnewAnimals[0].name = 'aaa';\nconsole.log(newAnimals); // [{name: 'aaa'}]\nconsole.log(animals);    // [{name: 'ant'}, {name: 'bison'}, {name: 'aaa'}]\n```\n&emsp;&emsp;注意如果是重新赋值，则等于重新分配空间，不会改变原数组。\n```\nconst animals = [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}];\nconst newAnimals = animals.slice(2);\n\nnewAnimals[0] = {name: 'aaa'};\nconsole.log(newAnimals); // [{name: 'aaa'}]\nconsole.log(animals);    // [{name: 'ant'}, {name: 'bison'}, {name: 'camel'}]\n```\n\n#### 2019/7/26\n&emsp;&emsp;应用场景：我们需要请求并更新菜单栏中任务的状态，如果一个请求完成立马更新会导致 React 频繁刷新，需要缓冲批处理：\n```\nimport { runInAction } from \"mobx\";\n\nlet handlers: Array<() => void> = [];\nconst runHandlers = () => {\n  runInAction(() => {\n    handlers.forEach(f => f());\n    handlers = [];\n  });\n};\n\nfor (const task of tasks) {\n  const {data} = await requestFn();\n  \n  handlers.push(() => {\n    // deal with data, update state\n    ...\n  });\n\n  if(handlers.length > 30) {\n    runHandlers();\n  }\n}\n\nrunHandlers();\n```\n&emsp;&emsp;上述代码主要是利用了自定义的 `handlers` 来暂存状态更新函数，之后使用 mobx 提供的 `runInAction` 执行函数并更新状态，更新状态都需要使用 `action` 函数， `runInAction` 接受一个代码块并在一个(匿名)操作中执行，有利于动态创建和执行操作，`runInAction(f) = action(f)()`。此外，必要时还可加上 `lodash.memoize(func,[resolver])`，记录主函数请求结果。\n> For one-time-actions runInAction(name?, fn) can be used, which is sugar for action(name, fn)()\n\n\n#### 2019/7/18 \n一、编程模式：\n&emsp;&emsp; 首先先记住这几种编程模式的中文：Imperative Programming 是命令式编程，Declarative Programming 是声明式编程，Reactive Programming 是响应式编程。（流下了英文不好的泪水）\n1）先看命令式编程和声明式编程的区别，直接上代码：\n```\n// 命令式编程 imperative programming\nconst array = [0,1,2,3,4,5];\nconst output = [];\nfor (let i = 0; i < array.length; i++) {\n  const tmp = array[i] * 2;\n  output.push(tmp)\n};\nconsole.log(output) // => [0,2,4,6,8,10]\n```\n```\n// 声明式编程 declarative programming\nconst array = [0,1,2,3,4,5];\nconst output = array.map(item => item * 2);\nconsole.log(output) // => [0,2,3,6,8,10]\n```\n&emsp;&emsp;很明显可以看到，命令式编程的关注点在于 how ，我们需要一步步告诉机器接下来要做什么，告诉他怎么去遍历一个数组，怎么去运算得到最后的结果，怎么去输出；声明式编程的关注点在于 what ，我们只关注最后的结果，由机器自己去摸索过程，如直接调用 `map` 函数，只告诉程序我们需要一个2倍输出。\n2）接着看声明式编程和响应式编程的对比\n&emsp;&emsp;可以阅读：[Imperative vs Reactive](https://codepen.io/HunorMarton/post/imperative-vs-reactive)，解释很清晰，比喻也很形象，但我觉得文章里的 Imperative 应该改成 Declarative 比较准确。继续沿用上面的例子，修改一下声明式编程的例子：\n```\n// 声明式编程 declarative programming\nconst array = [1,2];\nconst output = array.map(item => item * 2);\noutput.forEach(item => console.log(item)) // => 2 4\narray.push(3);  // => no output \narray.push(4);  // => no output\n```\n响应式编程的例子：\n```\nimport { Subject } from `rxjs`;\nlet array = new Subject();\narray.next(1);\narray.next(2);\n\nconst output = array.map(item => item * 2);\noutput.forEach(item => console.log(item)); // => 2 4\n\narray.next(3); // => 6\narray.next(4); // => 8\n```\n&emsp;&emsp;首先要注意的是，这两种方式中的 `map` ， `forEach` 等函数并不是一样的，内部实现机制是不同的。我们可以发现区别：在声明式编程中，如果在最后向原数组添加值，并不会打印出来，因为这是在 `console.log` 语句执行后发生的。但在响应式编程里，任何变化都可以被反应出来，它引入了一个**异步数据流**（asynchronous data streams）的概念，可以随时创建、更改或组合这些数据流，所以打印事件是一个 continuous observation case。\n二、类库\n[react-virtualized](https://github.com/bvaughn/react-virtualized) 的轻量级版 [react-window](https://github.com/bvaughn/react-window)，用于高效渲染长列表。\n\n\n#### 2019/7/17 \n&emsp;&emsp;如果我们在项目中需要请求很多图片，想要实现请求出错时继续发送请求，成功时返回数据，可以使用 `Promise` ：\n```\nfunction fetchURL(url: string):Promise<Blob> {\n  return Axios.get(url, {responeType: \"blob\"})\n              .then( resp => Promise.resolve(resp.data) )\n              .catch( () => fetchURL(url) )\n}\n```\n之后可以使用 `rxjs` ：\n```\nimport { mergeMap, bufferTime, takeUntil } from \"rxjs/operators\";\n\n[url1,...,url10]\n  .pipe(\n    mergeMap( url => fetchURL(url).then( val => val )),\n    bufferTime(10000)\n  )\n  .subscribe({\n    next: resps => {\n      // do sth with resps:Blob[]\n    }\n  })\n```\n&emsp;&emsp;每次遇到 `rxjs` 都很头大，现在也没有发现一个比较完善清晰的教程，但它又真的很强大，后续要开专题好好学习记录这个东西。\n\n\n#### 2019/7/16\n一、今日阅读：[How to read an often-changing value from useCallback?](https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback)\n直接上官网代码：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  const textRef = useRef();\n\n  useEffect(() => {\n    textRef.current = text; // Write it to the ref\n  });\n\n  const handleSubmit = useCallback(() => {\n    const currentText = textRef.current; // Read it from the ref\n    alert(currentText);\n  }, [textRef]); // Don't recreate handleSubmit like [text] would do\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n&emsp;&emsp; 也就是说，当 `text` 的值经常发生变化时，即使 `handleSubmit` 用 `useCallback` 包裹了，还是会重新声明。解决办法是传入一个 `ref` 对象代替原始值。也可以写一个 custom hook ：\n1）官网的版本：\n```\nfunction useEventCallback(fn, dependencies) {\n  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n```\n实际使用：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  // Will be memoized even if `text` changes:\n  const handleSubmit = useEventCallback(() => {\n    alert(text);\n  }, [text]);\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n2）导师的版本：（他来了，他带着代码又来了）\n```\n/**\n * @param callback\n * @param oRefs\n */\nexport function useCallbackWithRefs<\n  Refs,\n  Callback extends (...args: any[]) => void\n>(callback: (refs: Refs) => Callback, oRefs: Refs) {\n  const refs = useRef(oRefs);\n  useEffect(\n    () => {\n      refs.current = oRefs;\n    },\n    [oRefs]\n  );\n\n  return useCallback(\n    (...args: any[]) => callback(refs.current)(...args),\n    []\n  ) as Callback;\n}\n```\n实际使用：\n```\nfunction Form() {\n  const [text, updateText] = useState('');\n  \n  // 原先的 callback 也可以有参数\n  const handleSubmit = useCallbackWithRefs(\n    refs => (params: any) => {\n      // 要注意在函数内必须使用 `refs.xxx`，不能直接使用函数外部的任何变量 `xxx`\n      console.log(refs.text);\n  }, {text});\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n```\n&emsp;&emsp;总的来说，官网的实现是将 `callback` 作为 `ref` 对象，并作为 `useCallback` 的依赖，不会频繁改变；如果在函数 `handleSubmit` 中要访问外部变量 `text` ，直接使用 `test` 即可。第二种实现方式是把经常变化的值作为 `ref` 对象，返回值 `useCallback` 第一个参数是 `refs => callback` ，依赖是空数组；这时如果要在函数 `handleSubmit` 中要访问外部变量 `text` ，必须使用 `refs.test` ，否则访问的只是 `test` 的初始值。\n&emsp;&emsp;React 博大精深，接下来要好好研读一下这个 [FAQ](https://reactjs.org/docs/hooks-faq.html)。\n二、今日网址\n&emsp;&emsp;一个 [emoji copy](https://www.emojicopy.com/) 网站，我们 👧 就是喜欢这些花里胡哨的东西。\n\n\n#### 2019/7/15\n&emsp;&emsp;今天在项目中使用 React Hooks 又踩坑了，看来自己对这部分还是没有理解透彻。在使用 `useCallback` 和 `useEffect` 时，要注意第二个参数，也就是传入的 `[deps]`。如果使用 `useCallback(fn,[deps])` ， `[deps]` 应该包含函数 `fn` 所涉及的所有变量；如果使用 `useEffect(fn,[deps])` ， 当 `deps` 的值变化时，就会执行 `fn`，因此`[deps]` 不一定要包含函数 `fn` 所涉及的所有变量，而是应该传入会引起该函数执行的那些参数。\n&emsp;&emsp;今日踩坑记录：为了优化子组件，作为 `props` 的函数都使用 `useCallback` 包裹了，并传入了空数组作为第二个参数，表示没有依赖。但是函数中的运算需要用到组件中一个变量，如果没有将该变量作为 `deps` ，这个变量就会一直保持初始值，值并不会改变，运行结果就会与预期不符。（真的太蠢了，缓缓躺倒）\n\n\n#### 2019/7/14\n周末当然是约会啦。😍\n\n\n#### 2019/7/13\n一、今日阅读：[How to compare oldValues and newValues on React Hooks useEffect?](https://stackoverflow.com/questions/53446020/how-to-compare-oldvalues-and-newvalues-on-react-hooks-useeffect)\n&emsp;&emsp; React class 组件提供了 `ComponentDidUpdate` 之类的方法来获取到当前 `props` 和前一个 `props` ，并进行比较，决定是否进行更新。函数式组件只有 `useEffect` 函数来模仿生命周期函数，当我们需要获取组件先前的 `props` 时，可以使用下面的 custom hook ：\n```\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n```\n&emsp;&emsp;之后在 `useEffect` 中使用上面的函数来模拟 `ComponentDidUpdate` ：\n```\nconst Component = (props) => {\n    const {receiveAmount, sendAmount } = props\n    const prevAmount = usePrevious({receiveAmount, sendAmount});\n    useEffect(() => {\n        if(prevAmount.receiveAmount !== receiveAmount) {\n\n         // process here\n        }\n        if(prevAmount.sendAmount !== sendAmount) {\n\n         // process here\n        }\n    }, [receiveAmount, sendAmount])\n}\n```\n&emsp;&emsp;有时候在 debug 时，我们想知道组件为什么会重新渲染，是那些 `props` 更新了，也可以使用上面的方法来获取 `prevProps`，并在函数组件最开始时写一个 `useEffect` 将参数都打印出来，使用 `===` 比较。 \n\n\n\n#### 2019/7/12\n一、今日技能\n&emsp;&emsp;项目中经常会涉及到 JSON 字符串的解析，解析出错就扑街了，一般是用 `try {...} catch {...}` 包裹。今天导师在 code review 时建议我使用如下函数，该函数也可以覆盖空字符串的检测：\n```\nfunction safeJsonParse<T>(str): { ok: true, value: T } | { ok: false } {\n  try {\n    return {\n      ok: true,\n      value: JSON.parse(str)\n    }\n  } catch {\n    return {\n      ok: false\n    }\n  }\n}\n```\n二、今日阅读：[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://imweb.io/topic/5b72d4ef15554e6d3409f817)。\n&emsp;&emsp;这一篇很好地梳理了进程、线程、浏览器**多进程**、浏览器内核**多线程**、JS单线程、JS运行机制的相关知识，很连贯，建议时不时回顾。简单记录几个知识点：\n1）进程是CPU资源分配的最小单位，线程是CPU调度的最小单位。（想当年考操作系统的时候还背得滚瓜烂熟）\n2）**浏览器是多进程的**，包括的主要进程有：\n- Browser进程（浏览器的主进程，只有一个）\n- 浏览器渲染进程（浏览器内核，Renderer进程，渲染进程，内部是多线程的）：默认每个Tab一个进程\n- 第三方插件进程\n- GPU进程：3D绘制\n\n3）重点是浏览器内核，它是多线程的，主要常驻线程有：\n- GUI渲染线程：渲染页面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制，repaint 和 reflow 等。\n- JS引擎线程：处理任务队列中的任务，与 GUI 渲染线程是互斥的。\n- 事件触发线程：控制事件循环，把事件添加到任务队列的末尾。\n- 定时触发线程：`setTimeout` 和 `setInterval`，同样也是计时完毕后添加到队列末尾。\n- 异步 http 请求线程\n\n4）Browser进程和浏览器内核之间是需要通信的\n5）时间循环机制 `Event Loop` ：JS分为同步任务和异步任务，同步任务都会在主线程上运行，形成一个执行栈；主线程之外，由事件触发线程管理一个**任务队列/事件队列**，异步任务的运行结果会被添加到任务队列中。一旦执行栈中所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到执行栈中开始执行。 \n6）进阶：macrotask / task 和 microtask/ job。ES6中的 `Promise` 就属于 microtask 微任务 ，而主代码块，事件队列中的时间如 `setTimeout` 和 `setInterval` 就属于 macrotask 宏任务。总结的运行机制就是：\n- 执行宏任务。（从执行栈中获取，如果没有就从事件队列中获取）\n- 执行过程中如果遇到微任务，就添加到微任务队列 Job Queues 中。（作者猜测这个队列由JS引擎线程维护，因为是在主线程下无缝执行的）\n- 宏任务执行完毕后，立即依次执行当前微任务队列中所有微任务。\n- 检查渲染，由 GUI 线程接管。\n- 渲染完毕后，由 JS 引擎线程接管，从时间队列中获取并执行下一个宏任务。\n\n7）在第六点中提到的是一个进阶的概念，对应一道题目，如果代码中依次有 `setTimeout` 和 `Promise` ，是会先打印出 `Promise` 的执行结果的。\n\n\n#### 2019/7/11\n&emsp;&emsp; React 16.8 提出了 `hook` 的概念，函数式组件也可以拥有自己的状态。现在的工作项目已经摒弃了 `class` ，改用函数式组件，正在慢慢摸索中。今天在腾讯[IMWeb前端博客](http://imweb.io/)中看到了两篇介绍 `React hook` 的文章，受益匪浅，简单记录一下。\n 一、[react hook——你可能不是“我”所认识的useEffect](https://imweb.io/topic/5cd845cadcd62f86299fcd76)\n&emsp;&emsp;这篇介绍了 `useEffect` 这个API，用它模拟了class组件的生命周期函数。`useEffect` 用于执行副作用，相当于 `ComponentDidMount` 和 `ComponentDidUpdate`。该API有两个参数和一个返回值。第一个参数是一个副作用函数，返回值是清除函数，相当于 `ComponentWillUnmount`，每一次 `render` 都会执行副作用和清除上一次副作用。**第二个参数是一个数组，传入的是副作用函数所需要的依赖，当任一依赖更新时，会重新生成一个新的副作用并执行；如果传入一个空数组，没有依赖，只会执行一次，相当于 `ComponentDidMount`；如果不传，就是没有说明自己有没有依赖（注意是不知道有没有，不是没有！），每次 `render` 时就执行，相当于 `ComponentDidUpdate` 。**\n&emsp;&emsp; 最后还讲了 `useEffect` 和 `useLayoutEffect` 的区别，简单来说前者是异步的，后者是同步的。还没好好深入这部分，TODO。\n二、[可能你的react函数组件从来没有优化过](https://imweb.io/topic/5d1e3657f7b5692b080f2651)\n&emsp;&emsp;优化问题真是我一个痛点。这篇文章很清楚地解释了 `Hooks` 一些可用于组件优化的API。强推！\n&emsp;&emsp; 特别地，文章介绍了当函数组件中传入的 `props` 值为函数时，由于每一次执行或重新执行，作用域里面一切都是重新开始，函数不是简单数据类型，不能画上等号，子组件都会重新渲染。针对这个问题文章提出了几种解决办法：\n1） 作为 `props` 的函数在函数组件外定义，函数组件用 `React.memo()` 包裹。\n &emsp;&emsp; `React.memo()` 类似于 `PureComponent` 和 `ComponentDidUpdate` ，如果函数组件的 `props` 值都一样，就会跳过该组件的执行，减少不必要的渲染，实现性能优化。\n2） 作为 `props` 的函数在函数组件内定义，使用`useCallBack` 或 `useMemo`包裹，函数组件用 `React.memo()` 包裹。\n&emsp;&emsp; `useCallback(() => {}, [deps])` 返回一个函数，当 `deps` 不变时（如传入空数组，表示没有依赖），都是同一个函数。`const a = useMemo(() => memorizeValue, [deps])`，当 `deps` 不变时，`a` 的值还是上次的 `memorizeValue`，省去了重新计算的过程。\n&emsp;&emsp; 注意当 `memorizeValue` 是一个函数时，`useCallback(fn, inputs) <=> useMemo(() => fn, inputs)`。\n\n\n#### 2019/7/10\n&emsp;&emsp;今天在项目中接触到了 `symbol`，鉴于之前一直没有注意这个数据类型，在今天补上。 `symbol` 是 ES6 新增的**基本**数据类型。它的使用如下：\n```\nconst s1 = Symbol();\nconst s2 = Symbol();\nconsole.log(s1 === s2); // false\n\nconst s3 = new Symbol() // TypeError: Symbol is not a constructor\nSymbol(\"foo\") === Symbol(\"foo\"); // false\n```\n`Symbol()` 返回的每个 `symbol` 值都是唯一的，可以接受一个字符串作为参数。它最常被用于对象属性的标识符，如：\n```\nconst obj = {}\nconst foo = Symbol(\"foo\")\nobj[foo] = \"foo\"\nobj.bar = \"bar\"\n\nconsole.log(obj); // { bar: \"bar\" , Symbol(foo): \"foo\"}\nconsole.log(foo in obj); // true\nconsole.log(obj[foo]); // foo\nconsole.log(Object.keys(obj)); // [\"bar\"]\nconsole.log(Object.getOwnPropertySymbols(obj)) // [Symbol(foo)]\n```\n也就是说， `Object.key()` 不会返回 `symbol` 值，同理，`Object.getOwnPropertyNames()`、`for..in`、`for...of` 也不会返回。`JSON.stringify()` 也会忽略：\n```\nJSON.stringify({[Symbol('foo')]: 'foo'});                 \n// '{}'\n```\n`Symbol` 还有两个方法。 `Symbol.for(key)` 是根据指定的 `key` 搜索现有的 `symbol` 并返回, 如果找不到，会使用 `key` 在全局的 `symbol` 注册表中创建一个新的 `symbol` 。`Symbol.keyFor(sym)` 是在全局注册表中检索，返回共享的 `symbol key` 。\n\n\n#### 2019/7/9\n一个不好的编程习惯：让函数在内部获取自己所需的依赖。例如：\n```\n// 一个可复用函数\nfunction doSomething(key: string) {\n    return (\n        <Button\n            loading = {key===\"str1\"? Compoment1 : Compoment2}\n        >\n            button\n        </Button>\n    )\n}\n```\n`lodaing` 所需的组件应该是作为函数参数传入的，不然如果我们新增了一个 `key`，很容易忽略了该地方的修改。这个观点类似于依赖反转。","slug":"FrontEnd-Daily-Learning","published":1,"updated":"2019-12-08T08:32:53.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5393irz0006icuer01dr8er","content":"<h4 id=\"前言\">前言</h4>\n<p>📝 recap and cheat sheet ，记录每天学到的知识/想法。<br>\n🔊 每日一问：今天你比昨天更博学了吗？</p>\n<h4 id=\"2019825\">2019/8/25</h4>\n<p>今日踩坑记录：<br>\n展开语法（spread syntax）只能取到 enumerable properties。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const imageData = new ImageData(200, 100);</span><br><span class=\"line\">// ImageData &#123; width: 200, height: 100, data: Uint8ClampedArray[80000] &#125;</span><br><span class=\"line\">const result = &#123;...imageData&#125;</span><br><span class=\"line\">// result 只会包含 data ，不能取到 width 和 height</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019824\">2019/8/24</h4>\n<p>避免组件重新挂载，可以使用事件的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BussinessProvider &#123;</span><br><span class=\"line\">  sp$ = new Subject&lt;&#123;url: string, slic: string&#125;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Canvas &#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">     this.props.sp$.pipe(takeUntil(this.unmount$)).subscribe(ev =&gt; &#123;</span><br><span class=\"line\">        if (ev.url === this.url) &#123;</span><br><span class=\"line\">           this.handleSuperPixelChange(ev.slic)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019824\">2019/8/24</h4>\n<p>一、Promise</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">  // do something...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(onFulfilled[, onRejected]);</span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">  // fulfillment</span><br><span class=\"line\">&#125;, reason =&gt; &#123;</span><br><span class=\"line\">  // rejection</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.catch(onRejected);</span><br><span class=\"line\">promise.catch(function(reason) &#123;</span><br><span class=\"line\">   // rejection</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简单来说，<code>reject(value)</code> 可以被 <code>promise.then</code> 第二个函数参数捕获，也可以被 <code>promise.catch</code> 捕获。如果两者同时存在，会被 <code>promise.then</code> 第二个函数参数捕获，<code>promise.catch</code> 无输出。</p>\n<p>下载图片的典型例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function loadImage(url) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    let img = new Image();</span><br><span class=\"line\">    // img.onload = () =&gt; resolve(img)</span><br><span class=\"line\">    img.addEventListener(&apos;load&apos;, e =&gt; resolve(img));</span><br><span class=\"line\">    // img.onerror = () =&gt; reject(XXX)</span><br><span class=\"line\">    img.addEventListener(&apos;error&apos;, () =&gt; &#123;</span><br><span class=\"line\">      reject(new Error(`Failed to load image&apos;s URL: $&#123;url&#125;`));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    img.src = url;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">loadImage(&apos;http://thecatapi.com/api/images/get?format=src&amp;type=jpg&amp;size=small&apos;)</span><br><span class=\"line\">  .then(img =&gt; document.getElementById(&apos;image-holder&apos;).appendChild(img))</span><br><span class=\"line\">  .catch(error =&gt; console.error(error));</span><br></pre></td></tr></table></figure>\n<p>二、await<br>\n<code>[rv] = await expression</code>:</p>\n<blockquote>\n<p>TL;DR returns the fulfilled value of the promise,<br>\nThe await expression causes async function execution to pause until a Promise is settled, that is fulfilled or rejected, and to resume execution of the async function after fulfillment. When resumed, the value of the await expression is that of the fulfilled Promise.<br>\nIf the Promise is rejected, the await expression throws the rejected value.<br>\nIf the value of the expression following the await operator is not a Promise, it’s converted to a resolved Promise.</p>\n</blockquote>\n<h4 id=\"2019823\">2019/8/23</h4>\n<p><code>String.prototype.localeCompare()</code></p>\n<blockquote>\n<p>return a number, indicating whether the reference string comes before, after or is the same as the compareString in sort order. Returns one of three values:<br>\n-1: if the reference string is sorted before the compareString<br>\n0: if the two strings are equal<br>\n1: if the reference string is sorted after the compareString</p>\n</blockquote>\n<p><code>Array.prototype.sort()</code></p>\n<blockquote>\n<p>sorts the elements of an array in place and returns the sorted array.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">items.sort((a,b) =&gt; a.localeCompare(b))</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019821\">2019/8/21</h4>\n<p>今日阅读：<br>\n<a href=\"https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci\" target=\"_blank\" rel=\"noopener\">What is the difference between “npm install” and “npm ci”?</a><br>\n<a href=\"https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8\" target=\"_blank\" rel=\"noopener\">Everything You Wanted To Know About package-lock.json But Were Too Afraid To Ask</a></p>\n<h4 id=\"2019820\">2019/8/20</h4>\n<p>模仿 react hook <code>useState</code> 的第二个参数：<br>\n  因为在 jest 测试中某个函数的参数是 <code>useState</code> 的第二个参数，写了一个替代，不过不确定是否有错。😳</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// for example</span><br><span class=\"line\">const [str,setStr] = useState&lt;string[]&gt;([]);</span><br><span class=\"line\"></span><br><span class=\"line\">// fake setStr</span><br><span class=\"line\">let str:string[] = [];</span><br><span class=\"line\">const setStr = (val: string[] | ((prev:string[]) =&gt; string[])) =&gt; &#123;</span><br><span class=\"line\">  if (typeof val === &quot;object&quot;) &#123;</span><br><span class=\"line\">    str = val;</span><br><span class=\"line\">  &#125; else if (typeof val === &quot;function&quot;) &#123;</span><br><span class=\"line\">    str = val(str)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019819\">2019/8/19</h4>\n<p>今日阅读：<a href=\"https://searchenginelaws.com/seo/what-is-rel-noopener-noreferrer-tag/\" target=\"_blank\" rel=\"noopener\">What is rel=noopener noreferrer link</a><br>\n  使用 <code>a</code> 标签，且属性 <code>target=&quot;_blank&quot;</code> 时，需要加上 <code>rel=&quot;noopener noreferrer&quot;</code> 。可以防止新窗口利用 <code>window.opener</code> 的特性窃取原窗口信息。具体而言，如果 window A 打开了 window B，那么 B.opener 会返回 A。如果加上 <code>rel=&quot;noopener&quot;</code> ，会返回 null 。</p>\n<h4 id=\"2019812\">2019/8/12</h4>\n<p>一、download files using axios</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &quot;axios&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.get(url,&#123;</span><br><span class=\"line\">  responseType: &apos;blob&apos;, // important</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &apos;Authorization&apos;: AuthStr </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(resp =&gt; &#123;</span><br><span class=\"line\">  const &#123;data&#125; = resp;</span><br><span class=\"line\">  const file = new File([data],&quot;data.txt&quot;);</span><br><span class=\"line\">  const objectURL = URL.createObjectURL(file);</span><br><span class=\"line\">  const a = document.createElement(&quot;a&quot;);</span><br><span class=\"line\">  a.href = objectURL;</span><br><span class=\"line\">  a.download = &quot;data.txt&quot;;</span><br><span class=\"line\">  a.click();</span><br><span class=\"line\">  URL.revokeObjectURL(objectURL);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>  如果是单次点击下载多个文件，Chrome 只会弹出一个弹窗下载最后一个文件。这个时候可以加上 <code>setTimeout</code> ，触发多次下载，或是加上 <code>a.target = &quot;_blank&quot;</code> ，打开多个新窗口。<br>\n二、curl<br>\n查看命令：<br>\n<code>curl --help</code><br>\n-H 指定Header：<br>\n<code>curl -H &quot;Authorization: XXXXXXXX&quot; URL</code><br>\n<code>curl POST -d data -H &quot;Authorization: XXXXXXXX&quot; URL</code></p>\n<h4 id=\"201989\">2019/8/9</h4>\n<p>一、<a href=\"https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/\" target=\"_blank\" rel=\"noopener\">useRef vs useState: Should we re-render or not?</a><br>\n<img src=\"FE_20190809.png\" alt=\"FE_20190808\"><br>\n二、Hooks 监听键盘事件<br>\nkeyCode: <a href=\"https://keycode.info/\" target=\"_blank\" rel=\"noopener\">https://keycode.info/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function useKeyPress(targetKey) &#123;</span><br><span class=\"line\">  const [keyPressed, setKeyPressed] = useState(false);</span><br><span class=\"line\"></span><br><span class=\"line\">  function downHandler(&#123; key &#125;) &#123;</span><br><span class=\"line\">    if (key === targetKey) &#123;</span><br><span class=\"line\">      setKeyPressed(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const upHandler = (&#123; key &#125;) =&gt; &#123;</span><br><span class=\"line\">    if (key === targetKey) &#123;</span><br><span class=\"line\">      setKeyPressed(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    window.addEventListener(&apos;keydown&apos;, downHandler);</span><br><span class=\"line\">    window.addEventListener(&apos;keyup&apos;, upHandler);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      window.removeEventListener(&apos;keydown&apos;, downHandler);</span><br><span class=\"line\">      window.removeEventListener(&apos;keyup&apos;, upHandler);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  return keyPressed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"201988\">2019/8/8</h4>\n<p>  工程中经常会看到 CI/CD 的概念。CI 指的是持续集成，侧重于简化发布准备工作的实践，比如自动测试；CD 指的是持续交付，意味着不仅让测试自动化，让发布流程也自动化了。更多概念对比可以参考：<a href=\"https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment\" target=\"_blank\" rel=\"noopener\">Continuous integration VS continuous delivery VS continuous deployment</a><br>\n  下面这个图很清晰地描述了三者的不同：<br>\n<img src=\"FE_20190808.png\" alt=\"FE_20190808\"><br>\n  在 gitlab 上的实践可以参考：<a href=\"https://mp.weixin.qq.com/s/z2f1i2FgrVGofQR6nKTd1A\" target=\"_blank\" rel=\"noopener\">基于 GitLab CI/CD 的自动化构建、发布实践</a></p>\n<h4 id=\"201987\">2019/8/7</h4>\n<p>Typescript: <a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions\" target=\"_blank\" rel=\"noopener\">Discriminated Unions</a><br>\n  当我们某个参数可能有多个类型，而这些类型中又有公共的属性时，就可以使用这种形式约束。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Each interface has a kind property with a different string literal type. </span><br><span class=\"line\">// The kind property is called the discriminant or tag. </span><br><span class=\"line\">interface Square &#123;</span><br><span class=\"line\">    kind: &quot;square&quot;;</span><br><span class=\"line\">    size: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Rectangle &#123;</span><br><span class=\"line\">    kind: &quot;rectangle&quot;;</span><br><span class=\"line\">    width: number;</span><br><span class=\"line\">    height: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Circle &#123;</span><br><span class=\"line\">    kind: &quot;circle&quot;;</span><br><span class=\"line\">    radius: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// put the interfaces into a union</span><br><span class=\"line\">type Shape = Square | Rectangle | Circle;</span><br><span class=\"line\"></span><br><span class=\"line\">// use the discriminated union</span><br><span class=\"line\">function area(s: Shape) &#123;</span><br><span class=\"line\">    switch (s.kind) &#123;</span><br><span class=\"line\">        case &quot;square&quot;: return s.size * s.size;</span><br><span class=\"line\">        case &quot;rectangle&quot;: return s.height * s.width;</span><br><span class=\"line\">        case &quot;circle&quot;: return Math.PI * s.radius ** 2;</span><br><span class=\"line\">        default: return assertNever(s); // error here if there are missing cases</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Exhaustiveness checking </span><br><span class=\"line\">function assertNever(x: never): never &#123;</span><br><span class=\"line\">    throw new Error(&quot;Unexpected object: &quot; + x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"201986\">2019/8/6</h4>\n<p>Stack Overflow: <a href=\"https://stackoverflow.com/questions/54069253/usestate-set-method-not-reflecting-change-immediately\" target=\"_blank\" rel=\"noopener\">useState set method not reflecting change immediately.</a><br>\n  今天在实践中发现，<code>setState</code> 后马上打印，并不会取到更新后的值。查阅资料后发现这个函数是一个异步的函数，不会立即更新，但会触发重新渲染。如下：<br>\n<img src=\"FE_20190806.png\" alt=\"FE_20190806\"></p>\n<h4 id=\"201981\">2019/8/1</h4>\n<p>一、<a href=\"https://javascript.info/fetch-api\" target=\"_blank\" rel=\"noopener\">Fetch API</a><br>\n  用 fetch 来请求网络资源，可以配置不同的参数来解决缓存、跨域等问题，如下示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 不缓存请求结果 </span><br><span class=\"line\">// https://stackoverflow.com/questions/29246444/fetch-how-do-you-make-a-non-cached-request</span><br><span class=\"line\">const headers = new Headers();</span><br><span class=\"line\">headers.append(&quot;pragma&quot;, &quot;no-cache&quot;);</span><br><span class=\"line\">headers.append(&quot;cache-control&quot;, &quot;no-store&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 完全忽略 http-cache ，每次都从服务器请求数据</span><br><span class=\"line\">// https://developer.mozilla.org/en-US/docs/Web/API/Request/cache</span><br><span class=\"line\">const cache: RequestCache = &quot;no-store&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 请求模式，若有的请求会因为 cors 而失败，可以设置为 &quot;no-cors&quot;</span><br><span class=\"line\">// https://developer.mozilla.org/en-US/docs/Web/API/Request/mode</span><br><span class=\"line\">const mode: RequestMode = needCors ? &quot;cors&quot; : &quot;no-cors&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">await fetch(url. &#123;headers, cache, mode&#125;)</span><br><span class=\"line\">  .then(res =&gt; res.blob())</span><br><span class=\"line\">  .then(blob =&gt; &#123;</span><br><span class=\"line\">    // doSomething with blob</span><br><span class=\"line\">    const url = URL.createObjectURL(blob)</span><br><span class=\"line\">    let a = document.createElement(&apos;a&apos;)</span><br><span class=\"line\">    a.download = &apos;example.zip&apos;</span><br><span class=\"line\">    a.href = url</span><br><span class=\"line\">    document.body.appendChild(a)</span><br><span class=\"line\">    a.click()</span><br><span class=\"line\">    document.body.removeChild(a)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(err =&gt; &#123;</span><br><span class=\"line\">    console.log(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .finally(() =&gt; &#123;</span><br><span class=\"line\">    // doSomething</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>  关于 <code>res.blob()</code> ，可以参考知乎上<a href=\"https://zhuanlan.zhihu.com/p/32909043\" target=\"_blank\" rel=\"noopener\">谈一谈 Fetch API 中的 “res.blob()”</a>；也可以参考 <a href=\"https://github.github.io/fetch/\" target=\"_blank\" rel=\"noopener\">fetch documentation</a> ，这一篇比较详细，也提供了较多其他的例子。<br>\n关于浏览器缓存问题，Medium 上这篇 <a href=\"https://medium.com/@codebyamir/a-web-developers-guide-to-browser-caching-cc41f3b73e7c\" target=\"_blank\" rel=\"noopener\">A Web Developer’s Guide to Browser Caching</a> 写得不错。如果存在代理服务器，即使我们设置了 <code>mode: 'no-store'</code> ，代理服务器也会缓存。为了避免这个情况，我们可以在每次发送请求时构造新的 URL ，加上时间戳 <code>?t=Date.now()</code> 。🐮🍺<br>\n二、Jest<br>\n  我们在使用 jest 测试时，有时候需要引入一些外部文件/外部变量，如从 <code>config.json</code> 文件中引入某个变量。为了在测试文件中可以访问到该变量，我们可以在 <code>jest.config.js</code> 中配置全局变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  globals: &#123;</span><br><span class=\"line\">    API_BASE: &quot;&quot;,</span><br><span class=\"line\">    DATA_API: &quot;&quot;,</span><br><span class=\"line\">    TRACK_API: &quot;&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setupFiles: [&quot;./jestSetup.ts&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  由于 <code>globals</code> 只支持 JSON 格式的变量，如果我们需要定义全局函数，则可以使用 <code>setupFiles</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// jestSetup.ts</span><br><span class=\"line\">(global as any).fn= () =&gt; &#123;&#125;;</span><br><span class=\"line\">(global as any).variable = &quot;XXX&quot;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019731\">2019/7/31</h4>\n<p>1）<code>position: fixed</code> 和 flex 布局是不能同时起作用的。绝对布局脱离文档流，不会参与到 flex layout 中。如果想实现左侧菜单栏，右侧内容，两者不同时滚动（菜单栏 fixed），但菜单栏的大小可以改变（flex 父布局）。可以让父容器是 flex 布局，左侧菜单栏和右侧内容区域都是 flex element ， 菜单栏内部再有一个 <code>position: fixed</code> 的 div 。<br>\n2）如果想让 <code>position: fixed</code> 的元素相对父容器定位，可以给父容器增加 CSS 属性 <code>transform: translate(0,0)</code> 。参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">MDN - position</a></p>\n<blockquote>\n<p>fixed: It is positioned relative to the initial containing block established by the viewport, except when one of its ancestors has a transform, perspective, or filter property set to something other than none.</p>\n</blockquote>\n<h4 id=\"2019730\">2019/7/30</h4>\n<p><code>useEffect</code> 中的异步请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 错误写法， return 必须是 cleanup function</span><br><span class=\"line\">useEffect(async () =&gt; &#123;</span><br><span class=\"line\">  const newVal = await asyncCall();</span><br><span class=\"line\">  setVal(newVal);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确写法</span><br><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  asyncCall().then(resp =&gt; setVal(resp.data));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>好文共享：<a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\" target=\"_blank\" rel=\"noopener\">How to fetch data with React Hooks?</a>，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  async function fetchMyAPI() &#123;</span><br><span class=\"line\">    let url = &apos;http://something/&apos; + productId;</span><br><span class=\"line\">    let config = &#123;&#125;;</span><br><span class=\"line\">    const response = await myFetch(url);</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  fetchMyAPI();</span><br><span class=\"line\">&#125;, [productId]);</span><br></pre></td></tr></table></figure>\n<p>如果要保证请求按顺序发出，可以采用如下写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  let didCancel = false;</span><br><span class=\"line\"></span><br><span class=\"line\">  async function fetchMyAPI() &#123;</span><br><span class=\"line\">    let url = &apos;http://something/&apos; + productId;</span><br><span class=\"line\">    let config = &#123;&#125;;</span><br><span class=\"line\">    const response = await myFetch(url);</span><br><span class=\"line\">    if (!didCancel) &#123; // Ignore if we started fetching something else</span><br><span class=\"line\">      console.log(response);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  fetchMyAPI();</span><br><span class=\"line\">  return () =&gt; &#123; didCancel = true; &#125;; // Remember if we start fetching something else</span><br><span class=\"line\">&#125;, [productId]);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019729\">2019/7/29</h4>\n<p>一、<a href=\"https://stackoverflow.com/questions/30795525/performance-now-vs-date-now\" target=\"_blank\" rel=\"noopener\">performance.now() vs Date.now()</a><br>\n  在程序中打印执行时间时，使用 <code>performance.now(）</code> 更准确。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const start = performance.now();</span><br><span class=\"line\">doSomething();</span><br><span class=\"line\">const end = performance.now();</span><br><span class=\"line\">console.log(&quot;Call to doSomething took &quot; + (start - end) + &quot; milliseconds.&quot;);</span><br></pre></td></tr></table></figure>\n<p>二、<a href=\"https://stackoverflow.com/questions/47738344/does-javascript-slice-method-return-a-shallow-copy\" target=\"_blank\" rel=\"noopener\">Does javascript slice method return a shallow copy?</a><br>\n  mdn 上对 <code>slice()</code> 方法的介绍：</p>\n<blockquote>\n<p>The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included) where begin and end represent the index of items in that array. The original array will not be modified.</p>\n</blockquote>\n<p>  注意这里的浅复制指的是对数组中值的浅复制，而不是对整个数组的浅复制。如果是一个字符串数组，则修改新数组时，原数组不会改变；如果是对象数组，修改新数组对象值时，原数组也会发生变化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const animals = [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;];</span><br><span class=\"line\">const newAnimals = animals.slice(2);</span><br><span class=\"line\"></span><br><span class=\"line\">newAnimals[0].name = &apos;aaa&apos;;</span><br><span class=\"line\">console.log(newAnimals); // [&#123;name: &apos;aaa&apos;&#125;]</span><br><span class=\"line\">console.log(animals);    // [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;aaa&apos;&#125;]</span><br></pre></td></tr></table></figure>\n<p>  注意如果是重新赋值，则等于重新分配空间，不会改变原数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const animals = [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;];</span><br><span class=\"line\">const newAnimals = animals.slice(2);</span><br><span class=\"line\"></span><br><span class=\"line\">newAnimals[0] = &#123;name: &apos;aaa&apos;&#125;;</span><br><span class=\"line\">console.log(newAnimals); // [&#123;name: &apos;aaa&apos;&#125;]</span><br><span class=\"line\">console.log(animals);    // [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;]</span><br></pre></td></tr></table></figure>\n<h4 id=\"2019726\">2019/7/26</h4>\n<p>  应用场景：我们需要请求并更新菜单栏中任务的状态，如果一个请求完成立马更新会导致 React 频繁刷新，需要缓冲批处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; runInAction &#125; from &quot;mobx&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">let handlers: Array&lt;() =&gt; void&gt; = [];</span><br><span class=\"line\">const runHandlers = () =&gt; &#123;</span><br><span class=\"line\">  runInAction(() =&gt; &#123;</span><br><span class=\"line\">    handlers.forEach(f =&gt; f());</span><br><span class=\"line\">    handlers = [];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (const task of tasks) &#123;</span><br><span class=\"line\">  const &#123;data&#125; = await requestFn();</span><br><span class=\"line\">  </span><br><span class=\"line\">  handlers.push(() =&gt; &#123;</span><br><span class=\"line\">    // deal with data, update state</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if(handlers.length &gt; 30) &#123;</span><br><span class=\"line\">    runHandlers();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">runHandlers();</span><br></pre></td></tr></table></figure>\n<p>  上述代码主要是利用了自定义的 <code>handlers</code> 来暂存状态更新函数，之后使用 mobx 提供的 <code>runInAction</code> 执行函数并更新状态，更新状态都需要使用 <code>action</code> 函数， <code>runInAction</code> 接受一个代码块并在一个(匿名)操作中执行，有利于动态创建和执行操作，<code>runInAction(f) = action(f)()</code>。此外，必要时还可加上 <code>lodash.memoize(func,[resolver])</code>，记录主函数请求结果。</p>\n<blockquote>\n<p>For one-time-actions runInAction(name?, fn) can be used, which is sugar for action(name, fn)()</p>\n</blockquote>\n<h4 id=\"2019718\">2019/7/18</h4>\n<p>一、编程模式：<br>\n   首先先记住这几种编程模式的中文：Imperative Programming 是命令式编程，Declarative Programming 是声明式编程，Reactive Programming 是响应式编程。（流下了英文不好的泪水）<br>\n1）先看命令式编程和声明式编程的区别，直接上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 命令式编程 imperative programming</span><br><span class=\"line\">const array = [0,1,2,3,4,5];</span><br><span class=\"line\">const output = [];</span><br><span class=\"line\">for (let i = 0; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">  const tmp = array[i] * 2;</span><br><span class=\"line\">  output.push(tmp)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(output) // =&gt; [0,2,4,6,8,10]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明式编程 declarative programming</span><br><span class=\"line\">const array = [0,1,2,3,4,5];</span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">console.log(output) // =&gt; [0,2,3,6,8,10]</span><br></pre></td></tr></table></figure>\n<p>  很明显可以看到，命令式编程的关注点在于 how ，我们需要一步步告诉机器接下来要做什么，告诉他怎么去遍历一个数组，怎么去运算得到最后的结果，怎么去输出；声明式编程的关注点在于 what ，我们只关注最后的结果，由机器自己去摸索过程，如直接调用 <code>map</code> 函数，只告诉程序我们需要一个2倍输出。<br>\n2）接着看声明式编程和响应式编程的对比<br>\n  可以阅读：<a href=\"https://codepen.io/HunorMarton/post/imperative-vs-reactive\" target=\"_blank\" rel=\"noopener\">Imperative vs Reactive</a>，解释很清晰，比喻也很形象，但我觉得文章里的 Imperative 应该改成 Declarative 比较准确。继续沿用上面的例子，修改一下声明式编程的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明式编程 declarative programming</span><br><span class=\"line\">const array = [1,2];</span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">output.forEach(item =&gt; console.log(item)) // =&gt; 2 4</span><br><span class=\"line\">array.push(3);  // =&gt; no output </span><br><span class=\"line\">array.push(4);  // =&gt; no output</span><br></pre></td></tr></table></figure>\n<p>响应式编程的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Subject &#125; from `rxjs`;</span><br><span class=\"line\">let array = new Subject();</span><br><span class=\"line\">array.next(1);</span><br><span class=\"line\">array.next(2);</span><br><span class=\"line\"></span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">output.forEach(item =&gt; console.log(item)); // =&gt; 2 4</span><br><span class=\"line\"></span><br><span class=\"line\">array.next(3); // =&gt; 6</span><br><span class=\"line\">array.next(4); // =&gt; 8</span><br></pre></td></tr></table></figure>\n<p>  首先要注意的是，这两种方式中的 <code>map</code> ， <code>forEach</code> 等函数并不是一样的，内部实现机制是不同的。我们可以发现区别：在声明式编程中，如果在最后向原数组添加值，并不会打印出来，因为这是在 <code>console.log</code> 语句执行后发生的。但在响应式编程里，任何变化都可以被反应出来，它引入了一个<strong>异步数据流</strong>（asynchronous data streams）的概念，可以随时创建、更改或组合这些数据流，所以打印事件是一个 continuous observation case。<br>\n二、类库<br>\n<a href=\"https://github.com/bvaughn/react-virtualized\" target=\"_blank\" rel=\"noopener\">react-virtualized</a> 的轻量级版 <a href=\"https://github.com/bvaughn/react-window\" target=\"_blank\" rel=\"noopener\">react-window</a>，用于高效渲染长列表。</p>\n<h4 id=\"2019717\">2019/7/17</h4>\n<p>  如果我们在项目中需要请求很多图片，想要实现请求出错时继续发送请求，成功时返回数据，可以使用 <code>Promise</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fetchURL(url: string):Promise&lt;Blob&gt; &#123;</span><br><span class=\"line\">  return Axios.get(url, &#123;responeType: &quot;blob&quot;&#125;)</span><br><span class=\"line\">              .then( resp =&gt; Promise.resolve(resp.data) )</span><br><span class=\"line\">              .catch( () =&gt; fetchURL(url) )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后可以使用 <code>rxjs</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mergeMap, bufferTime, takeUntil &#125; from &quot;rxjs/operators&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">[url1,...,url10]</span><br><span class=\"line\">  .pipe(</span><br><span class=\"line\">    mergeMap( url =&gt; fetchURL(url).then( val =&gt; val )),</span><br><span class=\"line\">    bufferTime(10000)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .subscribe(&#123;</span><br><span class=\"line\">    next: resps =&gt; &#123;</span><br><span class=\"line\">      // do sth with resps:Blob[]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>  每次遇到 <code>rxjs</code> 都很头大，现在也没有发现一个比较完善清晰的教程，但它又真的很强大，后续要开专题好好学习记录这个东西。</p>\n<h4 id=\"2019716\">2019/7/16</h4>\n<p>一、今日阅读：<a href=\"https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\" target=\"_blank\" rel=\"noopener\">How to read an often-changing value from useCallback?</a><br>\n直接上官网代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  const textRef = useRef();</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    textRef.current = text; // Write it to the ref</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleSubmit = useCallback(() =&gt; &#123;</span><br><span class=\"line\">    const currentText = textRef.current; // Read it from the ref</span><br><span class=\"line\">    alert(currentText);</span><br><span class=\"line\">  &#125;, [textRef]); // Don&apos;t recreate handleSubmit like [text] would do</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   也就是说，当 <code>text</code> 的值经常发生变化时，即使 <code>handleSubmit</code> 用 <code>useCallback</code> 包裹了，还是会重新声明。解决办法是传入一个 <code>ref</code> 对象代替原始值。也可以写一个 custom hook ：<br>\n1）官网的版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function useEventCallback(fn, dependencies) &#123;</span><br><span class=\"line\">  const ref = useRef(() =&gt; &#123;</span><br><span class=\"line\">    throw new Error(&apos;Cannot call an event handler while rendering.&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ref.current = fn;</span><br><span class=\"line\">  &#125;, [fn, ...dependencies]);</span><br><span class=\"line\"></span><br><span class=\"line\">  return useCallback(() =&gt; &#123;</span><br><span class=\"line\">    const fn = ref.current;</span><br><span class=\"line\">    return fn();</span><br><span class=\"line\">  &#125;, [ref]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  // Will be memoized even if `text` changes:</span><br><span class=\"line\">  const handleSubmit = useEventCallback(() =&gt; &#123;</span><br><span class=\"line\">    alert(text);</span><br><span class=\"line\">  &#125;, [text]);</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2）导师的版本：（他来了，他带着代码又来了）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param callback</span><br><span class=\"line\"> * @param oRefs</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function useCallbackWithRefs&lt;</span><br><span class=\"line\">  Refs,</span><br><span class=\"line\">  Callback extends (...args: any[]) =&gt; void</span><br><span class=\"line\">&gt;(callback: (refs: Refs) =&gt; Callback, oRefs: Refs) &#123;</span><br><span class=\"line\">  const refs = useRef(oRefs);</span><br><span class=\"line\">  useEffect(</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">      refs.current = oRefs;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [oRefs]</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  return useCallback(</span><br><span class=\"line\">    (...args: any[]) =&gt; callback(refs.current)(...args),</span><br><span class=\"line\">    []</span><br><span class=\"line\">  ) as Callback;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 原先的 callback 也可以有参数</span><br><span class=\"line\">  const handleSubmit = useCallbackWithRefs(</span><br><span class=\"line\">    refs =&gt; (params: any) =&gt; &#123;</span><br><span class=\"line\">      // 要注意在函数内必须使用 `refs.xxx`，不能直接使用函数外部的任何变量 `xxx`</span><br><span class=\"line\">      console.log(refs.text);</span><br><span class=\"line\">  &#125;, &#123;text&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  总的来说，官网的实现是将 <code>callback</code> 作为 <code>ref</code> 对象，并作为 <code>useCallback</code> 的依赖，不会频繁改变；如果在函数 <code>handleSubmit</code> 中要访问外部变量 <code>text</code> ，直接使用 <code>test</code> 即可。第二种实现方式是把经常变化的值作为 <code>ref</code> 对象，返回值 <code>useCallback</code> 第一个参数是 <code>refs =&gt; callback</code> ，依赖是空数组；这时如果要在函数 <code>handleSubmit</code> 中要访问外部变量 <code>text</code> ，必须使用 <code>refs.test</code> ，否则访问的只是 <code>test</code> 的初始值。<br>\n  React 博大精深，接下来要好好研读一下这个 <a href=\"https://reactjs.org/docs/hooks-faq.html\" target=\"_blank\" rel=\"noopener\">FAQ</a>。<br>\n二、今日网址<br>\n  一个 <a href=\"https://www.emojicopy.com/\" target=\"_blank\" rel=\"noopener\">emoji copy</a> 网站，我们 👧 就是喜欢这些花里胡哨的东西。</p>\n<h4 id=\"2019715\">2019/7/15</h4>\n<p>  今天在项目中使用 React Hooks 又踩坑了，看来自己对这部分还是没有理解透彻。在使用 <code>useCallback</code> 和 <code>useEffect</code> 时，要注意第二个参数，也就是传入的 <code>[deps]</code>。如果使用 <code>useCallback(fn,[deps])</code> ， <code>[deps]</code> 应该包含函数 <code>fn</code> 所涉及的所有变量；如果使用 <code>useEffect(fn,[deps])</code> ， 当 <code>deps</code> 的值变化时，就会执行 <code>fn</code>，因此<code>[deps]</code> 不一定要包含函数 <code>fn</code> 所涉及的所有变量，而是应该传入会引起该函数执行的那些参数。<br>\n  今日踩坑记录：为了优化子组件，作为 <code>props</code> 的函数都使用 <code>useCallback</code> 包裹了，并传入了空数组作为第二个参数，表示没有依赖。但是函数中的运算需要用到组件中一个变量，如果没有将该变量作为 <code>deps</code> ，这个变量就会一直保持初始值，值并不会改变，运行结果就会与预期不符。（真的太蠢了，缓缓躺倒）</p>\n<h4 id=\"2019714\">2019/7/14</h4>\n<p>周末当然是约会啦。😍</p>\n<h4 id=\"2019713\">2019/7/13</h4>\n<p>一、今日阅读：<a href=\"https://stackoverflow.com/questions/53446020/how-to-compare-oldvalues-and-newvalues-on-react-hooks-useeffect\" target=\"_blank\" rel=\"noopener\">How to compare oldValues and newValues on React Hooks useEffect?</a><br>\n   React class 组件提供了 <code>ComponentDidUpdate</code> 之类的方法来获取到当前 <code>props</code> 和前一个 <code>props</code> ，并进行比较，决定是否进行更新。函数式组件只有 <code>useEffect</code> 函数来模仿生命周期函数，当我们需要获取组件先前的 <code>props</code> 时，可以使用下面的 custom hook ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function usePrevious(value) &#123;</span><br><span class=\"line\">  const ref = useRef();</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ref.current = value;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return ref.current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  之后在 <code>useEffect</code> 中使用上面的函数来模拟 <code>ComponentDidUpdate</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Component = (props) =&gt; &#123;</span><br><span class=\"line\">    const &#123;receiveAmount, sendAmount &#125; = props</span><br><span class=\"line\">    const prevAmount = usePrevious(&#123;receiveAmount, sendAmount&#125;);</span><br><span class=\"line\">    useEffect(() =&gt; &#123;</span><br><span class=\"line\">        if(prevAmount.receiveAmount !== receiveAmount) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         // process here</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(prevAmount.sendAmount !== sendAmount) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         // process here</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, [receiveAmount, sendAmount])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  有时候在 debug 时，我们想知道组件为什么会重新渲染，是那些 <code>props</code> 更新了，也可以使用上面的方法来获取 <code>prevProps</code>，并在函数组件最开始时写一个 <code>useEffect</code> 将参数都打印出来，使用 <code>===</code> 比较。</p>\n<h4 id=\"2019712\">2019/7/12</h4>\n<p>一、今日技能<br>\n  项目中经常会涉及到 JSON 字符串的解析，解析出错就扑街了，一般是用 <code>try {...} catch {...}</code> 包裹。今天导师在 code review 时建议我使用如下函数，该函数也可以覆盖空字符串的检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function safeJsonParse&lt;T&gt;(str): &#123; ok: true, value: T &#125; | &#123; ok: false &#125; &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ok: true,</span><br><span class=\"line\">      value: JSON.parse(str)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; catch &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ok: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二、今日阅读：<a href=\"https://imweb.io/topic/5b72d4ef15554e6d3409f817\" target=\"_blank\" rel=\"noopener\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a>。<br>\n  这一篇很好地梳理了进程、线程、浏览器<strong>多进程</strong>、浏览器内核<strong>多线程</strong>、JS单线程、JS运行机制的相关知识，很连贯，建议时不时回顾。简单记录几个知识点：<br>\n1）进程是CPU资源分配的最小单位，线程是CPU调度的最小单位。（想当年考操作系统的时候还背得滚瓜烂熟）<br>\n2）<strong>浏览器是多进程的</strong>，包括的主要进程有：</p>\n<ul>\n<li>Browser进程（浏览器的主进程，只有一个）</li>\n<li>浏览器渲染进程（浏览器内核，Renderer进程，渲染进程，内部是多线程的）：默认每个Tab一个进程</li>\n<li>第三方插件进程</li>\n<li>GPU进程：3D绘制</li>\n</ul>\n<p>3）重点是浏览器内核，它是多线程的，主要常驻线程有：</p>\n<ul>\n<li>GUI渲染线程：渲染页面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制，repaint 和 reflow 等。</li>\n<li>JS引擎线程：处理任务队列中的任务，与 GUI 渲染线程是互斥的。</li>\n<li>事件触发线程：控制事件循环，把事件添加到任务队列的末尾。</li>\n<li>定时触发线程：<code>setTimeout</code> 和 <code>setInterval</code>，同样也是计时完毕后添加到队列末尾。</li>\n<li>异步 http 请求线程</li>\n</ul>\n<p>4）Browser进程和浏览器内核之间是需要通信的<br>\n5）时间循环机制 <code>Event Loop</code> ：JS分为同步任务和异步任务，同步任务都会在主线程上运行，形成一个执行栈；主线程之外，由事件触发线程管理一个<strong>任务队列/事件队列</strong>，异步任务的运行结果会被添加到任务队列中。一旦执行栈中所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到执行栈中开始执行。<br>\n6）进阶：macrotask / task 和 microtask/ job。ES6中的 <code>Promise</code> 就属于 microtask 微任务 ，而主代码块，事件队列中的时间如 <code>setTimeout</code> 和 <code>setInterval</code> 就属于 macrotask 宏任务。总结的运行机制就是：</p>\n<ul>\n<li>执行宏任务。（从执行栈中获取，如果没有就从事件队列中获取）</li>\n<li>执行过程中如果遇到微任务，就添加到微任务队列 Job Queues 中。（作者猜测这个队列由JS引擎线程维护，因为是在主线程下无缝执行的）</li>\n<li>宏任务执行完毕后，立即依次执行当前微任务队列中所有微任务。</li>\n<li>检查渲染，由 GUI 线程接管。</li>\n<li>渲染完毕后，由 JS 引擎线程接管，从时间队列中获取并执行下一个宏任务。</li>\n</ul>\n<p>7）在第六点中提到的是一个进阶的概念，对应一道题目，如果代码中依次有 <code>setTimeout</code> 和 <code>Promise</code> ，是会先打印出 <code>Promise</code> 的执行结果的。</p>\n<h4 id=\"2019711\">2019/7/11</h4>\n<p>   React 16.8 提出了 <code>hook</code> 的概念，函数式组件也可以拥有自己的状态。现在的工作项目已经摒弃了 <code>class</code> ，改用函数式组件，正在慢慢摸索中。今天在腾讯<a href=\"http://imweb.io/\" target=\"_blank\" rel=\"noopener\">IMWeb前端博客</a>中看到了两篇介绍 <code>React hook</code> 的文章，受益匪浅，简单记录一下。<br>\n一、<a href=\"https://imweb.io/topic/5cd845cadcd62f86299fcd76\" target=\"_blank\" rel=\"noopener\">react hook——你可能不是“我”所认识的useEffect</a><br>\n  这篇介绍了 <code>useEffect</code> 这个API，用它模拟了class组件的生命周期函数。<code>useEffect</code> 用于执行副作用，相当于 <code>ComponentDidMount</code> 和 <code>ComponentDidUpdate</code>。该API有两个参数和一个返回值。第一个参数是一个副作用函数，返回值是清除函数，相当于 <code>ComponentWillUnmount</code>，每一次 <code>render</code> 都会执行副作用和清除上一次副作用。<strong>第二个参数是一个数组，传入的是副作用函数所需要的依赖，当任一依赖更新时，会重新生成一个新的副作用并执行；如果传入一个空数组，没有依赖，只会执行一次，相当于 <code>ComponentDidMount</code>；如果不传，就是没有说明自己有没有依赖（注意是不知道有没有，不是没有！），每次 <code>render</code> 时就执行，相当于 <code>ComponentDidUpdate</code> 。</strong><br>\n   最后还讲了 <code>useEffect</code> 和 <code>useLayoutEffect</code> 的区别，简单来说前者是异步的，后者是同步的。还没好好深入这部分，TODO。<br>\n二、<a href=\"https://imweb.io/topic/5d1e3657f7b5692b080f2651\" target=\"_blank\" rel=\"noopener\">可能你的react函数组件从来没有优化过</a><br>\n  优化问题真是我一个痛点。这篇文章很清楚地解释了 <code>Hooks</code> 一些可用于组件优化的API。强推！<br>\n   特别地，文章介绍了当函数组件中传入的 <code>props</code> 值为函数时，由于每一次执行或重新执行，作用域里面一切都是重新开始，函数不是简单数据类型，不能画上等号，子组件都会重新渲染。针对这个问题文章提出了几种解决办法：<br>\n1） 作为 <code>props</code> 的函数在函数组件外定义，函数组件用 <code>React.memo()</code> 包裹。<br>\n   <code>React.memo()</code> 类似于 <code>PureComponent</code> 和 <code>ComponentDidUpdate</code> ，如果函数组件的 <code>props</code> 值都一样，就会跳过该组件的执行，减少不必要的渲染，实现性能优化。<br>\n2） 作为 <code>props</code> 的函数在函数组件内定义，使用<code>useCallBack</code> 或 <code>useMemo</code>包裹，函数组件用 <code>React.memo()</code> 包裹。<br>\n   <code>useCallback(() =&gt; {}, [deps])</code> 返回一个函数，当 <code>deps</code> 不变时（如传入空数组，表示没有依赖），都是同一个函数。<code>const a = useMemo(() =&gt; memorizeValue, [deps])</code>，当 <code>deps</code> 不变时，<code>a</code> 的值还是上次的 <code>memorizeValue</code>，省去了重新计算的过程。<br>\n   注意当 <code>memorizeValue</code> 是一个函数时，<code>useCallback(fn, inputs) &lt;=&gt; useMemo(() =&gt; fn, inputs)</code>。</p>\n<h4 id=\"2019710\">2019/7/10</h4>\n<p>  今天在项目中接触到了 <code>symbol</code>，鉴于之前一直没有注意这个数据类型，在今天补上。 <code>symbol</code> 是 ES6 新增的<strong>基本</strong>数据类型。它的使用如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const s1 = Symbol();</span><br><span class=\"line\">const s2 = Symbol();</span><br><span class=\"line\">console.log(s1 === s2); // false</span><br><span class=\"line\"></span><br><span class=\"line\">const s3 = new Symbol() // TypeError: Symbol is not a constructor</span><br><span class=\"line\">Symbol(&quot;foo&quot;) === Symbol(&quot;foo&quot;); // false</span><br></pre></td></tr></table></figure>\n<p><code>Symbol()</code> 返回的每个 <code>symbol</code> 值都是唯一的，可以接受一个字符串作为参数。它最常被用于对象属性的标识符，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;&#125;</span><br><span class=\"line\">const foo = Symbol(&quot;foo&quot;)</span><br><span class=\"line\">obj[foo] = &quot;foo&quot;</span><br><span class=\"line\">obj.bar = &quot;bar&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(obj); // &#123; bar: &quot;bar&quot; , Symbol(foo): &quot;foo&quot;&#125;</span><br><span class=\"line\">console.log(foo in obj); // true</span><br><span class=\"line\">console.log(obj[foo]); // foo</span><br><span class=\"line\">console.log(Object.keys(obj)); // [&quot;bar&quot;]</span><br><span class=\"line\">console.log(Object.getOwnPropertySymbols(obj)) // [Symbol(foo)]</span><br></pre></td></tr></table></figure>\n<p>也就是说， <code>Object.key()</code> 不会返回 <code>symbol</code> 值，同理，<code>Object.getOwnPropertyNames()</code>、<code>for..in</code>、<code>for...of</code> 也不会返回。<code>JSON.stringify()</code> 也会忽略：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.stringify(&#123;[Symbol(&apos;foo&apos;)]: &apos;foo&apos;&#125;);                 </span><br><span class=\"line\">// &apos;&#123;&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p><code>Symbol</code> 还有两个方法。 <code>Symbol.for(key)</code> 是根据指定的 <code>key</code> 搜索现有的 <code>symbol</code> 并返回, 如果找不到，会使用 <code>key</code> 在全局的 <code>symbol</code> 注册表中创建一个新的 <code>symbol</code> 。<code>Symbol.keyFor(sym)</code> 是在全局注册表中检索，返回共享的 <code>symbol key</code> 。</p>\n<h4 id=\"201979\">2019/7/9</h4>\n<p>一个不好的编程习惯：让函数在内部获取自己所需的依赖。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个可复用函数</span><br><span class=\"line\">function doSomething(key: string) &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;Button</span><br><span class=\"line\">            loading = &#123;key===&quot;str1&quot;? Compoment1 : Compoment2&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">            button</span><br><span class=\"line\">        &lt;/Button&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>lodaing</code> 所需的组件应该是作为函数参数传入的，不然如果我们新增了一个 <code>key</code>，很容易忽略了该地方的修改。这个观点类似于依赖反转。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>前言</h4>\n<p>📝 recap and cheat sheet ，记录每天学到的知识/想法。<br>\n🔊 每日一问：今天你比昨天更博学了吗？</p>\n<h4>2019/8/25</h4>\n<p>今日踩坑记录：<br>\n展开语法（spread syntax）只能取到 enumerable properties。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const imageData = new ImageData(200, 100);</span><br><span class=\"line\">// ImageData &#123; width: 200, height: 100, data: Uint8ClampedArray[80000] &#125;</span><br><span class=\"line\">const result = &#123;...imageData&#125;</span><br><span class=\"line\">// result 只会包含 data ，不能取到 width 和 height</span><br></pre></td></tr></table></figure>\n<h4>2019/8/24</h4>\n<p>避免组件重新挂载，可以使用事件的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class BussinessProvider &#123;</span><br><span class=\"line\">  sp$ = new Subject&lt;&#123;url: string, slic: string&#125;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Canvas &#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">     this.props.sp$.pipe(takeUntil(this.unmount$)).subscribe(ev =&gt; &#123;</span><br><span class=\"line\">        if (ev.url === this.url) &#123;</span><br><span class=\"line\">           this.handleSuperPixelChange(ev.slic)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>2019/8/24</h4>\n<p>一、Promise</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">  // do something...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(onFulfilled[, onRejected]);</span><br><span class=\"line\">promise.then(value =&gt; &#123;</span><br><span class=\"line\">  // fulfillment</span><br><span class=\"line\">&#125;, reason =&gt; &#123;</span><br><span class=\"line\">  // rejection</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.catch(onRejected);</span><br><span class=\"line\">promise.catch(function(reason) &#123;</span><br><span class=\"line\">   // rejection</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>简单来说，<code>reject(value)</code> 可以被 <code>promise.then</code> 第二个函数参数捕获，也可以被 <code>promise.catch</code> 捕获。如果两者同时存在，会被 <code>promise.then</code> 第二个函数参数捕获，<code>promise.catch</code> 无输出。</p>\n<p>下载图片的典型例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function loadImage(url) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    let img = new Image();</span><br><span class=\"line\">    // img.onload = () =&gt; resolve(img)</span><br><span class=\"line\">    img.addEventListener(&apos;load&apos;, e =&gt; resolve(img));</span><br><span class=\"line\">    // img.onerror = () =&gt; reject(XXX)</span><br><span class=\"line\">    img.addEventListener(&apos;error&apos;, () =&gt; &#123;</span><br><span class=\"line\">      reject(new Error(`Failed to load image&apos;s URL: $&#123;url&#125;`));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    img.src = url;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">loadImage(&apos;http://thecatapi.com/api/images/get?format=src&amp;type=jpg&amp;size=small&apos;)</span><br><span class=\"line\">  .then(img =&gt; document.getElementById(&apos;image-holder&apos;).appendChild(img))</span><br><span class=\"line\">  .catch(error =&gt; console.error(error));</span><br></pre></td></tr></table></figure>\n<p>二、await<br>\n<code>[rv] = await expression</code>:</p>\n<blockquote>\n<p>TL;DR returns the fulfilled value of the promise,<br>\nThe await expression causes async function execution to pause until a Promise is settled, that is fulfilled or rejected, and to resume execution of the async function after fulfillment. When resumed, the value of the await expression is that of the fulfilled Promise.<br>\nIf the Promise is rejected, the await expression throws the rejected value.<br>\nIf the value of the expression following the await operator is not a Promise, it’s converted to a resolved Promise.</p>\n</blockquote>\n<h4>2019/8/23</h4>\n<p><code>String.prototype.localeCompare()</code></p>\n<blockquote>\n<p>return a number, indicating whether the reference string comes before, after or is the same as the compareString in sort order. Returns one of three values:<br>\n-1: if the reference string is sorted before the compareString<br>\n0: if the two strings are equal<br>\n1: if the reference string is sorted after the compareString</p>\n</blockquote>\n<p><code>Array.prototype.sort()</code></p>\n<blockquote>\n<p>sorts the elements of an array in place and returns the sorted array.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">items.sort((a,b) =&gt; a.localeCompare(b))</span><br></pre></td></tr></table></figure>\n<h4>2019/8/21</h4>\n<p>今日阅读：<br>\n<a href=\"https://stackoverflow.com/questions/52499617/what-is-the-difference-between-npm-install-and-npm-ci\" target=\"_blank\" rel=\"noopener\">What is the difference between “npm install” and “npm ci”?</a><br>\n<a href=\"https://medium.com/coinmonks/everything-you-wanted-to-know-about-package-lock-json-b81911aa8ab8\" target=\"_blank\" rel=\"noopener\">Everything You Wanted To Know About package-lock.json But Were Too Afraid To Ask</a></p>\n<h4>2019/8/20</h4>\n<p>模仿 react hook <code>useState</code> 的第二个参数：<br>\n  因为在 jest 测试中某个函数的参数是 <code>useState</code> 的第二个参数，写了一个替代，不过不确定是否有错。😳</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// for example</span><br><span class=\"line\">const [str,setStr] = useState&lt;string[]&gt;([]);</span><br><span class=\"line\"></span><br><span class=\"line\">// fake setStr</span><br><span class=\"line\">let str:string[] = [];</span><br><span class=\"line\">const setStr = (val: string[] | ((prev:string[]) =&gt; string[])) =&gt; &#123;</span><br><span class=\"line\">  if (typeof val === &quot;object&quot;) &#123;</span><br><span class=\"line\">    str = val;</span><br><span class=\"line\">  &#125; else if (typeof val === &quot;function&quot;) &#123;</span><br><span class=\"line\">    str = val(str)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>2019/8/19</h4>\n<p>今日阅读：<a href=\"https://searchenginelaws.com/seo/what-is-rel-noopener-noreferrer-tag/\" target=\"_blank\" rel=\"noopener\">What is rel=noopener noreferrer link</a><br>\n  使用 <code>a</code> 标签，且属性 <code>target=&quot;_blank&quot;</code> 时，需要加上 <code>rel=&quot;noopener noreferrer&quot;</code> 。可以防止新窗口利用 <code>window.opener</code> 的特性窃取原窗口信息。具体而言，如果 window A 打开了 window B，那么 B.opener 会返回 A。如果加上 <code>rel=&quot;noopener&quot;</code> ，会返回 null 。</p>\n<h4>2019/8/12</h4>\n<p>一、download files using axios</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios from &quot;axios&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">axios.get(url,&#123;</span><br><span class=\"line\">  responseType: &apos;blob&apos;, // important</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    &apos;Authorization&apos;: AuthStr </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).then(resp =&gt; &#123;</span><br><span class=\"line\">  const &#123;data&#125; = resp;</span><br><span class=\"line\">  const file = new File([data],&quot;data.txt&quot;);</span><br><span class=\"line\">  const objectURL = URL.createObjectURL(file);</span><br><span class=\"line\">  const a = document.createElement(&quot;a&quot;);</span><br><span class=\"line\">  a.href = objectURL;</span><br><span class=\"line\">  a.download = &quot;data.txt&quot;;</span><br><span class=\"line\">  a.click();</span><br><span class=\"line\">  URL.revokeObjectURL(objectURL);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>  如果是单次点击下载多个文件，Chrome 只会弹出一个弹窗下载最后一个文件。这个时候可以加上 <code>setTimeout</code> ，触发多次下载，或是加上 <code>a.target = &quot;_blank&quot;</code> ，打开多个新窗口。<br>\n二、curl<br>\n查看命令：<br>\n<code>curl --help</code><br>\n-H 指定Header：<br>\n<code>curl -H &quot;Authorization: XXXXXXXX&quot; URL</code><br>\n<code>curl POST -d data -H &quot;Authorization: XXXXXXXX&quot; URL</code></p>\n<h4>2019/8/9</h4>\n<p>一、<a href=\"https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/\" target=\"_blank\" rel=\"noopener\">useRef vs useState: Should we re-render or not?</a><br>\n<img src=\"FE_20190809.png\" alt=\"FE_20190808\"><br>\n二、Hooks 监听键盘事件<br>\nkeyCode: <a href=\"https://keycode.info/\" target=\"_blank\" rel=\"noopener\">https://keycode.info/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function useKeyPress(targetKey) &#123;</span><br><span class=\"line\">  const [keyPressed, setKeyPressed] = useState(false);</span><br><span class=\"line\"></span><br><span class=\"line\">  function downHandler(&#123; key &#125;) &#123;</span><br><span class=\"line\">    if (key === targetKey) &#123;</span><br><span class=\"line\">      setKeyPressed(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  const upHandler = (&#123; key &#125;) =&gt; &#123;</span><br><span class=\"line\">    if (key === targetKey) &#123;</span><br><span class=\"line\">      setKeyPressed(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    window.addEventListener(&apos;keydown&apos;, downHandler);</span><br><span class=\"line\">    window.addEventListener(&apos;keyup&apos;, upHandler);</span><br><span class=\"line\">    return () =&gt; &#123;</span><br><span class=\"line\">      window.removeEventListener(&apos;keydown&apos;, downHandler);</span><br><span class=\"line\">      window.removeEventListener(&apos;keyup&apos;, upHandler);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  return keyPressed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>2019/8/8</h4>\n<p>  工程中经常会看到 CI/CD 的概念。CI 指的是持续集成，侧重于简化发布准备工作的实践，比如自动测试；CD 指的是持续交付，意味着不仅让测试自动化，让发布流程也自动化了。更多概念对比可以参考：<a href=\"https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment\" target=\"_blank\" rel=\"noopener\">Continuous integration VS continuous delivery VS continuous deployment</a><br>\n  下面这个图很清晰地描述了三者的不同：<br>\n<img src=\"FE_20190808.png\" alt=\"FE_20190808\"><br>\n  在 gitlab 上的实践可以参考：<a href=\"https://mp.weixin.qq.com/s/z2f1i2FgrVGofQR6nKTd1A\" target=\"_blank\" rel=\"noopener\">基于 GitLab CI/CD 的自动化构建、发布实践</a></p>\n<h4>2019/8/7</h4>\n<p>Typescript: <a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions\" target=\"_blank\" rel=\"noopener\">Discriminated Unions</a><br>\n  当我们某个参数可能有多个类型，而这些类型中又有公共的属性时，就可以使用这种形式约束。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Each interface has a kind property with a different string literal type. </span><br><span class=\"line\">// The kind property is called the discriminant or tag. </span><br><span class=\"line\">interface Square &#123;</span><br><span class=\"line\">    kind: &quot;square&quot;;</span><br><span class=\"line\">    size: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Rectangle &#123;</span><br><span class=\"line\">    kind: &quot;rectangle&quot;;</span><br><span class=\"line\">    width: number;</span><br><span class=\"line\">    height: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Circle &#123;</span><br><span class=\"line\">    kind: &quot;circle&quot;;</span><br><span class=\"line\">    radius: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// put the interfaces into a union</span><br><span class=\"line\">type Shape = Square | Rectangle | Circle;</span><br><span class=\"line\"></span><br><span class=\"line\">// use the discriminated union</span><br><span class=\"line\">function area(s: Shape) &#123;</span><br><span class=\"line\">    switch (s.kind) &#123;</span><br><span class=\"line\">        case &quot;square&quot;: return s.size * s.size;</span><br><span class=\"line\">        case &quot;rectangle&quot;: return s.height * s.width;</span><br><span class=\"line\">        case &quot;circle&quot;: return Math.PI * s.radius ** 2;</span><br><span class=\"line\">        default: return assertNever(s); // error here if there are missing cases</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Exhaustiveness checking </span><br><span class=\"line\">function assertNever(x: never): never &#123;</span><br><span class=\"line\">    throw new Error(&quot;Unexpected object: &quot; + x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>2019/8/6</h4>\n<p>Stack Overflow: <a href=\"https://stackoverflow.com/questions/54069253/usestate-set-method-not-reflecting-change-immediately\" target=\"_blank\" rel=\"noopener\">useState set method not reflecting change immediately.</a><br>\n  今天在实践中发现，<code>setState</code> 后马上打印，并不会取到更新后的值。查阅资料后发现这个函数是一个异步的函数，不会立即更新，但会触发重新渲染。如下：<br>\n<img src=\"FE_20190806.png\" alt=\"FE_20190806\"></p>\n<h4>2019/8/1</h4>\n<p>一、<a href=\"https://javascript.info/fetch-api\" target=\"_blank\" rel=\"noopener\">Fetch API</a><br>\n  用 fetch 来请求网络资源，可以配置不同的参数来解决缓存、跨域等问题，如下示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 不缓存请求结果 </span><br><span class=\"line\">// https://stackoverflow.com/questions/29246444/fetch-how-do-you-make-a-non-cached-request</span><br><span class=\"line\">const headers = new Headers();</span><br><span class=\"line\">headers.append(&quot;pragma&quot;, &quot;no-cache&quot;);</span><br><span class=\"line\">headers.append(&quot;cache-control&quot;, &quot;no-store&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 完全忽略 http-cache ，每次都从服务器请求数据</span><br><span class=\"line\">// https://developer.mozilla.org/en-US/docs/Web/API/Request/cache</span><br><span class=\"line\">const cache: RequestCache = &quot;no-store&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 请求模式，若有的请求会因为 cors 而失败，可以设置为 &quot;no-cors&quot;</span><br><span class=\"line\">// https://developer.mozilla.org/en-US/docs/Web/API/Request/mode</span><br><span class=\"line\">const mode: RequestMode = needCors ? &quot;cors&quot; : &quot;no-cors&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">await fetch(url. &#123;headers, cache, mode&#125;)</span><br><span class=\"line\">  .then(res =&gt; res.blob())</span><br><span class=\"line\">  .then(blob =&gt; &#123;</span><br><span class=\"line\">    // doSomething with blob</span><br><span class=\"line\">    const url = URL.createObjectURL(blob)</span><br><span class=\"line\">    let a = document.createElement(&apos;a&apos;)</span><br><span class=\"line\">    a.download = &apos;example.zip&apos;</span><br><span class=\"line\">    a.href = url</span><br><span class=\"line\">    document.body.appendChild(a)</span><br><span class=\"line\">    a.click()</span><br><span class=\"line\">    document.body.removeChild(a)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(err =&gt; &#123;</span><br><span class=\"line\">    console.log(err)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .finally(() =&gt; &#123;</span><br><span class=\"line\">    // doSomething</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>  关于 <code>res.blob()</code> ，可以参考知乎上<a href=\"https://zhuanlan.zhihu.com/p/32909043\" target=\"_blank\" rel=\"noopener\">谈一谈 Fetch API 中的 “res.blob()”</a>；也可以参考 <a href=\"https://github.github.io/fetch/\" target=\"_blank\" rel=\"noopener\">fetch documentation</a> ，这一篇比较详细，也提供了较多其他的例子。<br>\n关于浏览器缓存问题，Medium 上这篇 <a href=\"https://medium.com/@codebyamir/a-web-developers-guide-to-browser-caching-cc41f3b73e7c\" target=\"_blank\" rel=\"noopener\">A Web Developer’s Guide to Browser Caching</a> 写得不错。如果存在代理服务器，即使我们设置了 <code>mode: 'no-store'</code> ，代理服务器也会缓存。为了避免这个情况，我们可以在每次发送请求时构造新的 URL ，加上时间戳 <code>?t=Date.now()</code> 。🐮🍺<br>\n二、Jest<br>\n  我们在使用 jest 测试时，有时候需要引入一些外部文件/外部变量，如从 <code>config.json</code> 文件中引入某个变量。为了在测试文件中可以访问到该变量，我们可以在 <code>jest.config.js</code> 中配置全局变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  globals: &#123;</span><br><span class=\"line\">    API_BASE: &quot;&quot;,</span><br><span class=\"line\">    DATA_API: &quot;&quot;,</span><br><span class=\"line\">    TRACK_API: &quot;&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  setupFiles: [&quot;./jestSetup.ts&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  由于 <code>globals</code> 只支持 JSON 格式的变量，如果我们需要定义全局函数，则可以使用 <code>setupFiles</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// jestSetup.ts</span><br><span class=\"line\">(global as any).fn= () =&gt; &#123;&#125;;</span><br><span class=\"line\">(global as any).variable = &quot;XXX&quot;;</span><br></pre></td></tr></table></figure>\n<h4>2019/7/31</h4>\n<p>1）<code>position: fixed</code> 和 flex 布局是不能同时起作用的。绝对布局脱离文档流，不会参与到 flex layout 中。如果想实现左侧菜单栏，右侧内容，两者不同时滚动（菜单栏 fixed），但菜单栏的大小可以改变（flex 父布局）。可以让父容器是 flex 布局，左侧菜单栏和右侧内容区域都是 flex element ， 菜单栏内部再有一个 <code>position: fixed</code> 的 div 。<br>\n2）如果想让 <code>position: fixed</code> 的元素相对父容器定位，可以给父容器增加 CSS 属性 <code>transform: translate(0,0)</code> 。参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">MDN - position</a></p>\n<blockquote>\n<p>fixed: It is positioned relative to the initial containing block established by the viewport, except when one of its ancestors has a transform, perspective, or filter property set to something other than none.</p>\n</blockquote>\n<h4>2019/7/30</h4>\n<p><code>useEffect</code> 中的异步请求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 错误写法， return 必须是 cleanup function</span><br><span class=\"line\">useEffect(async () =&gt; &#123;</span><br><span class=\"line\">  const newVal = await asyncCall();</span><br><span class=\"line\">  setVal(newVal);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 正确写法</span><br><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  asyncCall().then(resp =&gt; setVal(resp.data));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>好文共享：<a href=\"https://www.robinwieruch.de/react-hooks-fetch-data/\" target=\"_blank\" rel=\"noopener\">How to fetch data with React Hooks?</a>，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  async function fetchMyAPI() &#123;</span><br><span class=\"line\">    let url = &apos;http://something/&apos; + productId;</span><br><span class=\"line\">    let config = &#123;&#125;;</span><br><span class=\"line\">    const response = await myFetch(url);</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  fetchMyAPI();</span><br><span class=\"line\">&#125;, [productId]);</span><br></pre></td></tr></table></figure>\n<p>如果要保证请求按顺序发出，可以采用如下写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(() =&gt; &#123;</span><br><span class=\"line\">  let didCancel = false;</span><br><span class=\"line\"></span><br><span class=\"line\">  async function fetchMyAPI() &#123;</span><br><span class=\"line\">    let url = &apos;http://something/&apos; + productId;</span><br><span class=\"line\">    let config = &#123;&#125;;</span><br><span class=\"line\">    const response = await myFetch(url);</span><br><span class=\"line\">    if (!didCancel) &#123; // Ignore if we started fetching something else</span><br><span class=\"line\">      console.log(response);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">  fetchMyAPI();</span><br><span class=\"line\">  return () =&gt; &#123; didCancel = true; &#125;; // Remember if we start fetching something else</span><br><span class=\"line\">&#125;, [productId]);</span><br></pre></td></tr></table></figure>\n<h4>2019/7/29</h4>\n<p>一、<a href=\"https://stackoverflow.com/questions/30795525/performance-now-vs-date-now\" target=\"_blank\" rel=\"noopener\">performance.now() vs Date.now()</a><br>\n  在程序中打印执行时间时，使用 <code>performance.now(）</code> 更准确。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const start = performance.now();</span><br><span class=\"line\">doSomething();</span><br><span class=\"line\">const end = performance.now();</span><br><span class=\"line\">console.log(&quot;Call to doSomething took &quot; + (start - end) + &quot; milliseconds.&quot;);</span><br></pre></td></tr></table></figure>\n<p>二、<a href=\"https://stackoverflow.com/questions/47738344/does-javascript-slice-method-return-a-shallow-copy\" target=\"_blank\" rel=\"noopener\">Does javascript slice method return a shallow copy?</a><br>\n  mdn 上对 <code>slice()</code> 方法的介绍：</p>\n<blockquote>\n<p>The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included) where begin and end represent the index of items in that array. The original array will not be modified.</p>\n</blockquote>\n<p>  注意这里的浅复制指的是对数组中值的浅复制，而不是对整个数组的浅复制。如果是一个字符串数组，则修改新数组时，原数组不会改变；如果是对象数组，修改新数组对象值时，原数组也会发生变化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const animals = [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;];</span><br><span class=\"line\">const newAnimals = animals.slice(2);</span><br><span class=\"line\"></span><br><span class=\"line\">newAnimals[0].name = &apos;aaa&apos;;</span><br><span class=\"line\">console.log(newAnimals); // [&#123;name: &apos;aaa&apos;&#125;]</span><br><span class=\"line\">console.log(animals);    // [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;aaa&apos;&#125;]</span><br></pre></td></tr></table></figure>\n<p>  注意如果是重新赋值，则等于重新分配空间，不会改变原数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const animals = [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;];</span><br><span class=\"line\">const newAnimals = animals.slice(2);</span><br><span class=\"line\"></span><br><span class=\"line\">newAnimals[0] = &#123;name: &apos;aaa&apos;&#125;;</span><br><span class=\"line\">console.log(newAnimals); // [&#123;name: &apos;aaa&apos;&#125;]</span><br><span class=\"line\">console.log(animals);    // [&#123;name: &apos;ant&apos;&#125;, &#123;name: &apos;bison&apos;&#125;, &#123;name: &apos;camel&apos;&#125;]</span><br></pre></td></tr></table></figure>\n<h4>2019/7/26</h4>\n<p>  应用场景：我们需要请求并更新菜单栏中任务的状态，如果一个请求完成立马更新会导致 React 频繁刷新，需要缓冲批处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; runInAction &#125; from &quot;mobx&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">let handlers: Array&lt;() =&gt; void&gt; = [];</span><br><span class=\"line\">const runHandlers = () =&gt; &#123;</span><br><span class=\"line\">  runInAction(() =&gt; &#123;</span><br><span class=\"line\">    handlers.forEach(f =&gt; f());</span><br><span class=\"line\">    handlers = [];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">for (const task of tasks) &#123;</span><br><span class=\"line\">  const &#123;data&#125; = await requestFn();</span><br><span class=\"line\">  </span><br><span class=\"line\">  handlers.push(() =&gt; &#123;</span><br><span class=\"line\">    // deal with data, update state</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if(handlers.length &gt; 30) &#123;</span><br><span class=\"line\">    runHandlers();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">runHandlers();</span><br></pre></td></tr></table></figure>\n<p>  上述代码主要是利用了自定义的 <code>handlers</code> 来暂存状态更新函数，之后使用 mobx 提供的 <code>runInAction</code> 执行函数并更新状态，更新状态都需要使用 <code>action</code> 函数， <code>runInAction</code> 接受一个代码块并在一个(匿名)操作中执行，有利于动态创建和执行操作，<code>runInAction(f) = action(f)()</code>。此外，必要时还可加上 <code>lodash.memoize(func,[resolver])</code>，记录主函数请求结果。</p>\n<blockquote>\n<p>For one-time-actions runInAction(name?, fn) can be used, which is sugar for action(name, fn)()</p>\n</blockquote>\n<h4>2019/7/18</h4>\n<p>一、编程模式：<br>\n   首先先记住这几种编程模式的中文：Imperative Programming 是命令式编程，Declarative Programming 是声明式编程，Reactive Programming 是响应式编程。（流下了英文不好的泪水）<br>\n1）先看命令式编程和声明式编程的区别，直接上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 命令式编程 imperative programming</span><br><span class=\"line\">const array = [0,1,2,3,4,5];</span><br><span class=\"line\">const output = [];</span><br><span class=\"line\">for (let i = 0; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">  const tmp = array[i] * 2;</span><br><span class=\"line\">  output.push(tmp)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(output) // =&gt; [0,2,4,6,8,10]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明式编程 declarative programming</span><br><span class=\"line\">const array = [0,1,2,3,4,5];</span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">console.log(output) // =&gt; [0,2,3,6,8,10]</span><br></pre></td></tr></table></figure>\n<p>  很明显可以看到，命令式编程的关注点在于 how ，我们需要一步步告诉机器接下来要做什么，告诉他怎么去遍历一个数组，怎么去运算得到最后的结果，怎么去输出；声明式编程的关注点在于 what ，我们只关注最后的结果，由机器自己去摸索过程，如直接调用 <code>map</code> 函数，只告诉程序我们需要一个2倍输出。<br>\n2）接着看声明式编程和响应式编程的对比<br>\n  可以阅读：<a href=\"https://codepen.io/HunorMarton/post/imperative-vs-reactive\" target=\"_blank\" rel=\"noopener\">Imperative vs Reactive</a>，解释很清晰，比喻也很形象，但我觉得文章里的 Imperative 应该改成 Declarative 比较准确。继续沿用上面的例子，修改一下声明式编程的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 声明式编程 declarative programming</span><br><span class=\"line\">const array = [1,2];</span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">output.forEach(item =&gt; console.log(item)) // =&gt; 2 4</span><br><span class=\"line\">array.push(3);  // =&gt; no output </span><br><span class=\"line\">array.push(4);  // =&gt; no output</span><br></pre></td></tr></table></figure>\n<p>响应式编程的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Subject &#125; from `rxjs`;</span><br><span class=\"line\">let array = new Subject();</span><br><span class=\"line\">array.next(1);</span><br><span class=\"line\">array.next(2);</span><br><span class=\"line\"></span><br><span class=\"line\">const output = array.map(item =&gt; item * 2);</span><br><span class=\"line\">output.forEach(item =&gt; console.log(item)); // =&gt; 2 4</span><br><span class=\"line\"></span><br><span class=\"line\">array.next(3); // =&gt; 6</span><br><span class=\"line\">array.next(4); // =&gt; 8</span><br></pre></td></tr></table></figure>\n<p>  首先要注意的是，这两种方式中的 <code>map</code> ， <code>forEach</code> 等函数并不是一样的，内部实现机制是不同的。我们可以发现区别：在声明式编程中，如果在最后向原数组添加值，并不会打印出来，因为这是在 <code>console.log</code> 语句执行后发生的。但在响应式编程里，任何变化都可以被反应出来，它引入了一个<strong>异步数据流</strong>（asynchronous data streams）的概念，可以随时创建、更改或组合这些数据流，所以打印事件是一个 continuous observation case。<br>\n二、类库<br>\n<a href=\"https://github.com/bvaughn/react-virtualized\" target=\"_blank\" rel=\"noopener\">react-virtualized</a> 的轻量级版 <a href=\"https://github.com/bvaughn/react-window\" target=\"_blank\" rel=\"noopener\">react-window</a>，用于高效渲染长列表。</p>\n<h4>2019/7/17</h4>\n<p>  如果我们在项目中需要请求很多图片，想要实现请求出错时继续发送请求，成功时返回数据，可以使用 <code>Promise</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fetchURL(url: string):Promise&lt;Blob&gt; &#123;</span><br><span class=\"line\">  return Axios.get(url, &#123;responeType: &quot;blob&quot;&#125;)</span><br><span class=\"line\">              .then( resp =&gt; Promise.resolve(resp.data) )</span><br><span class=\"line\">              .catch( () =&gt; fetchURL(url) )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后可以使用 <code>rxjs</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mergeMap, bufferTime, takeUntil &#125; from &quot;rxjs/operators&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">[url1,...,url10]</span><br><span class=\"line\">  .pipe(</span><br><span class=\"line\">    mergeMap( url =&gt; fetchURL(url).then( val =&gt; val )),</span><br><span class=\"line\">    bufferTime(10000)</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .subscribe(&#123;</span><br><span class=\"line\">    next: resps =&gt; &#123;</span><br><span class=\"line\">      // do sth with resps:Blob[]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>  每次遇到 <code>rxjs</code> 都很头大，现在也没有发现一个比较完善清晰的教程，但它又真的很强大，后续要开专题好好学习记录这个东西。</p>\n<h4>2019/7/16</h4>\n<p>一、今日阅读：<a href=\"https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\" target=\"_blank\" rel=\"noopener\">How to read an often-changing value from useCallback?</a><br>\n直接上官网代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  const textRef = useRef();</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    textRef.current = text; // Write it to the ref</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  const handleSubmit = useCallback(() =&gt; &#123;</span><br><span class=\"line\">    const currentText = textRef.current; // Read it from the ref</span><br><span class=\"line\">    alert(currentText);</span><br><span class=\"line\">  &#125;, [textRef]); // Don&apos;t recreate handleSubmit like [text] would do</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   也就是说，当 <code>text</code> 的值经常发生变化时，即使 <code>handleSubmit</code> 用 <code>useCallback</code> 包裹了，还是会重新声明。解决办法是传入一个 <code>ref</code> 对象代替原始值。也可以写一个 custom hook ：<br>\n1）官网的版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function useEventCallback(fn, dependencies) &#123;</span><br><span class=\"line\">  const ref = useRef(() =&gt; &#123;</span><br><span class=\"line\">    throw new Error(&apos;Cannot call an event handler while rendering.&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ref.current = fn;</span><br><span class=\"line\">  &#125;, [fn, ...dependencies]);</span><br><span class=\"line\"></span><br><span class=\"line\">  return useCallback(() =&gt; &#123;</span><br><span class=\"line\">    const fn = ref.current;</span><br><span class=\"line\">    return fn();</span><br><span class=\"line\">  &#125;, [ref]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  // Will be memoized even if `text` changes:</span><br><span class=\"line\">  const handleSubmit = useEventCallback(() =&gt; &#123;</span><br><span class=\"line\">    alert(text);</span><br><span class=\"line\">  &#125;, [text]);</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2）导师的版本：（他来了，他带着代码又来了）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @param callback</span><br><span class=\"line\"> * @param oRefs</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function useCallbackWithRefs&lt;</span><br><span class=\"line\">  Refs,</span><br><span class=\"line\">  Callback extends (...args: any[]) =&gt; void</span><br><span class=\"line\">&gt;(callback: (refs: Refs) =&gt; Callback, oRefs: Refs) &#123;</span><br><span class=\"line\">  const refs = useRef(oRefs);</span><br><span class=\"line\">  useEffect(</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">      refs.current = oRefs;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [oRefs]</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  return useCallback(</span><br><span class=\"line\">    (...args: any[]) =&gt; callback(refs.current)(...args),</span><br><span class=\"line\">    []</span><br><span class=\"line\">  ) as Callback;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Form() &#123;</span><br><span class=\"line\">  const [text, updateText] = useState(&apos;&apos;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 原先的 callback 也可以有参数</span><br><span class=\"line\">  const handleSubmit = useCallbackWithRefs(</span><br><span class=\"line\">    refs =&gt; (params: any) =&gt; &#123;</span><br><span class=\"line\">      // 要注意在函数内必须使用 `refs.xxx`，不能直接使用函数外部的任何变量 `xxx`</span><br><span class=\"line\">      console.log(refs.text);</span><br><span class=\"line\">  &#125;, &#123;text&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input value=&#123;text&#125; onChange=&#123;e =&gt; updateText(e.target.value)&#125; /&gt;</span><br><span class=\"line\">      &lt;ExpensiveTree onSubmit=&#123;handleSubmit&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  总的来说，官网的实现是将 <code>callback</code> 作为 <code>ref</code> 对象，并作为 <code>useCallback</code> 的依赖，不会频繁改变；如果在函数 <code>handleSubmit</code> 中要访问外部变量 <code>text</code> ，直接使用 <code>test</code> 即可。第二种实现方式是把经常变化的值作为 <code>ref</code> 对象，返回值 <code>useCallback</code> 第一个参数是 <code>refs =&gt; callback</code> ，依赖是空数组；这时如果要在函数 <code>handleSubmit</code> 中要访问外部变量 <code>text</code> ，必须使用 <code>refs.test</code> ，否则访问的只是 <code>test</code> 的初始值。<br>\n  React 博大精深，接下来要好好研读一下这个 <a href=\"https://reactjs.org/docs/hooks-faq.html\" target=\"_blank\" rel=\"noopener\">FAQ</a>。<br>\n二、今日网址<br>\n  一个 <a href=\"https://www.emojicopy.com/\" target=\"_blank\" rel=\"noopener\">emoji copy</a> 网站，我们 👧 就是喜欢这些花里胡哨的东西。</p>\n<h4>2019/7/15</h4>\n<p>  今天在项目中使用 React Hooks 又踩坑了，看来自己对这部分还是没有理解透彻。在使用 <code>useCallback</code> 和 <code>useEffect</code> 时，要注意第二个参数，也就是传入的 <code>[deps]</code>。如果使用 <code>useCallback(fn,[deps])</code> ， <code>[deps]</code> 应该包含函数 <code>fn</code> 所涉及的所有变量；如果使用 <code>useEffect(fn,[deps])</code> ， 当 <code>deps</code> 的值变化时，就会执行 <code>fn</code>，因此<code>[deps]</code> 不一定要包含函数 <code>fn</code> 所涉及的所有变量，而是应该传入会引起该函数执行的那些参数。<br>\n  今日踩坑记录：为了优化子组件，作为 <code>props</code> 的函数都使用 <code>useCallback</code> 包裹了，并传入了空数组作为第二个参数，表示没有依赖。但是函数中的运算需要用到组件中一个变量，如果没有将该变量作为 <code>deps</code> ，这个变量就会一直保持初始值，值并不会改变，运行结果就会与预期不符。（真的太蠢了，缓缓躺倒）</p>\n<h4>2019/7/14</h4>\n<p>周末当然是约会啦。😍</p>\n<h4>2019/7/13</h4>\n<p>一、今日阅读：<a href=\"https://stackoverflow.com/questions/53446020/how-to-compare-oldvalues-and-newvalues-on-react-hooks-useeffect\" target=\"_blank\" rel=\"noopener\">How to compare oldValues and newValues on React Hooks useEffect?</a><br>\n   React class 组件提供了 <code>ComponentDidUpdate</code> 之类的方法来获取到当前 <code>props</code> 和前一个 <code>props</code> ，并进行比较，决定是否进行更新。函数式组件只有 <code>useEffect</code> 函数来模仿生命周期函数，当我们需要获取组件先前的 <code>props</code> 时，可以使用下面的 custom hook ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function usePrevious(value) &#123;</span><br><span class=\"line\">  const ref = useRef();</span><br><span class=\"line\">  useEffect(() =&gt; &#123;</span><br><span class=\"line\">    ref.current = value;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return ref.current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  之后在 <code>useEffect</code> 中使用上面的函数来模拟 <code>ComponentDidUpdate</code> ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Component = (props) =&gt; &#123;</span><br><span class=\"line\">    const &#123;receiveAmount, sendAmount &#125; = props</span><br><span class=\"line\">    const prevAmount = usePrevious(&#123;receiveAmount, sendAmount&#125;);</span><br><span class=\"line\">    useEffect(() =&gt; &#123;</span><br><span class=\"line\">        if(prevAmount.receiveAmount !== receiveAmount) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         // process here</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(prevAmount.sendAmount !== sendAmount) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         // process here</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, [receiveAmount, sendAmount])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  有时候在 debug 时，我们想知道组件为什么会重新渲染，是那些 <code>props</code> 更新了，也可以使用上面的方法来获取 <code>prevProps</code>，并在函数组件最开始时写一个 <code>useEffect</code> 将参数都打印出来，使用 <code>===</code> 比较。</p>\n<h4>2019/7/12</h4>\n<p>一、今日技能<br>\n  项目中经常会涉及到 JSON 字符串的解析，解析出错就扑街了，一般是用 <code>try {...} catch {...}</code> 包裹。今天导师在 code review 时建议我使用如下函数，该函数也可以覆盖空字符串的检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function safeJsonParse&lt;T&gt;(str): &#123; ok: true, value: T &#125; | &#123; ok: false &#125; &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ok: true,</span><br><span class=\"line\">      value: JSON.parse(str)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; catch &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      ok: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>二、今日阅读：<a href=\"https://imweb.io/topic/5b72d4ef15554e6d3409f817\" target=\"_blank\" rel=\"noopener\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a>。<br>\n  这一篇很好地梳理了进程、线程、浏览器<strong>多进程</strong>、浏览器内核<strong>多线程</strong>、JS单线程、JS运行机制的相关知识，很连贯，建议时不时回顾。简单记录几个知识点：<br>\n1）进程是CPU资源分配的最小单位，线程是CPU调度的最小单位。（想当年考操作系统的时候还背得滚瓜烂熟）<br>\n2）<strong>浏览器是多进程的</strong>，包括的主要进程有：</p>\n<ul>\n<li>Browser进程（浏览器的主进程，只有一个）</li>\n<li>浏览器渲染进程（浏览器内核，Renderer进程，渲染进程，内部是多线程的）：默认每个Tab一个进程</li>\n<li>第三方插件进程</li>\n<li>GPU进程：3D绘制</li>\n</ul>\n<p>3）重点是浏览器内核，它是多线程的，主要常驻线程有：</p>\n<ul>\n<li>GUI渲染线程：渲染页面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制，repaint 和 reflow 等。</li>\n<li>JS引擎线程：处理任务队列中的任务，与 GUI 渲染线程是互斥的。</li>\n<li>事件触发线程：控制事件循环，把事件添加到任务队列的末尾。</li>\n<li>定时触发线程：<code>setTimeout</code> 和 <code>setInterval</code>，同样也是计时完毕后添加到队列末尾。</li>\n<li>异步 http 请求线程</li>\n</ul>\n<p>4）Browser进程和浏览器内核之间是需要通信的<br>\n5）时间循环机制 <code>Event Loop</code> ：JS分为同步任务和异步任务，同步任务都会在主线程上运行，形成一个执行栈；主线程之外，由事件触发线程管理一个<strong>任务队列/事件队列</strong>，异步任务的运行结果会被添加到任务队列中。一旦执行栈中所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务添加到执行栈中开始执行。<br>\n6）进阶：macrotask / task 和 microtask/ job。ES6中的 <code>Promise</code> 就属于 microtask 微任务 ，而主代码块，事件队列中的时间如 <code>setTimeout</code> 和 <code>setInterval</code> 就属于 macrotask 宏任务。总结的运行机制就是：</p>\n<ul>\n<li>执行宏任务。（从执行栈中获取，如果没有就从事件队列中获取）</li>\n<li>执行过程中如果遇到微任务，就添加到微任务队列 Job Queues 中。（作者猜测这个队列由JS引擎线程维护，因为是在主线程下无缝执行的）</li>\n<li>宏任务执行完毕后，立即依次执行当前微任务队列中所有微任务。</li>\n<li>检查渲染，由 GUI 线程接管。</li>\n<li>渲染完毕后，由 JS 引擎线程接管，从时间队列中获取并执行下一个宏任务。</li>\n</ul>\n<p>7）在第六点中提到的是一个进阶的概念，对应一道题目，如果代码中依次有 <code>setTimeout</code> 和 <code>Promise</code> ，是会先打印出 <code>Promise</code> 的执行结果的。</p>\n<h4>2019/7/11</h4>\n<p>   React 16.8 提出了 <code>hook</code> 的概念，函数式组件也可以拥有自己的状态。现在的工作项目已经摒弃了 <code>class</code> ，改用函数式组件，正在慢慢摸索中。今天在腾讯<a href=\"http://imweb.io/\" target=\"_blank\" rel=\"noopener\">IMWeb前端博客</a>中看到了两篇介绍 <code>React hook</code> 的文章，受益匪浅，简单记录一下。<br>\n一、<a href=\"https://imweb.io/topic/5cd845cadcd62f86299fcd76\" target=\"_blank\" rel=\"noopener\">react hook——你可能不是“我”所认识的useEffect</a><br>\n  这篇介绍了 <code>useEffect</code> 这个API，用它模拟了class组件的生命周期函数。<code>useEffect</code> 用于执行副作用，相当于 <code>ComponentDidMount</code> 和 <code>ComponentDidUpdate</code>。该API有两个参数和一个返回值。第一个参数是一个副作用函数，返回值是清除函数，相当于 <code>ComponentWillUnmount</code>，每一次 <code>render</code> 都会执行副作用和清除上一次副作用。<strong>第二个参数是一个数组，传入的是副作用函数所需要的依赖，当任一依赖更新时，会重新生成一个新的副作用并执行；如果传入一个空数组，没有依赖，只会执行一次，相当于 <code>ComponentDidMount</code>；如果不传，就是没有说明自己有没有依赖（注意是不知道有没有，不是没有！），每次 <code>render</code> 时就执行，相当于 <code>ComponentDidUpdate</code> 。</strong><br>\n   最后还讲了 <code>useEffect</code> 和 <code>useLayoutEffect</code> 的区别，简单来说前者是异步的，后者是同步的。还没好好深入这部分，TODO。<br>\n二、<a href=\"https://imweb.io/topic/5d1e3657f7b5692b080f2651\" target=\"_blank\" rel=\"noopener\">可能你的react函数组件从来没有优化过</a><br>\n  优化问题真是我一个痛点。这篇文章很清楚地解释了 <code>Hooks</code> 一些可用于组件优化的API。强推！<br>\n   特别地，文章介绍了当函数组件中传入的 <code>props</code> 值为函数时，由于每一次执行或重新执行，作用域里面一切都是重新开始，函数不是简单数据类型，不能画上等号，子组件都会重新渲染。针对这个问题文章提出了几种解决办法：<br>\n1） 作为 <code>props</code> 的函数在函数组件外定义，函数组件用 <code>React.memo()</code> 包裹。<br>\n   <code>React.memo()</code> 类似于 <code>PureComponent</code> 和 <code>ComponentDidUpdate</code> ，如果函数组件的 <code>props</code> 值都一样，就会跳过该组件的执行，减少不必要的渲染，实现性能优化。<br>\n2） 作为 <code>props</code> 的函数在函数组件内定义，使用<code>useCallBack</code> 或 <code>useMemo</code>包裹，函数组件用 <code>React.memo()</code> 包裹。<br>\n   <code>useCallback(() =&gt; {}, [deps])</code> 返回一个函数，当 <code>deps</code> 不变时（如传入空数组，表示没有依赖），都是同一个函数。<code>const a = useMemo(() =&gt; memorizeValue, [deps])</code>，当 <code>deps</code> 不变时，<code>a</code> 的值还是上次的 <code>memorizeValue</code>，省去了重新计算的过程。<br>\n   注意当 <code>memorizeValue</code> 是一个函数时，<code>useCallback(fn, inputs) &lt;=&gt; useMemo(() =&gt; fn, inputs)</code>。</p>\n<h4>2019/7/10</h4>\n<p>  今天在项目中接触到了 <code>symbol</code>，鉴于之前一直没有注意这个数据类型，在今天补上。 <code>symbol</code> 是 ES6 新增的<strong>基本</strong>数据类型。它的使用如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const s1 = Symbol();</span><br><span class=\"line\">const s2 = Symbol();</span><br><span class=\"line\">console.log(s1 === s2); // false</span><br><span class=\"line\"></span><br><span class=\"line\">const s3 = new Symbol() // TypeError: Symbol is not a constructor</span><br><span class=\"line\">Symbol(&quot;foo&quot;) === Symbol(&quot;foo&quot;); // false</span><br></pre></td></tr></table></figure>\n<p><code>Symbol()</code> 返回的每个 <code>symbol</code> 值都是唯一的，可以接受一个字符串作为参数。它最常被用于对象属性的标识符，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;&#125;</span><br><span class=\"line\">const foo = Symbol(&quot;foo&quot;)</span><br><span class=\"line\">obj[foo] = &quot;foo&quot;</span><br><span class=\"line\">obj.bar = &quot;bar&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(obj); // &#123; bar: &quot;bar&quot; , Symbol(foo): &quot;foo&quot;&#125;</span><br><span class=\"line\">console.log(foo in obj); // true</span><br><span class=\"line\">console.log(obj[foo]); // foo</span><br><span class=\"line\">console.log(Object.keys(obj)); // [&quot;bar&quot;]</span><br><span class=\"line\">console.log(Object.getOwnPropertySymbols(obj)) // [Symbol(foo)]</span><br></pre></td></tr></table></figure>\n<p>也就是说， <code>Object.key()</code> 不会返回 <code>symbol</code> 值，同理，<code>Object.getOwnPropertyNames()</code>、<code>for..in</code>、<code>for...of</code> 也不会返回。<code>JSON.stringify()</code> 也会忽略：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON.stringify(&#123;[Symbol(&apos;foo&apos;)]: &apos;foo&apos;&#125;);                 </span><br><span class=\"line\">// &apos;&#123;&#125;&apos;</span><br></pre></td></tr></table></figure>\n<p><code>Symbol</code> 还有两个方法。 <code>Symbol.for(key)</code> 是根据指定的 <code>key</code> 搜索现有的 <code>symbol</code> 并返回, 如果找不到，会使用 <code>key</code> 在全局的 <code>symbol</code> 注册表中创建一个新的 <code>symbol</code> 。<code>Symbol.keyFor(sym)</code> 是在全局注册表中检索，返回共享的 <code>symbol key</code> 。</p>\n<h4>2019/7/9</h4>\n<p>一个不好的编程习惯：让函数在内部获取自己所需的依赖。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 一个可复用函数</span><br><span class=\"line\">function doSomething(key: string) &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;Button</span><br><span class=\"line\">            loading = &#123;key===&quot;str1&quot;? Compoment1 : Compoment2&#125;</span><br><span class=\"line\">        &gt;</span><br><span class=\"line\">            button</span><br><span class=\"line\">        &lt;/Button&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>lodaing</code> 所需的组件应该是作为函数参数传入的，不然如果我们新增了一个 <code>key</code>，很容易忽略了该地方的修改。这个观点类似于依赖反转。</p>\n"},{"title":"FrontEnd Notes [2020.01]","catalog":true,"date":"2020-01-02T01:57:13.000Z","subtitle":null,"header-img":null,"_content":"#### About\n\n📅 2020 年 1 月的零散学习记录。\n\n新年快乐！希望新的一年能坚持记笔记！\n\n#### 2020/01/12\n今日阅读：[Why ['1', '7', '11'].map(parseInt) returns [1, NaN, 3] in Javascript](https://medium.com/dailyjs/parseint-mystery-7c4368ef7b21)\n一篇非常有趣的文章，开篇一张图：\n![image.png](https://i.loli.net/2020/01/12/grShLvH28RDXtYM.png)\n出现这种结果的原因，在于 `map` 函数默认会传入三个参数：currentValue、currentIndex 以及 full array 。而对于 `parseInt` 而言，第二个参数表示基数，用此来解析数组中的每个字符串。'1' 以 0 为基数进行解析，0 的布尔值为 `false`，因此会以默认基数 10 进行解析，输出 1 ；'7' 以 1 为基数 进行解析，会输出 `NaN` ；'11' 以 2 为基数解析，会输出 3。\n['1'，'7'，'11']。map（parseInt）无法按预期工作，因为map每次迭代都会将三个参数传递给parseInt（）。 第二个参数索引作为基数参数传递到parseInt中。 因此，使用不同的基数解析数组中的每个字符串。 '7'被解析为基数1，即NaN，'11'被解析为基数2，即3。'1'被解析为默认基数10，因为其索引0为假。\n\n#### 2020/01/09\n一、[How to handle errors in Promise.all](https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all/30378082)\n简单来说就是：\n```\nawait Promise.all(vals.map(val => \n  promise(val)\n  .catch(err => {\n    // handle here\n    return err\n  })\n))\n```\n二、[New ES2018 Features](https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/)\n\n#### 2020/01/05\n今天需要对某个数值进行类型校验，避免出现 `NaN`，本来是用 `!typeof value === 'number'`，后来发现：\n```\ntypeof NaN === 'number'\n```\n关于为什么是这种输出，可以看 medium 上这篇文章：[NaN and typeof](https://javascriptrefined.io/nan-and-typeof-36cd6e2a4e43)。\n如果需要判断某个数是否为 `NaN`，可用 `isNaN(value)` 判断。\n\n#### 2020/01/04\n今天在处理正则表达式时遇到这样的疑惑：\n```\nconst str = '\\abc';\nconst reg = /\\\\abc/;\nreg.test(str); // false\n```\n我们都知道反斜杠 `\\` 是转义的作用，如果要输出斜杠，那么必须使用 `\\\\` ；在上面的代码中，`reg` 匹配是是 `\\abc` ，为什么输出结果会是 `false` 呢？\n经过查阅，发现在字符串中，'\\' 也有转义的作用。如果反斜杠出现在字符的前面，那么他们就是一个整体，比如说 '\\n' 表示换行，字符串 '\\abc' 也涉及转义操作，由于 a 不是有效的转义符，所以就直接转成 'abc' 。下面的代码可以验证这个说法：\n```\nconst str = \"\\abc\";\nconsole.info(str.length); // 3\n\"\\abc\" === \"abc\" //true\n```\n因此，上面的代码应该改成：\n```\nconst str = '\\\\abc';\nconst reg = /\\\\abc/;\nreg.test(str); // true\n```\n\n#### 2020/01/02\n放大预览图片的某个部分：思路是计算 bbox 的 scale 数值，使之能填充满整个 container ；再计算原始图片的偏移量，使之只显示 bbox 部分。    \n```\nfunction Preview(props: {\n  imgSrc: string;\n  imgSize: { width: number; height: number };\n  box: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n}) {\n  const [containerSize] = useState({ width: 350, height: 400 });\n\n  const scale = Math.min(\n    containerSize.width / props.box.width,\n    containerSize.height / props.box.height\n  );\n  const boxCenter = {\n    x: props.box.x + props.box.width / 2,\n    y: props.box.y + props.box.height / 2\n  };\n  const containerCenter = {\n    x: containerSize.width / 2,\n    y: containerSize.height / 2\n  };\n  const tr = {\n    x: containerCenter.x - boxCenter.x * scale,\n    y: containerCenter.y - boxCenter.y * scale\n  };\n\n  return (\n    <div style={{ position: \"relative\", ...containerSize, overflow: \"hidden\" }}>\n      <img\n        src={props.imgSrc}\n        style={{\n          ...props.imgSize,\n          objectFit: \"contain\",\n          position: \"absolute\",\n          left: 0,\n          top: 0,\n          transform: `translate(${tr.x}px, ${tr.y}px) scale(${scale})`,\n          transformOrigin: \"top left\",\n          transition: \"all 0.3s\"\n        }}\n      />\n    </div>\n  );\n}\n```","source":"_posts/FrontEnd-Notes-2020-01.md","raw":"---\ntitle: 'FrontEnd Notes [2020.01]'\ncatalog: true\ndate: 2020-01-02 09:57:13\nsubtitle:\nheader-img:\ntags: FE\n---\n#### About\n\n📅 2020 年 1 月的零散学习记录。\n\n新年快乐！希望新的一年能坚持记笔记！\n\n#### 2020/01/12\n今日阅读：[Why ['1', '7', '11'].map(parseInt) returns [1, NaN, 3] in Javascript](https://medium.com/dailyjs/parseint-mystery-7c4368ef7b21)\n一篇非常有趣的文章，开篇一张图：\n![image.png](https://i.loli.net/2020/01/12/grShLvH28RDXtYM.png)\n出现这种结果的原因，在于 `map` 函数默认会传入三个参数：currentValue、currentIndex 以及 full array 。而对于 `parseInt` 而言，第二个参数表示基数，用此来解析数组中的每个字符串。'1' 以 0 为基数进行解析，0 的布尔值为 `false`，因此会以默认基数 10 进行解析，输出 1 ；'7' 以 1 为基数 进行解析，会输出 `NaN` ；'11' 以 2 为基数解析，会输出 3。\n['1'，'7'，'11']。map（parseInt）无法按预期工作，因为map每次迭代都会将三个参数传递给parseInt（）。 第二个参数索引作为基数参数传递到parseInt中。 因此，使用不同的基数解析数组中的每个字符串。 '7'被解析为基数1，即NaN，'11'被解析为基数2，即3。'1'被解析为默认基数10，因为其索引0为假。\n\n#### 2020/01/09\n一、[How to handle errors in Promise.all](https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all/30378082)\n简单来说就是：\n```\nawait Promise.all(vals.map(val => \n  promise(val)\n  .catch(err => {\n    // handle here\n    return err\n  })\n))\n```\n二、[New ES2018 Features](https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/)\n\n#### 2020/01/05\n今天需要对某个数值进行类型校验，避免出现 `NaN`，本来是用 `!typeof value === 'number'`，后来发现：\n```\ntypeof NaN === 'number'\n```\n关于为什么是这种输出，可以看 medium 上这篇文章：[NaN and typeof](https://javascriptrefined.io/nan-and-typeof-36cd6e2a4e43)。\n如果需要判断某个数是否为 `NaN`，可用 `isNaN(value)` 判断。\n\n#### 2020/01/04\n今天在处理正则表达式时遇到这样的疑惑：\n```\nconst str = '\\abc';\nconst reg = /\\\\abc/;\nreg.test(str); // false\n```\n我们都知道反斜杠 `\\` 是转义的作用，如果要输出斜杠，那么必须使用 `\\\\` ；在上面的代码中，`reg` 匹配是是 `\\abc` ，为什么输出结果会是 `false` 呢？\n经过查阅，发现在字符串中，'\\' 也有转义的作用。如果反斜杠出现在字符的前面，那么他们就是一个整体，比如说 '\\n' 表示换行，字符串 '\\abc' 也涉及转义操作，由于 a 不是有效的转义符，所以就直接转成 'abc' 。下面的代码可以验证这个说法：\n```\nconst str = \"\\abc\";\nconsole.info(str.length); // 3\n\"\\abc\" === \"abc\" //true\n```\n因此，上面的代码应该改成：\n```\nconst str = '\\\\abc';\nconst reg = /\\\\abc/;\nreg.test(str); // true\n```\n\n#### 2020/01/02\n放大预览图片的某个部分：思路是计算 bbox 的 scale 数值，使之能填充满整个 container ；再计算原始图片的偏移量，使之只显示 bbox 部分。    \n```\nfunction Preview(props: {\n  imgSrc: string;\n  imgSize: { width: number; height: number };\n  box: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n}) {\n  const [containerSize] = useState({ width: 350, height: 400 });\n\n  const scale = Math.min(\n    containerSize.width / props.box.width,\n    containerSize.height / props.box.height\n  );\n  const boxCenter = {\n    x: props.box.x + props.box.width / 2,\n    y: props.box.y + props.box.height / 2\n  };\n  const containerCenter = {\n    x: containerSize.width / 2,\n    y: containerSize.height / 2\n  };\n  const tr = {\n    x: containerCenter.x - boxCenter.x * scale,\n    y: containerCenter.y - boxCenter.y * scale\n  };\n\n  return (\n    <div style={{ position: \"relative\", ...containerSize, overflow: \"hidden\" }}>\n      <img\n        src={props.imgSrc}\n        style={{\n          ...props.imgSize,\n          objectFit: \"contain\",\n          position: \"absolute\",\n          left: 0,\n          top: 0,\n          transform: `translate(${tr.x}px, ${tr.y}px) scale(${scale})`,\n          transformOrigin: \"top left\",\n          transition: \"all 0.3s\"\n        }}\n      />\n    </div>\n  );\n}\n```","slug":"FrontEnd-Notes-2020-01","published":1,"updated":"2020-01-12T02:46:59.170Z","_id":"ck5393is00007icuegsdu99f2","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"about\"><a href=\"#About\" class=\"headerlink\" title=\"About\"></a>About</h4><p>📅 2020 年 1 月的零散学习记录。</p>\n<p>新年快乐！希望新的一年能坚持记笔记！</p>\n<h4 id=\"20200112\"><a href=\"#2020-01-12\" class=\"headerlink\" title=\"2020/01/12\"></a>2020/01/12</h4><p>今日阅读：<a href=\"https://medium.com/dailyjs/parseint-mystery-7c4368ef7b21\" target=\"_blank\" rel=\"noopener\">Why [‘1’, ‘7’, ‘11’].map(parseInt) returns [1, NaN, 3] in Javascript</a><br>一篇非常有趣的文章，开篇一张图：<br><img src=\"https://i.loli.net/2020/01/12/grShLvH28RDXtYM.png\" alt=\"image.png\"><br>出现这种结果的原因，在于 <code>map</code> 函数默认会传入三个参数：currentValue、currentIndex 以及 full array 。而对于 <code>parseInt</code> 而言，第二个参数表示基数，用此来解析数组中的每个字符串。’1’ 以 0 为基数进行解析，0 的布尔值为 <code>false</code>，因此会以默认基数 10 进行解析，输出 1 ；’7’ 以 1 为基数 进行解析，会输出 <code>NaN</code> ；’11’ 以 2 为基数解析，会输出 3。<br>[‘1’，’7’，’11’]。map（parseInt）无法按预期工作，因为map每次迭代都会将三个参数传递给parseInt（）。 第二个参数索引作为基数参数传递到parseInt中。 因此，使用不同的基数解析数组中的每个字符串。 ‘7’被解析为基数1，即NaN，’11’被解析为基数2，即3。’1’被解析为默认基数10，因为其索引0为假。</p>\n<h4 id=\"20200109\"><a href=\"#2020-01-09\" class=\"headerlink\" title=\"2020/01/09\"></a>2020/01/09</h4><p>一、<a href=\"https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all/30378082\" target=\"_blank\" rel=\"noopener\">How to handle errors in Promise.all</a><br>简单来说就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">await Promise.all(vals.map(val =&gt; </span><br><span class=\"line\">  promise(val)</span><br><span class=\"line\">  .catch(err =&gt; &#123;</span><br><span class=\"line\">    // handle here</span><br><span class=\"line\">    return err</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">))</span><br></pre></td></tr></table></figure></p>\n<p>二、<a href=\"https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/\" target=\"_blank\" rel=\"noopener\">New ES2018 Features</a></p>\n<h4 id=\"20200105\"><a href=\"#2020-01-05\" class=\"headerlink\" title=\"2020/01/05\"></a>2020/01/05</h4><p>今天需要对某个数值进行类型校验，避免出现 <code>NaN</code>，本来是用 <code>!typeof value === &#39;number&#39;</code>，后来发现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof NaN === &apos;number&apos;</span><br></pre></td></tr></table></figure></p>\n<p>关于为什么是这种输出，可以看 medium 上这篇文章：<a href=\"https://javascriptrefined.io/nan-and-typeof-36cd6e2a4e43\" target=\"_blank\" rel=\"noopener\">NaN and typeof</a>。<br>如果需要判断某个数是否为 <code>NaN</code>，可用 <code>isNaN(value)</code> 判断。</p>\n<h4 id=\"20200104\"><a href=\"#2020-01-04\" class=\"headerlink\" title=\"2020/01/04\"></a>2020/01/04</h4><p>今天在处理正则表达式时遇到这样的疑惑：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;\\abc&apos;;</span><br><span class=\"line\">const reg = /\\\\abc/;</span><br><span class=\"line\">reg.test(str); // false</span><br></pre></td></tr></table></figure></p>\n<p>我们都知道反斜杠 <code>\\</code> 是转义的作用，如果要输出斜杠，那么必须使用 <code>\\\\</code> ；在上面的代码中，<code>reg</code> 匹配是是 <code>\\abc</code> ，为什么输出结果会是 <code>false</code> 呢？<br>经过查阅，发现在字符串中，’\\’ 也有转义的作用。如果反斜杠出现在字符的前面，那么他们就是一个整体，比如说 ‘\\n’ 表示换行，字符串 ‘\\abc’ 也涉及转义操作，由于 a 不是有效的转义符，所以就直接转成 ‘abc’ 。下面的代码可以验证这个说法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &quot;\\abc&quot;;</span><br><span class=\"line\">console.info(str.length); // 3</span><br><span class=\"line\">&quot;\\abc&quot; === &quot;abc&quot; //true</span><br></pre></td></tr></table></figure></p>\n<p>因此，上面的代码应该改成：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;\\\\abc&apos;;</span><br><span class=\"line\">const reg = /\\\\abc/;</span><br><span class=\"line\">reg.test(str); // true</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"20200102\"><a href=\"#2020-01-02\" class=\"headerlink\" title=\"2020/01/02\"></a>2020/01/02</h4><p>放大预览图片的某个部分：思路是计算 bbox 的 scale 数值，使之能填充满整个 container ；再计算原始图片的偏移量，使之只显示 bbox 部分。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Preview(props: &#123;</span><br><span class=\"line\">  imgSrc: string;</span><br><span class=\"line\">  imgSize: &#123; width: number; height: number &#125;;</span><br><span class=\"line\">  box: &#123;</span><br><span class=\"line\">    x: number;</span><br><span class=\"line\">    y: number;</span><br><span class=\"line\">    width: number;</span><br><span class=\"line\">    height: number;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  const [containerSize] = useState(&#123; width: 350, height: 400 &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  const scale = Math.min(</span><br><span class=\"line\">    containerSize.width / props.box.width,</span><br><span class=\"line\">    containerSize.height / props.box.height</span><br><span class=\"line\">  );</span><br><span class=\"line\">  const boxCenter = &#123;</span><br><span class=\"line\">    x: props.box.x + props.box.width / 2,</span><br><span class=\"line\">    y: props.box.y + props.box.height / 2</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  const containerCenter = &#123;</span><br><span class=\"line\">    x: containerSize.width / 2,</span><br><span class=\"line\">    y: containerSize.height / 2</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  const tr = &#123;</span><br><span class=\"line\">    x: containerCenter.x - boxCenter.x * scale,</span><br><span class=\"line\">    y: containerCenter.y - boxCenter.y * scale</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div style=&#123;&#123; position: &quot;relative&quot;, ...containerSize, overflow: &quot;hidden&quot; &#125;&#125;&gt;</span><br><span class=\"line\">      &lt;img</span><br><span class=\"line\">        src=&#123;props.imgSrc&#125;</span><br><span class=\"line\">        style=&#123;&#123;</span><br><span class=\"line\">          ...props.imgSize,</span><br><span class=\"line\">          objectFit: &quot;contain&quot;,</span><br><span class=\"line\">          position: &quot;absolute&quot;,</span><br><span class=\"line\">          left: 0,</span><br><span class=\"line\">          top: 0,</span><br><span class=\"line\">          transform: `translate($&#123;tr.x&#125;px, $&#123;tr.y&#125;px) scale($&#123;scale&#125;)`,</span><br><span class=\"line\">          transformOrigin: &quot;top left&quot;,</span><br><span class=\"line\">          transition: &quot;all 0.3s&quot;</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"About\"><a href=\"#About\" class=\"headerlink\" title=\"About\"></a>About</h4><p>📅 2020 年 1 月的零散学习记录。</p>\n<p>新年快乐！希望新的一年能坚持记笔记！</p>\n<h4 id=\"2020-01-12\"><a href=\"#2020-01-12\" class=\"headerlink\" title=\"2020/01/12\"></a>2020/01/12</h4><p>今日阅读：<a href=\"https://medium.com/dailyjs/parseint-mystery-7c4368ef7b21\" target=\"_blank\" rel=\"noopener\">Why [‘1’, ‘7’, ‘11’].map(parseInt) returns [1, NaN, 3] in Javascript</a><br>一篇非常有趣的文章，开篇一张图：<br><img src=\"https://i.loli.net/2020/01/12/grShLvH28RDXtYM.png\" alt=\"image.png\"><br>出现这种结果的原因，在于 <code>map</code> 函数默认会传入三个参数：currentValue、currentIndex 以及 full array 。而对于 <code>parseInt</code> 而言，第二个参数表示基数，用此来解析数组中的每个字符串。’1’ 以 0 为基数进行解析，0 的布尔值为 <code>false</code>，因此会以默认基数 10 进行解析，输出 1 ；’7’ 以 1 为基数 进行解析，会输出 <code>NaN</code> ；’11’ 以 2 为基数解析，会输出 3。<br>[‘1’，’7’，’11’]。map（parseInt）无法按预期工作，因为map每次迭代都会将三个参数传递给parseInt（）。 第二个参数索引作为基数参数传递到parseInt中。 因此，使用不同的基数解析数组中的每个字符串。 ‘7’被解析为基数1，即NaN，’11’被解析为基数2，即3。’1’被解析为默认基数10，因为其索引0为假。</p>\n<h4 id=\"2020-01-09\"><a href=\"#2020-01-09\" class=\"headerlink\" title=\"2020/01/09\"></a>2020/01/09</h4><p>一、<a href=\"https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all/30378082\" target=\"_blank\" rel=\"noopener\">How to handle errors in Promise.all</a><br>简单来说就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">await Promise.all(vals.map(val =&gt; </span><br><span class=\"line\">  promise(val)</span><br><span class=\"line\">  .catch(err =&gt; &#123;</span><br><span class=\"line\">    // handle here</span><br><span class=\"line\">    return err</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">))</span><br></pre></td></tr></table></figure></p>\n<p>二、<a href=\"https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/\" target=\"_blank\" rel=\"noopener\">New ES2018 Features</a></p>\n<h4 id=\"2020-01-05\"><a href=\"#2020-01-05\" class=\"headerlink\" title=\"2020/01/05\"></a>2020/01/05</h4><p>今天需要对某个数值进行类型校验，避免出现 <code>NaN</code>，本来是用 <code>!typeof value === &#39;number&#39;</code>，后来发现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof NaN === &apos;number&apos;</span><br></pre></td></tr></table></figure></p>\n<p>关于为什么是这种输出，可以看 medium 上这篇文章：<a href=\"https://javascriptrefined.io/nan-and-typeof-36cd6e2a4e43\" target=\"_blank\" rel=\"noopener\">NaN and typeof</a>。<br>如果需要判断某个数是否为 <code>NaN</code>，可用 <code>isNaN(value)</code> 判断。</p>\n<h4 id=\"2020-01-04\"><a href=\"#2020-01-04\" class=\"headerlink\" title=\"2020/01/04\"></a>2020/01/04</h4><p>今天在处理正则表达式时遇到这样的疑惑：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;\\abc&apos;;</span><br><span class=\"line\">const reg = /\\\\abc/;</span><br><span class=\"line\">reg.test(str); // false</span><br></pre></td></tr></table></figure></p>\n<p>我们都知道反斜杠 <code>\\</code> 是转义的作用，如果要输出斜杠，那么必须使用 <code>\\\\</code> ；在上面的代码中，<code>reg</code> 匹配是是 <code>\\abc</code> ，为什么输出结果会是 <code>false</code> 呢？<br>经过查阅，发现在字符串中，’\\’ 也有转义的作用。如果反斜杠出现在字符的前面，那么他们就是一个整体，比如说 ‘\\n’ 表示换行，字符串 ‘\\abc’ 也涉及转义操作，由于 a 不是有效的转义符，所以就直接转成 ‘abc’ 。下面的代码可以验证这个说法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &quot;\\abc&quot;;</span><br><span class=\"line\">console.info(str.length); // 3</span><br><span class=\"line\">&quot;\\abc&quot; === &quot;abc&quot; //true</span><br></pre></td></tr></table></figure></p>\n<p>因此，上面的代码应该改成：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;\\\\abc&apos;;</span><br><span class=\"line\">const reg = /\\\\abc/;</span><br><span class=\"line\">reg.test(str); // true</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2020-01-02\"><a href=\"#2020-01-02\" class=\"headerlink\" title=\"2020/01/02\"></a>2020/01/02</h4><p>放大预览图片的某个部分：思路是计算 bbox 的 scale 数值，使之能填充满整个 container ；再计算原始图片的偏移量，使之只显示 bbox 部分。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Preview(props: &#123;</span><br><span class=\"line\">  imgSrc: string;</span><br><span class=\"line\">  imgSize: &#123; width: number; height: number &#125;;</span><br><span class=\"line\">  box: &#123;</span><br><span class=\"line\">    x: number;</span><br><span class=\"line\">    y: number;</span><br><span class=\"line\">    width: number;</span><br><span class=\"line\">    height: number;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  const [containerSize] = useState(&#123; width: 350, height: 400 &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  const scale = Math.min(</span><br><span class=\"line\">    containerSize.width / props.box.width,</span><br><span class=\"line\">    containerSize.height / props.box.height</span><br><span class=\"line\">  );</span><br><span class=\"line\">  const boxCenter = &#123;</span><br><span class=\"line\">    x: props.box.x + props.box.width / 2,</span><br><span class=\"line\">    y: props.box.y + props.box.height / 2</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  const containerCenter = &#123;</span><br><span class=\"line\">    x: containerSize.width / 2,</span><br><span class=\"line\">    y: containerSize.height / 2</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  const tr = &#123;</span><br><span class=\"line\">    x: containerCenter.x - boxCenter.x * scale,</span><br><span class=\"line\">    y: containerCenter.y - boxCenter.y * scale</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div style=&#123;&#123; position: &quot;relative&quot;, ...containerSize, overflow: &quot;hidden&quot; &#125;&#125;&gt;</span><br><span class=\"line\">      &lt;img</span><br><span class=\"line\">        src=&#123;props.imgSrc&#125;</span><br><span class=\"line\">        style=&#123;&#123;</span><br><span class=\"line\">          ...props.imgSize,</span><br><span class=\"line\">          objectFit: &quot;contain&quot;,</span><br><span class=\"line\">          position: &quot;absolute&quot;,</span><br><span class=\"line\">          left: 0,</span><br><span class=\"line\">          top: 0,</span><br><span class=\"line\">          transform: `translate($&#123;tr.x&#125;px, $&#123;tr.y&#125;px) scale($&#123;scale&#125;)`,</span><br><span class=\"line\">          transformOrigin: &quot;top left&quot;,</span><br><span class=\"line\">          transition: &quot;all 0.3s&quot;</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"We Are Graduated!","catalog":true,"date":"2019-06-13T09:53:24.000Z","subtitle":null,"header-img":null,"_content":"\nWe Are Graduated ! 🎓\n\nReady to move on ! 💪","source":"_posts/We Are Graduated!.md","raw":"---\ntitle: We Are Graduated!\ncatalog: true\ndate: 2019-06-13 17:53:24\nsubtitle:\nheader-img:\ntags: Daily\n---\n\nWe Are Graduated ! 🎓\n\nReady to move on ! 💪","slug":"We Are Graduated!","published":1,"updated":"2019-12-08T06:55:16.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5393is20008icuey4qlqq1b","content":"<p>We Are Graduated ! 🎓</p>\n<p>Ready to move on ! 💪</p>\n","site":{"data":{}},"excerpt":"","more":"<p>We Are Graduated ! 🎓</p>\n<p>Ready to move on ! 💪</p>\n"},{"title":"What is Gumbel-Softmax Trick？","catalog":true,"date":"2019-07-16T12:02:54.000Z","subtitle":null,"header-img":null,"mathjax":true,"_content":"\nGumbel-Softmax trick 在VAE、GAN、NAS等深度学习领域经常出现，那它到底是啥，有什么用呢？  \n\n### 背景问题\n首先简要介绍一下问题的背景。假设我们在网络中有一个有 \\\\(n\\\\) 个取值的离散分布\\\\(P(x)\\\\)，也就是一个\\\\(n\\\\)维的向量，每一个元素就是一个概率值。如果我们只是要对其进行采样或者得到最终概率最大的一个取值，我们很容易就可以直接采样或取\\\\(arg \\max\\\\)得到结果。但是，如果我们希望这个过程是可导的，该怎么办呢？\n\n### Re-Parameterization Trick\n首先介绍一个叫重参数化(Re-Parameterization)的东西，Re-Parameterization解决了上面提到的采样不可导的问题。这里用油管上一个[变分自动编码器教程](https://www.youtube.com/watch?v=9zKuYvjFFS8)中的图片来解释。\n![re-paramerise](re-paramerise.png)\n首先左边是重参数化之前的形式，我们希望通过学习到了标准差\\\\(\\phi\\\\)和均值\\\\(x\\\\)，通过对分布\\\\(q\\\\)进行采样得到\\\\(z\\\\)，然后传入下一层网络。然而这就有个问题，采样过程是没法反传的，这样加载网络中就没法学习了，因此就有了右边的形式。  \n\n在这里呢，其实就是在网络中只保留可以求导的部分，把不可导的采样部分放到网络外用一个新的输入节点\\\\(\\epsilon\\\\)表示。\\\\(\\epsilon\\\\)采样的过程和网络学习是分离的，因此不影响网络反传。  \n\n具体而言，假设我们需要根据均值和方差从正太分布\\\\(N(x,\\phi^2)\\\\)采样，我们可以转化为先从\\\\(\\epsilon=N(0,1)\\\\)采样，然后计算\\\\(z=x+\\epsilon\\cdot \\phi\\\\)来得到我们需要的\\\\(z\\\\)。\n\n### Gumbel-Softmax Trick\n通过Re-Parameterization Trick我们可以一定条件下解决采样不可导的问题。但回到我们最初的问题，我们并不是在连续的高斯分布上采样，而是在一个离散分布\\\\(P(x)\\\\)上采样。上面的重参数后是可导的，而换成离散分布以后，就无法满足了。所以，对于离散分布要怎么处理呢？\n类似与前面的重参数技巧，我们对于离散变量有Gumbel-Max trick的采样方法：\n![gumbel-max](gumbel1.png)\n从上图中可以看出，我们将离散变量\\\\(\\log{\\alpha_1}, \\log{\\alpha_2}, \\log{\\alpha_3}\\\\)加上Gumbel噪声，然后对相加后的随机变量取\\\\(\\arg \\max\\\\)后得到一个onehot向量，就是我们的采样结果，可以表示为：\n$$x_{\\alpha}=\\arg\\max(\\log(\\alpha_i)+G_i)$$\n但\\\\(\\arg \\max\\\\)这个操作是没法求导的，那么我们就用softmax来对\\\\(\\arg \\max\\\\)进行松弛，这就得到了我们的Gumbel-Softmax Trick:\n![gumbel-back](gumbel2.png)\n其中，\\\\(\\lambda\\\\)是softmax函数的temperature参数，用于控制采样 当\\\\(\\lambda \\to \\infty\\\\)时，所有的激活值对应的激活概率趋近于相同（激活概率差异性较小）；而当\\\\(\\lambda \\to 0\\\\)，不同的激活值对应的激活概率差异也就越大，也就越趋向于onehot向量。（温度这个词主要来自于物理学中的温度，当温度高的时候，分子的运动就越剧烈，随机性就越大，反之则越稳定，随机性越小）  \n到这里，我们既可以对分布进行采样，又能够满足在网络中可以反向传播学习。  \n但我们可能还会有这样的问题：为什么不直接就用softmax函数呢，这样不是也能在网络中学习么？我们再回顾下我们的问题就能发现，我们需要采样+能反传，softmax满足能反传但是它不能达到我们根据概率分布采样的目的，而Gumbel-Max Trick就是用来近似分布然后采样的。  \n另外，我们在此用到了Gumbel Distribution--\\\\(G\\\\)，是一个极值分布，通俗来讲就是分布的极值的分布，具体可参考：\n[Gumbel distribution](https://en.wikipedia.org/wiki/Gumbel_distribution)\n\n### 参考\n[Gumbel-Softmax Trick和Gumbel分布](https://www.cnblogs.com/initial-h/p/9468974.html)\n[The Gumbel-Softmax Trick for Inference of Discrete Variables](https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html)\n[Variational Autoencoders](https://www.youtube.com/watch?v=9zKuYvjFFS8)\n[带你认识神奇的Gumbel trick](https://blog.csdn.net/a358463121/article/details/80820878)\n[Talk: Categorical Reparameterization with Gumbel-Softmax & The Concrete Distribution](https://www.youtube.com/watch?v=wVkLM2KKHp8)","source":"_posts/What-is-Gumbel-Softmax-Trick.md","raw":"---\ntitle: What is Gumbel-Softmax Trick？\ncatalog: true\ndate: 2019-07-16 20:02:54\nsubtitle:\nheader-img:\nmathjax: true\ntags: ML\n---\n\nGumbel-Softmax trick 在VAE、GAN、NAS等深度学习领域经常出现，那它到底是啥，有什么用呢？  \n\n### 背景问题\n首先简要介绍一下问题的背景。假设我们在网络中有一个有 \\\\(n\\\\) 个取值的离散分布\\\\(P(x)\\\\)，也就是一个\\\\(n\\\\)维的向量，每一个元素就是一个概率值。如果我们只是要对其进行采样或者得到最终概率最大的一个取值，我们很容易就可以直接采样或取\\\\(arg \\max\\\\)得到结果。但是，如果我们希望这个过程是可导的，该怎么办呢？\n\n### Re-Parameterization Trick\n首先介绍一个叫重参数化(Re-Parameterization)的东西，Re-Parameterization解决了上面提到的采样不可导的问题。这里用油管上一个[变分自动编码器教程](https://www.youtube.com/watch?v=9zKuYvjFFS8)中的图片来解释。\n![re-paramerise](re-paramerise.png)\n首先左边是重参数化之前的形式，我们希望通过学习到了标准差\\\\(\\phi\\\\)和均值\\\\(x\\\\)，通过对分布\\\\(q\\\\)进行采样得到\\\\(z\\\\)，然后传入下一层网络。然而这就有个问题，采样过程是没法反传的，这样加载网络中就没法学习了，因此就有了右边的形式。  \n\n在这里呢，其实就是在网络中只保留可以求导的部分，把不可导的采样部分放到网络外用一个新的输入节点\\\\(\\epsilon\\\\)表示。\\\\(\\epsilon\\\\)采样的过程和网络学习是分离的，因此不影响网络反传。  \n\n具体而言，假设我们需要根据均值和方差从正太分布\\\\(N(x,\\phi^2)\\\\)采样，我们可以转化为先从\\\\(\\epsilon=N(0,1)\\\\)采样，然后计算\\\\(z=x+\\epsilon\\cdot \\phi\\\\)来得到我们需要的\\\\(z\\\\)。\n\n### Gumbel-Softmax Trick\n通过Re-Parameterization Trick我们可以一定条件下解决采样不可导的问题。但回到我们最初的问题，我们并不是在连续的高斯分布上采样，而是在一个离散分布\\\\(P(x)\\\\)上采样。上面的重参数后是可导的，而换成离散分布以后，就无法满足了。所以，对于离散分布要怎么处理呢？\n类似与前面的重参数技巧，我们对于离散变量有Gumbel-Max trick的采样方法：\n![gumbel-max](gumbel1.png)\n从上图中可以看出，我们将离散变量\\\\(\\log{\\alpha_1}, \\log{\\alpha_2}, \\log{\\alpha_3}\\\\)加上Gumbel噪声，然后对相加后的随机变量取\\\\(\\arg \\max\\\\)后得到一个onehot向量，就是我们的采样结果，可以表示为：\n$$x_{\\alpha}=\\arg\\max(\\log(\\alpha_i)+G_i)$$\n但\\\\(\\arg \\max\\\\)这个操作是没法求导的，那么我们就用softmax来对\\\\(\\arg \\max\\\\)进行松弛，这就得到了我们的Gumbel-Softmax Trick:\n![gumbel-back](gumbel2.png)\n其中，\\\\(\\lambda\\\\)是softmax函数的temperature参数，用于控制采样 当\\\\(\\lambda \\to \\infty\\\\)时，所有的激活值对应的激活概率趋近于相同（激活概率差异性较小）；而当\\\\(\\lambda \\to 0\\\\)，不同的激活值对应的激活概率差异也就越大，也就越趋向于onehot向量。（温度这个词主要来自于物理学中的温度，当温度高的时候，分子的运动就越剧烈，随机性就越大，反之则越稳定，随机性越小）  \n到这里，我们既可以对分布进行采样，又能够满足在网络中可以反向传播学习。  \n但我们可能还会有这样的问题：为什么不直接就用softmax函数呢，这样不是也能在网络中学习么？我们再回顾下我们的问题就能发现，我们需要采样+能反传，softmax满足能反传但是它不能达到我们根据概率分布采样的目的，而Gumbel-Max Trick就是用来近似分布然后采样的。  \n另外，我们在此用到了Gumbel Distribution--\\\\(G\\\\)，是一个极值分布，通俗来讲就是分布的极值的分布，具体可参考：\n[Gumbel distribution](https://en.wikipedia.org/wiki/Gumbel_distribution)\n\n### 参考\n[Gumbel-Softmax Trick和Gumbel分布](https://www.cnblogs.com/initial-h/p/9468974.html)\n[The Gumbel-Softmax Trick for Inference of Discrete Variables](https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html)\n[Variational Autoencoders](https://www.youtube.com/watch?v=9zKuYvjFFS8)\n[带你认识神奇的Gumbel trick](https://blog.csdn.net/a358463121/article/details/80820878)\n[Talk: Categorical Reparameterization with Gumbel-Softmax & The Concrete Distribution](https://www.youtube.com/watch?v=wVkLM2KKHp8)","slug":"What-is-Gumbel-Softmax-Trick","published":1,"updated":"2019-12-09T16:09:11.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5393is6000bicueedtn9hph","content":"<p>Gumbel-Softmax trick 在VAE、GAN、NAS等深度学习领域经常出现，那它到底是啥，有什么用呢？</p>\n<h3 id=\"背景问题\">背景问题</h3>\n<p>首先简要介绍一下问题的背景。假设我们在网络中有一个有 \\(n\\) 个取值的离散分布\\(P(x)\\)，也就是一个\\(n\\)维的向量，每一个元素就是一个概率值。如果我们只是要对其进行采样或者得到最终概率最大的一个取值，我们很容易就可以直接采样或取\\(arg \\max\\)得到结果。但是，如果我们希望这个过程是可导的，该怎么办呢？</p>\n<h3 id=\"re-parameterization-trick\">Re-Parameterization Trick</h3>\n<p>首先介绍一个叫重参数化(Re-Parameterization)的东西，Re-Parameterization解决了上面提到的采样不可导的问题。这里用油管上一个<a href=\"https://www.youtube.com/watch?v=9zKuYvjFFS8\" target=\"_blank\" rel=\"noopener\">变分自动编码器教程</a>中的图片来解释。<br>\n<img src=\"re-paramerise.png\" alt=\"re-paramerise\"><br>\n首先左边是重参数化之前的形式，我们希望通过学习到了标准差\\(\\phi\\)和均值\\(x\\)，通过对分布\\(q\\)进行采样得到\\(z\\)，然后传入下一层网络。然而这就有个问题，采样过程是没法反传的，这样加载网络中就没法学习了，因此就有了右边的形式。</p>\n<p>在这里呢，其实就是在网络中只保留可以求导的部分，把不可导的采样部分放到网络外用一个新的输入节点\\(\\epsilon\\)表示。\\(\\epsilon\\)采样的过程和网络学习是分离的，因此不影响网络反传。</p>\n<p>具体而言，假设我们需要根据均值和方差从正太分布\\(N(x,\\phi^2)\\)采样，我们可以转化为先从\\(\\epsilon=N(0,1)\\)采样，然后计算\\(z=x+\\epsilon\\cdot \\phi\\)来得到我们需要的\\(z\\)。</p>\n<h3 id=\"gumbel-softmax-trick\">Gumbel-Softmax Trick</h3>\n<p>通过Re-Parameterization Trick我们可以一定条件下解决采样不可导的问题。但回到我们最初的问题，我们并不是在连续的高斯分布上采样，而是在一个离散分布\\(P(x)\\)上采样。上面的重参数后是可导的，而换成离散分布以后，就无法满足了。所以，对于离散分布要怎么处理呢？<br>\n类似与前面的重参数技巧，我们对于离散变量有Gumbel-Max trick的采样方法：<br>\n<img src=\"gumbel1.png\" alt=\"gumbel-max\"><br>\n从上图中可以看出，我们将离散变量\\(\\log{\\alpha_1}, \\log{\\alpha_2}, \\log{\\alpha_3}\\)加上Gumbel噪声，然后对相加后的随机变量取\\(\\arg \\max\\)后得到一个onehot向量，就是我们的采样结果，可以表示为：<br>\n$$x_{\\alpha}=\\arg\\max(\\log(\\alpha_i)+G_i)$$<br>\n但\\(\\arg \\max\\)这个操作是没法求导的，那么我们就用softmax来对\\(\\arg \\max\\)进行松弛，这就得到了我们的Gumbel-Softmax Trick:<br>\n<img src=\"gumbel2.png\" alt=\"gumbel-back\"><br>\n其中，\\(\\lambda\\)是softmax函数的temperature参数，用于控制采样 当\\(\\lambda \\to \\infty\\)时，所有的激活值对应的激活概率趋近于相同（激活概率差异性较小）；而当\\(\\lambda \\to 0\\)，不同的激活值对应的激活概率差异也就越大，也就越趋向于onehot向量。（温度这个词主要来自于物理学中的温度，当温度高的时候，分子的运动就越剧烈，随机性就越大，反之则越稳定，随机性越小）<br>\n到这里，我们既可以对分布进行采样，又能够满足在网络中可以反向传播学习。<br>\n但我们可能还会有这样的问题：为什么不直接就用softmax函数呢，这样不是也能在网络中学习么？我们再回顾下我们的问题就能发现，我们需要采样+能反传，softmax满足能反传但是它不能达到我们根据概率分布采样的目的，而Gumbel-Max Trick就是用来近似分布然后采样的。<br>\n另外，我们在此用到了Gumbel Distribution–\\(G\\)，是一个极值分布，通俗来讲就是分布的极值的分布，具体可参考：<br>\n<a href=\"https://en.wikipedia.org/wiki/Gumbel_distribution\" target=\"_blank\" rel=\"noopener\">Gumbel distribution</a></p>\n<h3 id=\"参考\">参考</h3>\n<p><a href=\"https://www.cnblogs.com/initial-h/p/9468974.html\" target=\"_blank\" rel=\"noopener\">Gumbel-Softmax Trick和Gumbel分布</a><br>\n<a href=\"https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html\" target=\"_blank\" rel=\"noopener\">The Gumbel-Softmax Trick for Inference of Discrete Variables</a><br>\n<a href=\"https://www.youtube.com/watch?v=9zKuYvjFFS8\" target=\"_blank\" rel=\"noopener\">Variational Autoencoders</a><br>\n<a href=\"https://blog.csdn.net/a358463121/article/details/80820878\" target=\"_blank\" rel=\"noopener\">带你认识神奇的Gumbel trick</a><br>\n<a href=\"https://www.youtube.com/watch?v=wVkLM2KKHp8\" target=\"_blank\" rel=\"noopener\">Talk: Categorical Reparameterization with Gumbel-Softmax &amp; The Concrete Distribution</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Gumbel-Softmax trick 在VAE、GAN、NAS等深度学习领域经常出现，那它到底是啥，有什么用呢？</p>\n<h3>背景问题</h3>\n<p>首先简要介绍一下问题的背景。假设我们在网络中有一个有 \\(n\\) 个取值的离散分布\\(P(x)\\)，也就是一个\\(n\\)维的向量，每一个元素就是一个概率值。如果我们只是要对其进行采样或者得到最终概率最大的一个取值，我们很容易就可以直接采样或取\\(arg \\max\\)得到结果。但是，如果我们希望这个过程是可导的，该怎么办呢？</p>\n<h3>Re-Parameterization Trick</h3>\n<p>首先介绍一个叫重参数化(Re-Parameterization)的东西，Re-Parameterization解决了上面提到的采样不可导的问题。这里用油管上一个<a href=\"https://www.youtube.com/watch?v=9zKuYvjFFS8\" target=\"_blank\" rel=\"noopener\">变分自动编码器教程</a>中的图片来解释。<br>\n<img src=\"re-paramerise.png\" alt=\"re-paramerise\"><br>\n首先左边是重参数化之前的形式，我们希望通过学习到了标准差\\(\\phi\\)和均值\\(x\\)，通过对分布\\(q\\)进行采样得到\\(z\\)，然后传入下一层网络。然而这就有个问题，采样过程是没法反传的，这样加载网络中就没法学习了，因此就有了右边的形式。</p>\n<p>在这里呢，其实就是在网络中只保留可以求导的部分，把不可导的采样部分放到网络外用一个新的输入节点\\(\\epsilon\\)表示。\\(\\epsilon\\)采样的过程和网络学习是分离的，因此不影响网络反传。</p>\n<p>具体而言，假设我们需要根据均值和方差从正太分布\\(N(x,\\phi^2)\\)采样，我们可以转化为先从\\(\\epsilon=N(0,1)\\)采样，然后计算\\(z=x+\\epsilon\\cdot \\phi\\)来得到我们需要的\\(z\\)。</p>\n<h3>Gumbel-Softmax Trick</h3>\n<p>通过Re-Parameterization Trick我们可以一定条件下解决采样不可导的问题。但回到我们最初的问题，我们并不是在连续的高斯分布上采样，而是在一个离散分布\\(P(x)\\)上采样。上面的重参数后是可导的，而换成离散分布以后，就无法满足了。所以，对于离散分布要怎么处理呢？<br>\n类似与前面的重参数技巧，我们对于离散变量有Gumbel-Max trick的采样方法：<br>\n<img src=\"gumbel1.png\" alt=\"gumbel-max\"><br>\n从上图中可以看出，我们将离散变量\\(\\log{\\alpha_1}, \\log{\\alpha_2}, \\log{\\alpha_3}\\)加上Gumbel噪声，然后对相加后的随机变量取\\(\\arg \\max\\)后得到一个onehot向量，就是我们的采样结果，可以表示为：<br>\n$$x_{\\alpha}=\\arg\\max(\\log(\\alpha_i)+G_i)$$<br>\n但\\(\\arg \\max\\)这个操作是没法求导的，那么我们就用softmax来对\\(\\arg \\max\\)进行松弛，这就得到了我们的Gumbel-Softmax Trick:<br>\n<img src=\"gumbel2.png\" alt=\"gumbel-back\"><br>\n其中，\\(\\lambda\\)是softmax函数的temperature参数，用于控制采样 当\\(\\lambda \\to \\infty\\)时，所有的激活值对应的激活概率趋近于相同（激活概率差异性较小）；而当\\(\\lambda \\to 0\\)，不同的激活值对应的激活概率差异也就越大，也就越趋向于onehot向量。（温度这个词主要来自于物理学中的温度，当温度高的时候，分子的运动就越剧烈，随机性就越大，反之则越稳定，随机性越小）<br>\n到这里，我们既可以对分布进行采样，又能够满足在网络中可以反向传播学习。<br>\n但我们可能还会有这样的问题：为什么不直接就用softmax函数呢，这样不是也能在网络中学习么？我们再回顾下我们的问题就能发现，我们需要采样+能反传，softmax满足能反传但是它不能达到我们根据概率分布采样的目的，而Gumbel-Max Trick就是用来近似分布然后采样的。<br>\n另外，我们在此用到了Gumbel Distribution–\\(G\\)，是一个极值分布，通俗来讲就是分布的极值的分布，具体可参考：<br>\n<a href=\"https://en.wikipedia.org/wiki/Gumbel_distribution\" target=\"_blank\" rel=\"noopener\">Gumbel distribution</a></p>\n<h3>参考</h3>\n<p><a href=\"https://www.cnblogs.com/initial-h/p/9468974.html\" target=\"_blank\" rel=\"noopener\">Gumbel-Softmax Trick和Gumbel分布</a><br>\n<a href=\"https://casmls.github.io/general/2017/02/01/GumbelSoftmax.html\" target=\"_blank\" rel=\"noopener\">The Gumbel-Softmax Trick for Inference of Discrete Variables</a><br>\n<a href=\"https://www.youtube.com/watch?v=9zKuYvjFFS8\" target=\"_blank\" rel=\"noopener\">Variational Autoencoders</a><br>\n<a href=\"https://blog.csdn.net/a358463121/article/details/80820878\" target=\"_blank\" rel=\"noopener\">带你认识神奇的Gumbel trick</a><br>\n<a href=\"https://www.youtube.com/watch?v=wVkLM2KKHp8\" target=\"_blank\" rel=\"noopener\">Talk: Categorical Reparameterization with Gumbel-Softmax &amp; The Concrete Distribution</a></p>\n"},{"title":"ML Resources Collection","catalog":true,"date":"2019-10-06T09:52:54.000Z","subtitle":null,"header-img":null,"mathjax":true,"_content":"\n## Tools\n\n1. Loss Landscape Visualization \nA tools for visualizing the Loss Landscape of Neural Nets.  \nNote: Support PyTorch 0.4 and 0.4+ is not evaluated.\nLink: [Github](https://github.com/tomgoldstein/loss-landscape)  \n2. Wasabi: A lightweight console printing and formatting toolkit\nNote: Work in progress but no updates since May 2019.\nLink: [Github](https://github.com/ines/wasabi)\n\n\n## Writing Guide\n1. [Research Proposal Guide](https://www.monash.edu/rlo/graduate-research-writing/write-the-thesis/writing-a-research-proposal)\n2. [How to write research paper](https://m.v.qq.com/play.html?&vid=k07751x7n6y&ptag=v_qq_com%23v.play.adaptor%233), 短短16分钟，针针见血，这个看了挺好的\n\n## Blog\n1. [Tim Dettmers](https://timdettmers.com/): UW 的ML PhD，写了些学术思考\n2. [Marvin Petersen\n](https://vinpetersen.github.io/): Dl入门的文章","source":"_posts/Resources.md","raw":"---\ntitle: ML Resources Collection\ncatalog: true\ndate: 2019-10-06 17:52:54\nsubtitle:\nheader-img:\nmathjax: true\ntags: ML\n---\n\n## Tools\n\n1. Loss Landscape Visualization \nA tools for visualizing the Loss Landscape of Neural Nets.  \nNote: Support PyTorch 0.4 and 0.4+ is not evaluated.\nLink: [Github](https://github.com/tomgoldstein/loss-landscape)  \n2. Wasabi: A lightweight console printing and formatting toolkit\nNote: Work in progress but no updates since May 2019.\nLink: [Github](https://github.com/ines/wasabi)\n\n\n## Writing Guide\n1. [Research Proposal Guide](https://www.monash.edu/rlo/graduate-research-writing/write-the-thesis/writing-a-research-proposal)\n2. [How to write research paper](https://m.v.qq.com/play.html?&vid=k07751x7n6y&ptag=v_qq_com%23v.play.adaptor%233), 短短16分钟，针针见血，这个看了挺好的\n\n## Blog\n1. [Tim Dettmers](https://timdettmers.com/): UW 的ML PhD，写了些学术思考\n2. [Marvin Petersen\n](https://vinpetersen.github.io/): Dl入门的文章","slug":"Resources","published":1,"updated":"2020-01-02T02:00:52.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5393is8000dicuen7paidkt","content":"<h2 id=\"tools\">Tools</h2>\n<ol>\n<li>Loss Landscape Visualization<br>\nA tools for visualizing the Loss Landscape of Neural Nets.<br>\nNote: Support PyTorch 0.4 and 0.4+ is not evaluated.<br>\nLink: <a href=\"https://github.com/tomgoldstein/loss-landscape\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n<li>Wasabi: A lightweight console printing and formatting toolkit<br>\nNote: Work in progress but no updates since May 2019.<br>\nLink: <a href=\"https://github.com/ines/wasabi\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n</ol>\n<h2 id=\"writing-guide\">Writing Guide</h2>\n<ol>\n<li><a href=\"https://www.monash.edu/rlo/graduate-research-writing/write-the-thesis/writing-a-research-proposal\" target=\"_blank\" rel=\"noopener\">Research Proposal Guide</a></li>\n<li><a href=\"https://m.v.qq.com/play.html?&amp;vid=k07751x7n6y&amp;ptag=v_qq_com%23v.play.adaptor%233\" target=\"_blank\" rel=\"noopener\">How to write research paper</a>, 短短16分钟，针针见血，这个看了挺好的</li>\n</ol>\n<h2 id=\"blog\">Blog</h2>\n<ol>\n<li><a href=\"https://timdettmers.com/\" target=\"_blank\" rel=\"noopener\">Tim Dettmers</a>: UW 的ML PhD，写了些学术思考</li>\n<li><a href=\"https://vinpetersen.github.io/\" target=\"_blank\" rel=\"noopener\">Marvin Petersen<br>\n</a>: Dl入门的文章</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2>Tools</h2>\n<ol>\n<li>Loss Landscape Visualization<br>\nA tools for visualizing the Loss Landscape of Neural Nets.<br>\nNote: Support PyTorch 0.4 and 0.4+ is not evaluated.<br>\nLink: <a href=\"https://github.com/tomgoldstein/loss-landscape\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n<li>Wasabi: A lightweight console printing and formatting toolkit<br>\nNote: Work in progress but no updates since May 2019.<br>\nLink: <a href=\"https://github.com/ines/wasabi\" target=\"_blank\" rel=\"noopener\">Github</a></li>\n</ol>\n<h2>Writing Guide</h2>\n<ol>\n<li><a href=\"https://www.monash.edu/rlo/graduate-research-writing/write-the-thesis/writing-a-research-proposal\" target=\"_blank\" rel=\"noopener\">Research Proposal Guide</a></li>\n<li><a href=\"https://m.v.qq.com/play.html?&amp;vid=k07751x7n6y&amp;ptag=v_qq_com%23v.play.adaptor%233\" target=\"_blank\" rel=\"noopener\">How to write research paper</a>, 短短16分钟，针针见血，这个看了挺好的</li>\n</ol>\n<h2>Blog</h2>\n<ol>\n<li><a href=\"https://timdettmers.com/\" target=\"_blank\" rel=\"noopener\">Tim Dettmers</a>: UW 的ML PhD，写了些学术思考</li>\n<li><a href=\"https://vinpetersen.github.io/\" target=\"_blank\" rel=\"noopener\">Marvin Petersen<br>\n</a>: Dl入门的文章</li>\n</ol>\n"},{"title":"Technical Docs Collection involved in FE work","catalog":true,"date":"2020-01-07T02:24:22.000Z","subtitle":null,"header-img":null,"_content":"#### Docker\n- [官方文档](https://docs.docker.com/)\n\n#### Sentry\n- [官方文档](https://docs.sentry.io/)\n\n#### JWT\n- [Introduction to JSON Web Tokens](https://jwt.io/introduction/)\n\n#### JEST\n- [官方文档](https://jestjs.io/docs/en/getting-started)\n\n#### Enzyme\n- [API introduction](https://airbnb.io/enzyme/)\n\n#### Rxjs\n- [官方文档](https://rxjs-dev.firebaseapp.com/guide/overview)\n- [Learn RxJS](https://www.learnrxjs.io/)\n- [RxJS Marbles: Interactive diagrams of Rx Observables](https://rxmarbles.com/)\n\n#### Protocol Buffers\n- [google docs](https://developers.google.com/protocol-buffers)","source":"_posts/一些工作中涉及到的技术文档集合.md","raw":"---\ntitle: Technical Docs Collection involved in FE work\ncatalog: true\ndate: 2020-01-07 10:24:22\nsubtitle:\nheader-img:\ntags: FE\n---\n#### Docker\n- [官方文档](https://docs.docker.com/)\n\n#### Sentry\n- [官方文档](https://docs.sentry.io/)\n\n#### JWT\n- [Introduction to JSON Web Tokens](https://jwt.io/introduction/)\n\n#### JEST\n- [官方文档](https://jestjs.io/docs/en/getting-started)\n\n#### Enzyme\n- [API introduction](https://airbnb.io/enzyme/)\n\n#### Rxjs\n- [官方文档](https://rxjs-dev.firebaseapp.com/guide/overview)\n- [Learn RxJS](https://www.learnrxjs.io/)\n- [RxJS Marbles: Interactive diagrams of Rx Observables](https://rxmarbles.com/)\n\n#### Protocol Buffers\n- [google docs](https://developers.google.com/protocol-buffers)","slug":"一些工作中涉及到的技术文档集合","published":1,"updated":"2020-01-09T01:40:30.731Z","_id":"ck5393isc000gicuekop03fij","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h4><ul>\n<li><a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"sentry\"><a href=\"#Sentry\" class=\"headerlink\" title=\"Sentry\"></a>Sentry</h4><ul>\n<li><a href=\"https://docs.sentry.io/\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"jwt\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h4><ul>\n<li><a href=\"https://jwt.io/introduction/\" target=\"_blank\" rel=\"noopener\">Introduction to JSON Web Tokens</a></li>\n</ul>\n<h4 id=\"jest\"><a href=\"#JEST\" class=\"headerlink\" title=\"JEST\"></a>JEST</h4><ul>\n<li><a href=\"https://jestjs.io/docs/en/getting-started\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"enzyme\"><a href=\"#Enzyme\" class=\"headerlink\" title=\"Enzyme\"></a>Enzyme</h4><ul>\n<li><a href=\"https://airbnb.io/enzyme/\" target=\"_blank\" rel=\"noopener\">API introduction</a></li>\n</ul>\n<h4 id=\"rxjs\"><a href=\"#Rxjs\" class=\"headerlink\" title=\"Rxjs\"></a>Rxjs</h4><ul>\n<li><a href=\"https://rxjs-dev.firebaseapp.com/guide/overview\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li><a href=\"https://www.learnrxjs.io/\" target=\"_blank\" rel=\"noopener\">Learn RxJS</a></li>\n<li><a href=\"https://rxmarbles.com/\" target=\"_blank\" rel=\"noopener\">RxJS Marbles: Interactive diagrams of Rx Observables</a></li>\n</ul>\n<h4 id=\"protocol-buffers\"><a href=\"#Protocol-Buffers\" class=\"headerlink\" title=\"Protocol Buffers\"></a>Protocol Buffers</h4><ul>\n<li><a href=\"https://developers.google.com/protocol-buffers\" target=\"_blank\" rel=\"noopener\">google docs</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h4><ul>\n<li><a href=\"https://docs.docker.com/\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"Sentry\"><a href=\"#Sentry\" class=\"headerlink\" title=\"Sentry\"></a>Sentry</h4><ul>\n<li><a href=\"https://docs.sentry.io/\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h4><ul>\n<li><a href=\"https://jwt.io/introduction/\" target=\"_blank\" rel=\"noopener\">Introduction to JSON Web Tokens</a></li>\n</ul>\n<h4 id=\"JEST\"><a href=\"#JEST\" class=\"headerlink\" title=\"JEST\"></a>JEST</h4><ul>\n<li><a href=\"https://jestjs.io/docs/en/getting-started\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n</ul>\n<h4 id=\"Enzyme\"><a href=\"#Enzyme\" class=\"headerlink\" title=\"Enzyme\"></a>Enzyme</h4><ul>\n<li><a href=\"https://airbnb.io/enzyme/\" target=\"_blank\" rel=\"noopener\">API introduction</a></li>\n</ul>\n<h4 id=\"Rxjs\"><a href=\"#Rxjs\" class=\"headerlink\" title=\"Rxjs\"></a>Rxjs</h4><ul>\n<li><a href=\"https://rxjs-dev.firebaseapp.com/guide/overview\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li><a href=\"https://www.learnrxjs.io/\" target=\"_blank\" rel=\"noopener\">Learn RxJS</a></li>\n<li><a href=\"https://rxmarbles.com/\" target=\"_blank\" rel=\"noopener\">RxJS Marbles: Interactive diagrams of Rx Observables</a></li>\n</ul>\n<h4 id=\"Protocol-Buffers\"><a href=\"#Protocol-Buffers\" class=\"headerlink\" title=\"Protocol Buffers\"></a>Protocol Buffers</h4><ul>\n<li><a href=\"https://developers.google.com/protocol-buffers\" target=\"_blank\" rel=\"noopener\">google docs</a></li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/re-paramerise.png","slug":"re-paramerise.png","post":"ck5393is6000bicueedtn9hph","modified":0,"renderable":0},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/gumbel2.png","slug":"gumbel2.png","post":"ck5393is6000bicueedtn9hph","modified":0,"renderable":0},{"_id":"source/_posts/FrontEnd-Daily-Learning/FE_20190806.png","slug":"FE_20190806.png","post":"ck5393irz0006icuer01dr8er","modified":0,"renderable":0},{"_id":"source/_posts/FrontEnd-Daily-Learning/FE_20190808.png","slug":"FE_20190808.png","post":"ck5393irz0006icuer01dr8er","modified":0,"renderable":0},{"_id":"source/_posts/FrontEnd-Daily-Learning/FE_20190809.png","slug":"FE_20190809.png","post":"ck5393irz0006icuer01dr8er","modified":0,"renderable":0},{"_id":"source/_posts/What-is-Gumbel-Softmax-Trick/gumbel1.png","slug":"gumbel1.png","post":"ck5393is6000bicueedtn9hph","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ck5393is00007icuegsdu99f2","tag_id":"ck5393irx0005icuev2tgrh5u","_id":"ck5393is5000aicuemydbki7i"},{"post_id":"ck5393irp0001icue4956j72g","tag_id":"ck5393irx0005icuev2tgrh5u","_id":"ck5393is7000cicue86rm2tyh"},{"post_id":"ck5393iru0003icuef84ro4rr","tag_id":"ck5393irx0005icuev2tgrh5u","_id":"ck5393isc000ficueh7cwsjja"},{"post_id":"ck5393irz0006icuer01dr8er","tag_id":"ck5393irx0005icuev2tgrh5u","_id":"ck5393ise000iicuezmku4bta"},{"post_id":"ck5393is20008icuey4qlqq1b","tag_id":"ck5393isd000hicuepco5afvk","_id":"ck5393isg000kicue71uj0bsl"},{"post_id":"ck5393is6000bicueedtn9hph","tag_id":"ck5393ise000jicue5vj2aphk","_id":"ck5393isg000micueqs29sggh"},{"post_id":"ck5393is8000dicuen7paidkt","tag_id":"ck5393ise000jicue5vj2aphk","_id":"ck5393ish000nicueltzvei88"},{"post_id":"ck5393isc000gicuekop03fij","tag_id":"ck5393irx0005icuev2tgrh5u","_id":"ck56710zr0000okuets7zxuoz"}],"Tag":[{"name":"FE","_id":"ck5393irx0005icuev2tgrh5u"},{"name":"Daily","_id":"ck5393isd000hicuepco5afvk"},{"name":"ML","_id":"ck5393ise000jicue5vj2aphk"}]}}